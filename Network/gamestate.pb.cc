// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Network/gamestate.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ast {

namespace {

const ::google::protobuf::Descriptor* Vector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Weapon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Weapon_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientCommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timer_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameState_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollisionMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollisionMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChatMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChatMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateEntityMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateEntityMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* Frame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Frame_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Network_2fgamestate_2eproto() {
  protobuf_AddDesc_Network_2fgamestate_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Network/gamestate.proto");
  GOOGLE_CHECK(file != NULL);
  Vector_descriptor_ = file->message_type(0);
  static const int Vector_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, z_),
  };
  Vector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vector_descriptor_,
      Vector::default_instance_,
      Vector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vector));
  Entity_descriptor_ = file->message_type(1);
  static const int Entity_offsets_[58] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, weapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, up_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, forward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, axis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, rotationspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetyawspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetpitchspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetrollspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, healthmax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, enginelevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, regenhealthlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, banklevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, color1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, color2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, shotdirection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isfiring_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, currentweapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbarrelrollingleft_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbarrelrollingright_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, curforwardaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, currightaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, curupaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbraking_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, bankperiod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, flyingaienabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, shootingaienabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, banktimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, alivetimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, respawntimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timelefttorespawn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, kills_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, deaths_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, lives_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, bankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, unbankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, totalbankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, ownerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, lifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timefired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, weaponindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, damage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, chargetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, damagepersecond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timesinceexploded_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, energyhit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timelasthitbyenergy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, shouldremove_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, releasedshards_),
  };
  Entity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entity));
  Weapon_descriptor_ = file->message_type(2);
  static const int Weapon_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, activationtimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, timelastfired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, cooldown_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, damage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, currentheat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, shotsfired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, timestartedfiring_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, shotid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, purchased_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, weaponprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, overheatlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, heatpershot_),
  };
  Weapon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Weapon_descriptor_,
      Weapon::default_instance_,
      Weapon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Weapon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Weapon));
  ClientCommand_descriptor_ = file->message_type(3);
  static const int ClientCommand_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, shipid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, forwardacceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, rightacceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, upacceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, brake_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, yawspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, rollspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, pitchspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, fire_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, curweapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, mousex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, mousey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, lastreceivedgamestateid_),
  };
  ClientCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientCommand_descriptor_,
      ClientCommand::default_instance_,
      ClientCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientCommand));
  Timer_descriptor_ = file->message_type(4);
  static const int Timer_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, timestarted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, countdowntime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, timepaused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, ispaused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, isrunning_),
  };
  Timer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Timer_descriptor_,
      Timer::default_instance_,
      Timer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Timer));
  GameState_descriptor_ = file->message_type(5);
  static const int GameState_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, gametime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, playership_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, leveltimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, curlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, id_),
  };
  GameState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameState_descriptor_,
      GameState::default_instance_,
      GameState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameState));
  CollisionMessage_descriptor_ = file->message_type(6);
  static const int CollisionMessage_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, gamestateid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, collider_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_bottom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_front_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, wall_back_),
  };
  CollisionMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollisionMessage_descriptor_,
      CollisionMessage::default_instance_,
      CollisionMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollisionMessage));
  ChatMessage_descriptor_ = file->message_type(7);
  static const int ChatMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, sourceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, text_),
  };
  ChatMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChatMessage_descriptor_,
      ChatMessage::default_instance_,
      ChatMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChatMessage));
  CreateEntityMessage_descriptor_ = file->message_type(8);
  static const int CreateEntityMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, createentitymessageid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, entity_),
  };
  CreateEntityMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateEntityMessage_descriptor_,
      CreateEntityMessage::default_instance_,
      CreateEntityMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateEntityMessage));
  Frame_descriptor_ = file->message_type(9);
  static const int Frame_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, collision_message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, chatmessage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, ack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, remove_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, firing_ships_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, diff_of_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, gamestate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, shipid_),
  };
  Frame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Frame_descriptor_,
      Frame::default_instance_,
      Frame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Frame));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Network_2fgamestate_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vector_descriptor_, &Vector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Weapon_descriptor_, &Weapon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientCommand_descriptor_, &ClientCommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Timer_descriptor_, &Timer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameState_descriptor_, &GameState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollisionMessage_descriptor_, &CollisionMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChatMessage_descriptor_, &ChatMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateEntityMessage_descriptor_, &CreateEntityMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Frame_descriptor_, &Frame::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Network_2fgamestate_2eproto() {
  delete Vector::default_instance_;
  delete Vector_reflection_;
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete Weapon::default_instance_;
  delete Weapon_reflection_;
  delete ClientCommand::default_instance_;
  delete ClientCommand_reflection_;
  delete Timer::default_instance_;
  delete Timer_reflection_;
  delete GameState::default_instance_;
  delete GameState_reflection_;
  delete CollisionMessage::default_instance_;
  delete CollisionMessage_reflection_;
  delete ChatMessage::default_instance_;
  delete ChatMessage_reflection_;
  delete CreateEntityMessage::default_instance_;
  delete CreateEntityMessage_reflection_;
  delete Frame::default_instance_;
  delete Frame_reflection_;
}

void protobuf_AddDesc_Network_2fgamestate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027Network/gamestate.proto\022\003ast\")\n\006Vector"
    "\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\253\n\n\006En"
    "tity\022\n\n\002id\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022\035\n\010positi"
    "on\030\003 \001(\0132\013.ast.Vector\022\035\n\010velocity\030\004 \001(\0132"
    "\013.ast.Vector\022\033\n\006weapon\030\005 \003(\0132\013.ast.Weapo"
    "n\022\027\n\002up\030\006 \001(\0132\013.ast.Vector\022\032\n\005right\030\007 \001("
    "\0132\013.ast.Vector\022\034\n\007forward\030\010 \001(\0132\013.ast.Ve"
    "ctor\022\016\n\006radius\030\023 \001(\002\022\031\n\004axis\030\025 \001(\0132\013.ast"
    ".Vector\022\r\n\005angle\030\031 \001(\002\022\025\n\rrotationSpeed\030"
    "\032 \001(\002\022\026\n\016targetYawSpeed\030\033 \001(\002\022\030\n\020targetP"
    "itchSpeed\030\034 \001(\002\022\027\n\017targetRollSpeed\030\035 \001(\002"
    "\022\016\n\006health\030\036 \001(\002\022\021\n\thealthMax\030\037 \001(\002\022\023\n\013e"
    "ngineLevel\030  \001(\005\022\030\n\020regenHealthLevel\030! \001"
    "(\005\022\021\n\tbankLevel\030\" \001(\005\022\016\n\006color1\030# \001(\002\022\016\n"
    "\006color2\030$ \001(\002\022\"\n\rshotDirection\030% \001(\0132\013.a"
    "st.Vector\022\020\n\010isFiring\030& \001(\010\022\025\n\rcurrentWe"
    "apon\030\' \001(\005\022\033\n\023isBarrelRollingLeft\030( \001(\002\022"
    "\034\n\024isBarrelRollingRight\030) \001(\002\022\027\n\017curForw"
    "ardAccel\030* \001(\002\022\025\n\rcurRightAccel\030+ \001(\002\022\022\n"
    "\ncurUpAccel\030, \001(\002\022\021\n\tisBraking\030- \001(\010\022\022\n\n"
    "bankPeriod\030. \001(\002\022\027\n\017flyingAIEnabled\030/ \001("
    "\010\022\031\n\021shootingAIEnabled\0300 \001(\010\022\035\n\tbankTime"
    "r\0301 \001(\0132\n.ast.Timer\022\036\n\naliveTimer\0302 \001(\0132"
    "\n.ast.Timer\022 \n\014respawnTimer\0303 \001(\0132\n.ast."
    "Timer\022\031\n\021timeLeftToRespawn\0304 \001(\002\022\r\n\005scor"
    "e\0305 \001(\005\022\r\n\005kills\0306 \001(\005\022\016\n\006deaths\0307 \001(\005\022\r"
    "\n\005lives\0308 \001(\005\022\024\n\014bankedShards\0309 \001(\005\022\026\n\016u"
    "nbankedShards\030: \001(\005\022\031\n\021totalBankedShards"
    "\030; \001(\005\022\017\n\007ownerid\030< \001(\r\022\020\n\010lifetime\030= \001("
    "\002\022\021\n\ttimeFired\030> \001(\002\022\023\n\013weaponIndex\030\? \001("
    "\005\022\016\n\006damage\030@ \001(\002\022\022\n\nchargeTime\030A \001(\002\022\027\n"
    "\017damagePerSecond\030B \001(\002\022\031\n\021timeSinceExplo"
    "ded\030C \001(\002\022\021\n\tenergyHit\030D \001(\010\022\033\n\023timeLast"
    "HitByEnergy\030E \001(\002\022\024\n\014shouldRemove\030F \001(\010\022"
    "\016\n\006length\030G \001(\002\022\026\n\016releasedShards\030H \001(\005\""
    "\273\002\n\006Weapon\022\r\n\005index\030\001 \002(\r\022#\n\017activationT"
    "imer\030\002 \001(\0132\n.ast.Timer\022\025\n\rtimeLastFired\030"
    "\003 \001(\002\022\020\n\010coolDown\030\004 \001(\002\022\016\n\006damage\030\005 \001(\002\022"
    "\023\n\013currentHeat\030\006 \001(\002\022\022\n\nshotsFired\030\007 \001(\005"
    "\022\031\n\021timeStartedFiring\030\010 \001(\002\022\016\n\006shotid\030\t "
    "\001(\r\022\021\n\tpurchased\030\n \001(\010\022\023\n\013weaponPrice\030\013 "
    "\001(\005\022\r\n\005level\030\014 \001(\005\022\r\n\005range\030\r \001(\002\022\025\n\rove"
    "rheatLevel\030\016 \001(\002\022\023\n\013heatPerShot\030\017 \001(\002\"\231\002"
    "\n\rClientCommand\022\016\n\006shipID\030\001 \002(\r\022\033\n\023forwa"
    "rdAcceleration\030\002 \001(\021\022\031\n\021rightAcceleratio"
    "n\030\003 \001(\021\022\026\n\016upAcceleration\030\004 \001(\021\022\r\n\005brake"
    "\030\005 \001(\010\022\020\n\010yawSpeed\030\006 \001(\002\022\021\n\trollSpeed\030\007 "
    "\001(\002\022\022\n\npitchSpeed\030\010 \001(\002\022\014\n\004fire\030\t \001(\010\022\021\n"
    "\tcurWeapon\030\n \001(\r\022\016\n\006mouseX\030\013 \001(\002\022\016\n\006mous"
    "eY\030\014 \001(\002\022\037\n\027lastReceivedGameStateId\030\r \001("
    "\r\"l\n\005Timer\022\023\n\013timeStarted\030\001 \001(\002\022\025\n\rcount"
    "DownTime\030\002 \001(\002\022\022\n\ntimePaused\030\003 \001(\002\022\020\n\010is"
    "Paused\030\004 \001(\010\022\021\n\tisRunning\030\005 \001(\010\"\214\001\n\tGame"
    "State\022\033\n\006entity\030\001 \003(\0132\013.ast.Entity\022\020\n\010ga"
    "meTime\030\002 \002(\001\022\022\n\nplayerShip\030\003 \001(\r\022\036\n\nleve"
    "lTimer\030\004 \001(\0132\n.ast.Timer\022\020\n\010curLevel\030\005 \001"
    "(\005\022\n\n\002id\030\006 \001(\r\"\312\001\n\020CollisionMessage\022\023\n\013g"
    "amestateid\030\001 \001(\r\022\024\n\010collider\030\002 \003(\rB\002\020\001\022\024"
    "\n\010wall_top\030\003 \003(\rB\002\020\001\022\027\n\013wall_bottom\030\004 \003("
    "\rB\002\020\001\022\025\n\twall_left\030\005 \003(\rB\002\020\001\022\026\n\nwall_rig"
    "ht\030\006 \003(\rB\002\020\001\022\026\n\nwall_front\030\007 \003(\rB\002\020\001\022\025\n\t"
    "wall_back\030\010 \003(\rB\002\020\001\"-\n\013ChatMessage\022\020\n\010so"
    "urceid\030\001 \001(\r\022\014\n\004text\030\002 \001(\t\"Q\n\023CreateEnti"
    "tyMessage\022\035\n\025createEntityMessageid\030\001 \001(\r"
    "\022\033\n\006entity\030\002 \003(\0132\013.ast.Entity\"\202\002\n\005Frame\022"
    "0\n\021collision_message\030\001 \003(\0132\025.ast.Collisi"
    "onMessage\022%\n\013chatMessage\030\002 \003(\0132\020.ast.Cha"
    "tMessage\022\013\n\003seq\030\003 \001(\004\022\013\n\003ack\030\004 \001(\004\022\021\n\tti"
    "mestamp\030\005 \001(\001\022\025\n\tremove_id\030\006 \003(\rB\002\020\001\022\030\n\014"
    "firing_ships\030\007 \003(\rB\002\020\001\022\017\n\007diff_of\030\010 \001(\r\022"
    "!\n\tgameState\030\t \001(\0132\016.ast.GameState\022\016\n\006sh"
    "ipid\030\n \001(\r", 2850);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Network/gamestate.proto", &protobuf_RegisterTypes);
  Vector::default_instance_ = new Vector();
  Entity::default_instance_ = new Entity();
  Weapon::default_instance_ = new Weapon();
  ClientCommand::default_instance_ = new ClientCommand();
  Timer::default_instance_ = new Timer();
  GameState::default_instance_ = new GameState();
  CollisionMessage::default_instance_ = new CollisionMessage();
  ChatMessage::default_instance_ = new ChatMessage();
  CreateEntityMessage::default_instance_ = new CreateEntityMessage();
  Frame::default_instance_ = new Frame();
  Vector::default_instance_->InitAsDefaultInstance();
  Entity::default_instance_->InitAsDefaultInstance();
  Weapon::default_instance_->InitAsDefaultInstance();
  ClientCommand::default_instance_->InitAsDefaultInstance();
  Timer::default_instance_->InitAsDefaultInstance();
  GameState::default_instance_->InitAsDefaultInstance();
  CollisionMessage::default_instance_->InitAsDefaultInstance();
  ChatMessage::default_instance_->InitAsDefaultInstance();
  CreateEntityMessage::default_instance_->InitAsDefaultInstance();
  Frame::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Network_2fgamestate_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Network_2fgamestate_2eproto {
  StaticDescriptorInitializer_Network_2fgamestate_2eproto() {
    protobuf_AddDesc_Network_2fgamestate_2eproto();
  }
} static_descriptor_initializer_Network_2fgamestate_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Vector::kXFieldNumber;
const int Vector::kYFieldNumber;
const int Vector::kZFieldNumber;
#endif  // !_MSC_VER

Vector::Vector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Vector::InitAsDefaultInstance() {
}

Vector::Vector(const Vector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Vector::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector::~Vector() {
  SharedDtor();
}

void Vector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector_descriptor_;
}

const Vector& Vector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Vector* Vector::default_instance_ = NULL;

Vector* Vector::New() const {
  return new Vector;
}

void Vector::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }
      
      // required double y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }
      
      // required double z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }
  
  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }
  
  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Vector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }
  
  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }
  
  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Vector::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }
    
    // required double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }
    
    // required double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vector::MergeFrom(const Vector& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector::CopyFrom(const Vector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Vector::Swap(Vector* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector_descriptor_;
  metadata.reflection = Vector_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entity::kIdFieldNumber;
const int Entity::kTypeFieldNumber;
const int Entity::kPositionFieldNumber;
const int Entity::kVelocityFieldNumber;
const int Entity::kWeaponFieldNumber;
const int Entity::kUpFieldNumber;
const int Entity::kRightFieldNumber;
const int Entity::kForwardFieldNumber;
const int Entity::kRadiusFieldNumber;
const int Entity::kAxisFieldNumber;
const int Entity::kAngleFieldNumber;
const int Entity::kRotationSpeedFieldNumber;
const int Entity::kTargetYawSpeedFieldNumber;
const int Entity::kTargetPitchSpeedFieldNumber;
const int Entity::kTargetRollSpeedFieldNumber;
const int Entity::kHealthFieldNumber;
const int Entity::kHealthMaxFieldNumber;
const int Entity::kEngineLevelFieldNumber;
const int Entity::kRegenHealthLevelFieldNumber;
const int Entity::kBankLevelFieldNumber;
const int Entity::kColor1FieldNumber;
const int Entity::kColor2FieldNumber;
const int Entity::kShotDirectionFieldNumber;
const int Entity::kIsFiringFieldNumber;
const int Entity::kCurrentWeaponFieldNumber;
const int Entity::kIsBarrelRollingLeftFieldNumber;
const int Entity::kIsBarrelRollingRightFieldNumber;
const int Entity::kCurForwardAccelFieldNumber;
const int Entity::kCurRightAccelFieldNumber;
const int Entity::kCurUpAccelFieldNumber;
const int Entity::kIsBrakingFieldNumber;
const int Entity::kBankPeriodFieldNumber;
const int Entity::kFlyingAIEnabledFieldNumber;
const int Entity::kShootingAIEnabledFieldNumber;
const int Entity::kBankTimerFieldNumber;
const int Entity::kAliveTimerFieldNumber;
const int Entity::kRespawnTimerFieldNumber;
const int Entity::kTimeLeftToRespawnFieldNumber;
const int Entity::kScoreFieldNumber;
const int Entity::kKillsFieldNumber;
const int Entity::kDeathsFieldNumber;
const int Entity::kLivesFieldNumber;
const int Entity::kBankedShardsFieldNumber;
const int Entity::kUnbankedShardsFieldNumber;
const int Entity::kTotalBankedShardsFieldNumber;
const int Entity::kOwneridFieldNumber;
const int Entity::kLifetimeFieldNumber;
const int Entity::kTimeFiredFieldNumber;
const int Entity::kWeaponIndexFieldNumber;
const int Entity::kDamageFieldNumber;
const int Entity::kChargeTimeFieldNumber;
const int Entity::kDamagePerSecondFieldNumber;
const int Entity::kTimeSinceExplodedFieldNumber;
const int Entity::kEnergyHitFieldNumber;
const int Entity::kTimeLastHitByEnergyFieldNumber;
const int Entity::kShouldRemoveFieldNumber;
const int Entity::kLengthFieldNumber;
const int Entity::kReleasedShardsFieldNumber;
#endif  // !_MSC_VER

Entity::Entity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entity::InitAsDefaultInstance() {
  position_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  velocity_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  up_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  right_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  forward_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  axis_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  shotdirection_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  banktimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
  alivetimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
  respawntimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entity::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  type_ = 0u;
  position_ = NULL;
  velocity_ = NULL;
  up_ = NULL;
  right_ = NULL;
  forward_ = NULL;
  radius_ = 0;
  axis_ = NULL;
  angle_ = 0;
  rotationspeed_ = 0;
  targetyawspeed_ = 0;
  targetpitchspeed_ = 0;
  targetrollspeed_ = 0;
  health_ = 0;
  healthmax_ = 0;
  enginelevel_ = 0;
  regenhealthlevel_ = 0;
  banklevel_ = 0;
  color1_ = 0;
  color2_ = 0;
  shotdirection_ = NULL;
  isfiring_ = false;
  currentweapon_ = 0;
  isbarrelrollingleft_ = 0;
  isbarrelrollingright_ = 0;
  curforwardaccel_ = 0;
  currightaccel_ = 0;
  curupaccel_ = 0;
  isbraking_ = false;
  bankperiod_ = 0;
  flyingaienabled_ = false;
  shootingaienabled_ = false;
  banktimer_ = NULL;
  alivetimer_ = NULL;
  respawntimer_ = NULL;
  timelefttorespawn_ = 0;
  score_ = 0;
  kills_ = 0;
  deaths_ = 0;
  lives_ = 0;
  bankedshards_ = 0;
  unbankedshards_ = 0;
  totalbankedshards_ = 0;
  ownerid_ = 0u;
  lifetime_ = 0;
  timefired_ = 0;
  weaponindex_ = 0;
  damage_ = 0;
  chargetime_ = 0;
  damagepersecond_ = 0;
  timesinceexploded_ = 0;
  energyhit_ = false;
  timelasthitbyenergy_ = 0;
  shouldremove_ = false;
  length_ = 0;
  releasedshards_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  SharedDtor();
}

void Entity::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete velocity_;
    delete up_;
    delete right_;
    delete forward_;
    delete axis_;
    delete shotdirection_;
    delete banktimer_;
    delete alivetimer_;
    delete respawntimer_;
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New() const {
  return new Entity;
}

void Entity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    type_ = 0u;
    if (has_position()) {
      if (position_ != NULL) position_->::ast::Vector::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::ast::Vector::Clear();
    }
    if (has_up()) {
      if (up_ != NULL) up_->::ast::Vector::Clear();
    }
    if (has_right()) {
      if (right_ != NULL) right_->::ast::Vector::Clear();
    }
    if (has_forward()) {
      if (forward_ != NULL) forward_->::ast::Vector::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    radius_ = 0;
    if (has_axis()) {
      if (axis_ != NULL) axis_->::ast::Vector::Clear();
    }
    angle_ = 0;
    rotationspeed_ = 0;
    targetyawspeed_ = 0;
    targetpitchspeed_ = 0;
    targetrollspeed_ = 0;
    health_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    healthmax_ = 0;
    enginelevel_ = 0;
    regenhealthlevel_ = 0;
    banklevel_ = 0;
    color1_ = 0;
    color2_ = 0;
    if (has_shotdirection()) {
      if (shotdirection_ != NULL) shotdirection_->::ast::Vector::Clear();
    }
    isfiring_ = false;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    currentweapon_ = 0;
    isbarrelrollingleft_ = 0;
    isbarrelrollingright_ = 0;
    curforwardaccel_ = 0;
    currightaccel_ = 0;
    curupaccel_ = 0;
    isbraking_ = false;
    bankperiod_ = 0;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    flyingaienabled_ = false;
    shootingaienabled_ = false;
    if (has_banktimer()) {
      if (banktimer_ != NULL) banktimer_->::ast::Timer::Clear();
    }
    if (has_alivetimer()) {
      if (alivetimer_ != NULL) alivetimer_->::ast::Timer::Clear();
    }
    if (has_respawntimer()) {
      if (respawntimer_ != NULL) respawntimer_->::ast::Timer::Clear();
    }
    timelefttorespawn_ = 0;
    score_ = 0;
    kills_ = 0;
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    deaths_ = 0;
    lives_ = 0;
    bankedshards_ = 0;
    unbankedshards_ = 0;
    totalbankedshards_ = 0;
    ownerid_ = 0u;
    lifetime_ = 0;
    timefired_ = 0;
  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    weaponindex_ = 0;
    damage_ = 0;
    chargetime_ = 0;
    damagepersecond_ = 0;
    timesinceexploded_ = 0;
    energyhit_ = false;
    timelasthitbyenergy_ = 0;
    shouldremove_ = false;
  }
  if (_has_bits_[56 / 32] & (0xffu << (56 % 32))) {
    length_ = 0;
    releasedshards_ = 0;
  }
  weapon_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // optional uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }
      
      // optional .ast.Vector position = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_velocity;
        break;
      }
      
      // optional .ast.Vector velocity = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_weapon;
        break;
      }
      
      // repeated .ast.Weapon weapon = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_weapon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_weapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_weapon;
        if (input->ExpectTag(50)) goto parse_up;
        break;
      }
      
      // optional .ast.Vector up = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_up:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_up()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_right;
        break;
      }
      
      // optional .ast.Vector right = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_forward;
        break;
      }
      
      // optional .ast.Vector forward = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_forward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_forward()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(157)) goto parse_radius;
        break;
      }
      
      // optional float radius = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_axis;
        break;
      }
      
      // optional .ast.Vector axis = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_axis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axis()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(205)) goto parse_angle;
        break;
      }
      
      // optional float angle = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(213)) goto parse_rotationSpeed;
        break;
      }
      
      // optional float rotationSpeed = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotationSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotationspeed_)));
          set_has_rotationspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(221)) goto parse_targetYawSpeed;
        break;
      }
      
      // optional float targetYawSpeed = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetYawSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetyawspeed_)));
          set_has_targetyawspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(229)) goto parse_targetPitchSpeed;
        break;
      }
      
      // optional float targetPitchSpeed = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetPitchSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetpitchspeed_)));
          set_has_targetpitchspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(237)) goto parse_targetRollSpeed;
        break;
      }
      
      // optional float targetRollSpeed = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetRollSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetrollspeed_)));
          set_has_targetrollspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(245)) goto parse_health;
        break;
      }
      
      // optional float health = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(253)) goto parse_healthMax;
        break;
      }
      
      // optional float healthMax = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_healthMax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &healthmax_)));
          set_has_healthmax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(256)) goto parse_engineLevel;
        break;
      }
      
      // optional int32 engineLevel = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_engineLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enginelevel_)));
          set_has_enginelevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(264)) goto parse_regenHealthLevel;
        break;
      }
      
      // optional int32 regenHealthLevel = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_regenHealthLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &regenhealthlevel_)));
          set_has_regenhealthlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(272)) goto parse_bankLevel;
        break;
      }
      
      // optional int32 bankLevel = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bankLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &banklevel_)));
          set_has_banklevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(285)) goto parse_color1;
        break;
      }
      
      // optional float color1 = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color1_)));
          set_has_color1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(293)) goto parse_color2;
        break;
      }
      
      // optional float color2 = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color2_)));
          set_has_color2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_shotDirection;
        break;
      }
      
      // optional .ast.Vector shotDirection = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shotDirection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shotdirection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_isFiring;
        break;
      }
      
      // optional bool isFiring = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isFiring:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isfiring_)));
          set_has_isfiring();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(312)) goto parse_currentWeapon;
        break;
      }
      
      // optional int32 currentWeapon = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_currentWeapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentweapon_)));
          set_has_currentweapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_isBarrelRollingLeft;
        break;
      }
      
      // optional float isBarrelRollingLeft = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_isBarrelRollingLeft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &isbarrelrollingleft_)));
          set_has_isbarrelrollingleft();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(333)) goto parse_isBarrelRollingRight;
        break;
      }
      
      // optional float isBarrelRollingRight = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_isBarrelRollingRight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &isbarrelrollingright_)));
          set_has_isbarrelrollingright();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(341)) goto parse_curForwardAccel;
        break;
      }
      
      // optional float curForwardAccel = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curForwardAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &curforwardaccel_)));
          set_has_curforwardaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(349)) goto parse_curRightAccel;
        break;
      }
      
      // optional float curRightAccel = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curRightAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &currightaccel_)));
          set_has_currightaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(357)) goto parse_curUpAccel;
        break;
      }
      
      // optional float curUpAccel = 44;
      case 44: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curUpAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &curupaccel_)));
          set_has_curupaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(360)) goto parse_isBraking;
        break;
      }
      
      // optional bool isBraking = 45;
      case 45: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isBraking:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isbraking_)));
          set_has_isbraking();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(373)) goto parse_bankPeriod;
        break;
      }
      
      // optional float bankPeriod = 46;
      case 46: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bankPeriod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bankperiod_)));
          set_has_bankperiod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(376)) goto parse_flyingAIEnabled;
        break;
      }
      
      // optional bool flyingAIEnabled = 47;
      case 47: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flyingAIEnabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flyingaienabled_)));
          set_has_flyingaienabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(384)) goto parse_shootingAIEnabled;
        break;
      }
      
      // optional bool shootingAIEnabled = 48;
      case 48: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shootingAIEnabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shootingaienabled_)));
          set_has_shootingaienabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(394)) goto parse_bankTimer;
        break;
      }
      
      // optional .ast.Timer bankTimer = 49;
      case 49: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bankTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_banktimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_aliveTimer;
        break;
      }
      
      // optional .ast.Timer aliveTimer = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aliveTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alivetimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(410)) goto parse_respawnTimer;
        break;
      }
      
      // optional .ast.Timer respawnTimer = 51;
      case 51: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_respawnTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_respawntimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(421)) goto parse_timeLeftToRespawn;
        break;
      }
      
      // optional float timeLeftToRespawn = 52;
      case 52: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeLeftToRespawn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelefttorespawn_)));
          set_has_timelefttorespawn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(424)) goto parse_score;
        break;
      }
      
      // optional int32 score = 53;
      case 53: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(432)) goto parse_kills;
        break;
      }
      
      // optional int32 kills = 54;
      case 54: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &kills_)));
          set_has_kills();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(440)) goto parse_deaths;
        break;
      }
      
      // optional int32 deaths = 55;
      case 55: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deaths:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deaths_)));
          set_has_deaths();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(448)) goto parse_lives;
        break;
      }
      
      // optional int32 lives = 56;
      case 56: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lives:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lives_)));
          set_has_lives();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(456)) goto parse_bankedShards;
        break;
      }
      
      // optional int32 bankedShards = 57;
      case 57: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bankedshards_)));
          set_has_bankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(464)) goto parse_unbankedShards;
        break;
      }
      
      // optional int32 unbankedShards = 58;
      case 58: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unbankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unbankedshards_)));
          set_has_unbankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(472)) goto parse_totalBankedShards;
        break;
      }
      
      // optional int32 totalBankedShards = 59;
      case 59: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_totalBankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totalbankedshards_)));
          set_has_totalbankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(480)) goto parse_ownerid;
        break;
      }
      
      // optional uint32 ownerid = 60;
      case 60: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ownerid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ownerid_)));
          set_has_ownerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(493)) goto parse_lifetime;
        break;
      }
      
      // optional float lifetime = 61;
      case 61: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_lifetime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lifetime_)));
          set_has_lifetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(501)) goto parse_timeFired;
        break;
      }
      
      // optional float timeFired = 62;
      case 62: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeFired:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timefired_)));
          set_has_timefired();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(504)) goto parse_weaponIndex;
        break;
      }
      
      // optional int32 weaponIndex = 63;
      case 63: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weaponIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponindex_)));
          set_has_weaponindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(517)) goto parse_damage;
        break;
      }
      
      // optional float damage = 64;
      case 64: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(525)) goto parse_chargeTime;
        break;
      }
      
      // optional float chargeTime = 65;
      case 65: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_chargeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &chargetime_)));
          set_has_chargetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(533)) goto parse_damagePerSecond;
        break;
      }
      
      // optional float damagePerSecond = 66;
      case 66: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damagePerSecond:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damagepersecond_)));
          set_has_damagepersecond();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(541)) goto parse_timeSinceExploded;
        break;
      }
      
      // optional float timeSinceExploded = 67;
      case 67: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeSinceExploded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timesinceexploded_)));
          set_has_timesinceexploded();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(544)) goto parse_energyHit;
        break;
      }
      
      // optional bool energyHit = 68;
      case 68: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_energyHit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &energyhit_)));
          set_has_energyhit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(557)) goto parse_timeLastHitByEnergy;
        break;
      }
      
      // optional float timeLastHitByEnergy = 69;
      case 69: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeLastHitByEnergy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelasthitbyenergy_)));
          set_has_timelasthitbyenergy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(560)) goto parse_shouldRemove;
        break;
      }
      
      // optional bool shouldRemove = 70;
      case 70: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shouldRemove:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shouldremove_)));
          set_has_shouldremove();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(573)) goto parse_length;
        break;
      }
      
      // optional float length = 71;
      case 71: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(576)) goto parse_releasedShards;
        break;
      }
      
      // optional int32 releasedShards = 72;
      case 72: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_releasedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &releasedshards_)));
          set_has_releasedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  // optional uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }
  
  // optional .ast.Vector position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->position(), output);
  }
  
  // optional .ast.Vector velocity = 4;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->velocity(), output);
  }
  
  // repeated .ast.Weapon weapon = 5;
  for (int i = 0; i < this->weapon_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->weapon(i), output);
  }
  
  // optional .ast.Vector up = 6;
  if (has_up()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->up(), output);
  }
  
  // optional .ast.Vector right = 7;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->right(), output);
  }
  
  // optional .ast.Vector forward = 8;
  if (has_forward()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->forward(), output);
  }
  
  // optional float radius = 19;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(19, this->radius(), output);
  }
  
  // optional .ast.Vector axis = 21;
  if (has_axis()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->axis(), output);
  }
  
  // optional float angle = 25;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(25, this->angle(), output);
  }
  
  // optional float rotationSpeed = 26;
  if (has_rotationspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(26, this->rotationspeed(), output);
  }
  
  // optional float targetYawSpeed = 27;
  if (has_targetyawspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(27, this->targetyawspeed(), output);
  }
  
  // optional float targetPitchSpeed = 28;
  if (has_targetpitchspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(28, this->targetpitchspeed(), output);
  }
  
  // optional float targetRollSpeed = 29;
  if (has_targetrollspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(29, this->targetrollspeed(), output);
  }
  
  // optional float health = 30;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(30, this->health(), output);
  }
  
  // optional float healthMax = 31;
  if (has_healthmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(31, this->healthmax(), output);
  }
  
  // optional int32 engineLevel = 32;
  if (has_enginelevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(32, this->enginelevel(), output);
  }
  
  // optional int32 regenHealthLevel = 33;
  if (has_regenhealthlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(33, this->regenhealthlevel(), output);
  }
  
  // optional int32 bankLevel = 34;
  if (has_banklevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(34, this->banklevel(), output);
  }
  
  // optional float color1 = 35;
  if (has_color1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(35, this->color1(), output);
  }
  
  // optional float color2 = 36;
  if (has_color2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(36, this->color2(), output);
  }
  
  // optional .ast.Vector shotDirection = 37;
  if (has_shotdirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      37, this->shotdirection(), output);
  }
  
  // optional bool isFiring = 38;
  if (has_isfiring()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->isfiring(), output);
  }
  
  // optional int32 currentWeapon = 39;
  if (has_currentweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(39, this->currentweapon(), output);
  }
  
  // optional float isBarrelRollingLeft = 40;
  if (has_isbarrelrollingleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->isbarrelrollingleft(), output);
  }
  
  // optional float isBarrelRollingRight = 41;
  if (has_isbarrelrollingright()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(41, this->isbarrelrollingright(), output);
  }
  
  // optional float curForwardAccel = 42;
  if (has_curforwardaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(42, this->curforwardaccel(), output);
  }
  
  // optional float curRightAccel = 43;
  if (has_currightaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(43, this->currightaccel(), output);
  }
  
  // optional float curUpAccel = 44;
  if (has_curupaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(44, this->curupaccel(), output);
  }
  
  // optional bool isBraking = 45;
  if (has_isbraking()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(45, this->isbraking(), output);
  }
  
  // optional float bankPeriod = 46;
  if (has_bankperiod()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(46, this->bankperiod(), output);
  }
  
  // optional bool flyingAIEnabled = 47;
  if (has_flyingaienabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(47, this->flyingaienabled(), output);
  }
  
  // optional bool shootingAIEnabled = 48;
  if (has_shootingaienabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(48, this->shootingaienabled(), output);
  }
  
  // optional .ast.Timer bankTimer = 49;
  if (has_banktimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      49, this->banktimer(), output);
  }
  
  // optional .ast.Timer aliveTimer = 50;
  if (has_alivetimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      50, this->alivetimer(), output);
  }
  
  // optional .ast.Timer respawnTimer = 51;
  if (has_respawntimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      51, this->respawntimer(), output);
  }
  
  // optional float timeLeftToRespawn = 52;
  if (has_timelefttorespawn()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(52, this->timelefttorespawn(), output);
  }
  
  // optional int32 score = 53;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(53, this->score(), output);
  }
  
  // optional int32 kills = 54;
  if (has_kills()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(54, this->kills(), output);
  }
  
  // optional int32 deaths = 55;
  if (has_deaths()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(55, this->deaths(), output);
  }
  
  // optional int32 lives = 56;
  if (has_lives()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(56, this->lives(), output);
  }
  
  // optional int32 bankedShards = 57;
  if (has_bankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(57, this->bankedshards(), output);
  }
  
  // optional int32 unbankedShards = 58;
  if (has_unbankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(58, this->unbankedshards(), output);
  }
  
  // optional int32 totalBankedShards = 59;
  if (has_totalbankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(59, this->totalbankedshards(), output);
  }
  
  // optional uint32 ownerid = 60;
  if (has_ownerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(60, this->ownerid(), output);
  }
  
  // optional float lifetime = 61;
  if (has_lifetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(61, this->lifetime(), output);
  }
  
  // optional float timeFired = 62;
  if (has_timefired()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(62, this->timefired(), output);
  }
  
  // optional int32 weaponIndex = 63;
  if (has_weaponindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(63, this->weaponindex(), output);
  }
  
  // optional float damage = 64;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(64, this->damage(), output);
  }
  
  // optional float chargeTime = 65;
  if (has_chargetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(65, this->chargetime(), output);
  }
  
  // optional float damagePerSecond = 66;
  if (has_damagepersecond()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(66, this->damagepersecond(), output);
  }
  
  // optional float timeSinceExploded = 67;
  if (has_timesinceexploded()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(67, this->timesinceexploded(), output);
  }
  
  // optional bool energyHit = 68;
  if (has_energyhit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(68, this->energyhit(), output);
  }
  
  // optional float timeLastHitByEnergy = 69;
  if (has_timelasthitbyenergy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(69, this->timelasthitbyenergy(), output);
  }
  
  // optional bool shouldRemove = 70;
  if (has_shouldremove()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(70, this->shouldremove(), output);
  }
  
  // optional float length = 71;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(71, this->length(), output);
  }
  
  // optional int32 releasedShards = 72;
  if (has_releasedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(72, this->releasedshards(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  // optional uint32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
  }
  
  // optional .ast.Vector position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->position(), target);
  }
  
  // optional .ast.Vector velocity = 4;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->velocity(), target);
  }
  
  // repeated .ast.Weapon weapon = 5;
  for (int i = 0; i < this->weapon_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->weapon(i), target);
  }
  
  // optional .ast.Vector up = 6;
  if (has_up()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->up(), target);
  }
  
  // optional .ast.Vector right = 7;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->right(), target);
  }
  
  // optional .ast.Vector forward = 8;
  if (has_forward()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->forward(), target);
  }
  
  // optional float radius = 19;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(19, this->radius(), target);
  }
  
  // optional .ast.Vector axis = 21;
  if (has_axis()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->axis(), target);
  }
  
  // optional float angle = 25;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(25, this->angle(), target);
  }
  
  // optional float rotationSpeed = 26;
  if (has_rotationspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(26, this->rotationspeed(), target);
  }
  
  // optional float targetYawSpeed = 27;
  if (has_targetyawspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(27, this->targetyawspeed(), target);
  }
  
  // optional float targetPitchSpeed = 28;
  if (has_targetpitchspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(28, this->targetpitchspeed(), target);
  }
  
  // optional float targetRollSpeed = 29;
  if (has_targetrollspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(29, this->targetrollspeed(), target);
  }
  
  // optional float health = 30;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(30, this->health(), target);
  }
  
  // optional float healthMax = 31;
  if (has_healthmax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(31, this->healthmax(), target);
  }
  
  // optional int32 engineLevel = 32;
  if (has_enginelevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(32, this->enginelevel(), target);
  }
  
  // optional int32 regenHealthLevel = 33;
  if (has_regenhealthlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(33, this->regenhealthlevel(), target);
  }
  
  // optional int32 bankLevel = 34;
  if (has_banklevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(34, this->banklevel(), target);
  }
  
  // optional float color1 = 35;
  if (has_color1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(35, this->color1(), target);
  }
  
  // optional float color2 = 36;
  if (has_color2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(36, this->color2(), target);
  }
  
  // optional .ast.Vector shotDirection = 37;
  if (has_shotdirection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        37, this->shotdirection(), target);
  }
  
  // optional bool isFiring = 38;
  if (has_isfiring()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(38, this->isfiring(), target);
  }
  
  // optional int32 currentWeapon = 39;
  if (has_currentweapon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(39, this->currentweapon(), target);
  }
  
  // optional float isBarrelRollingLeft = 40;
  if (has_isbarrelrollingleft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(40, this->isbarrelrollingleft(), target);
  }
  
  // optional float isBarrelRollingRight = 41;
  if (has_isbarrelrollingright()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(41, this->isbarrelrollingright(), target);
  }
  
  // optional float curForwardAccel = 42;
  if (has_curforwardaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(42, this->curforwardaccel(), target);
  }
  
  // optional float curRightAccel = 43;
  if (has_currightaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(43, this->currightaccel(), target);
  }
  
  // optional float curUpAccel = 44;
  if (has_curupaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(44, this->curupaccel(), target);
  }
  
  // optional bool isBraking = 45;
  if (has_isbraking()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(45, this->isbraking(), target);
  }
  
  // optional float bankPeriod = 46;
  if (has_bankperiod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(46, this->bankperiod(), target);
  }
  
  // optional bool flyingAIEnabled = 47;
  if (has_flyingaienabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(47, this->flyingaienabled(), target);
  }
  
  // optional bool shootingAIEnabled = 48;
  if (has_shootingaienabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(48, this->shootingaienabled(), target);
  }
  
  // optional .ast.Timer bankTimer = 49;
  if (has_banktimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        49, this->banktimer(), target);
  }
  
  // optional .ast.Timer aliveTimer = 50;
  if (has_alivetimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        50, this->alivetimer(), target);
  }
  
  // optional .ast.Timer respawnTimer = 51;
  if (has_respawntimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        51, this->respawntimer(), target);
  }
  
  // optional float timeLeftToRespawn = 52;
  if (has_timelefttorespawn()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(52, this->timelefttorespawn(), target);
  }
  
  // optional int32 score = 53;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(53, this->score(), target);
  }
  
  // optional int32 kills = 54;
  if (has_kills()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(54, this->kills(), target);
  }
  
  // optional int32 deaths = 55;
  if (has_deaths()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(55, this->deaths(), target);
  }
  
  // optional int32 lives = 56;
  if (has_lives()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(56, this->lives(), target);
  }
  
  // optional int32 bankedShards = 57;
  if (has_bankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(57, this->bankedshards(), target);
  }
  
  // optional int32 unbankedShards = 58;
  if (has_unbankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(58, this->unbankedshards(), target);
  }
  
  // optional int32 totalBankedShards = 59;
  if (has_totalbankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(59, this->totalbankedshards(), target);
  }
  
  // optional uint32 ownerid = 60;
  if (has_ownerid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(60, this->ownerid(), target);
  }
  
  // optional float lifetime = 61;
  if (has_lifetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(61, this->lifetime(), target);
  }
  
  // optional float timeFired = 62;
  if (has_timefired()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(62, this->timefired(), target);
  }
  
  // optional int32 weaponIndex = 63;
  if (has_weaponindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(63, this->weaponindex(), target);
  }
  
  // optional float damage = 64;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(64, this->damage(), target);
  }
  
  // optional float chargeTime = 65;
  if (has_chargetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(65, this->chargetime(), target);
  }
  
  // optional float damagePerSecond = 66;
  if (has_damagepersecond()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(66, this->damagepersecond(), target);
  }
  
  // optional float timeSinceExploded = 67;
  if (has_timesinceexploded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(67, this->timesinceexploded(), target);
  }
  
  // optional bool energyHit = 68;
  if (has_energyhit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(68, this->energyhit(), target);
  }
  
  // optional float timeLastHitByEnergy = 69;
  if (has_timelasthitbyenergy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(69, this->timelasthitbyenergy(), target);
  }
  
  // optional bool shouldRemove = 70;
  if (has_shouldremove()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(70, this->shouldremove(), target);
  }
  
  // optional float length = 71;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(71, this->length(), target);
  }
  
  // optional int32 releasedShards = 72;
  if (has_releasedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(72, this->releasedshards(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
    // optional uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }
    
    // optional .ast.Vector position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }
    
    // optional .ast.Vector velocity = 4;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }
    
    // optional .ast.Vector up = 6;
    if (has_up()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->up());
    }
    
    // optional .ast.Vector right = 7;
    if (has_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->right());
    }
    
    // optional .ast.Vector forward = 8;
    if (has_forward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->forward());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float radius = 19;
    if (has_radius()) {
      total_size += 2 + 4;
    }
    
    // optional .ast.Vector axis = 21;
    if (has_axis()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->axis());
    }
    
    // optional float angle = 25;
    if (has_angle()) {
      total_size += 2 + 4;
    }
    
    // optional float rotationSpeed = 26;
    if (has_rotationspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float targetYawSpeed = 27;
    if (has_targetyawspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float targetPitchSpeed = 28;
    if (has_targetpitchspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float targetRollSpeed = 29;
    if (has_targetrollspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float health = 30;
    if (has_health()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional float healthMax = 31;
    if (has_healthmax()) {
      total_size += 2 + 4;
    }
    
    // optional int32 engineLevel = 32;
    if (has_enginelevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enginelevel());
    }
    
    // optional int32 regenHealthLevel = 33;
    if (has_regenhealthlevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->regenhealthlevel());
    }
    
    // optional int32 bankLevel = 34;
    if (has_banklevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->banklevel());
    }
    
    // optional float color1 = 35;
    if (has_color1()) {
      total_size += 2 + 4;
    }
    
    // optional float color2 = 36;
    if (has_color2()) {
      total_size += 2 + 4;
    }
    
    // optional .ast.Vector shotDirection = 37;
    if (has_shotdirection()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shotdirection());
    }
    
    // optional bool isFiring = 38;
    if (has_isfiring()) {
      total_size += 2 + 1;
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional int32 currentWeapon = 39;
    if (has_currentweapon()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentweapon());
    }
    
    // optional float isBarrelRollingLeft = 40;
    if (has_isbarrelrollingleft()) {
      total_size += 2 + 4;
    }
    
    // optional float isBarrelRollingRight = 41;
    if (has_isbarrelrollingright()) {
      total_size += 2 + 4;
    }
    
    // optional float curForwardAccel = 42;
    if (has_curforwardaccel()) {
      total_size += 2 + 4;
    }
    
    // optional float curRightAccel = 43;
    if (has_currightaccel()) {
      total_size += 2 + 4;
    }
    
    // optional float curUpAccel = 44;
    if (has_curupaccel()) {
      total_size += 2 + 4;
    }
    
    // optional bool isBraking = 45;
    if (has_isbraking()) {
      total_size += 2 + 1;
    }
    
    // optional float bankPeriod = 46;
    if (has_bankperiod()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional bool flyingAIEnabled = 47;
    if (has_flyingaienabled()) {
      total_size += 2 + 1;
    }
    
    // optional bool shootingAIEnabled = 48;
    if (has_shootingaienabled()) {
      total_size += 2 + 1;
    }
    
    // optional .ast.Timer bankTimer = 49;
    if (has_banktimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->banktimer());
    }
    
    // optional .ast.Timer aliveTimer = 50;
    if (has_alivetimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->alivetimer());
    }
    
    // optional .ast.Timer respawnTimer = 51;
    if (has_respawntimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->respawntimer());
    }
    
    // optional float timeLeftToRespawn = 52;
    if (has_timelefttorespawn()) {
      total_size += 2 + 4;
    }
    
    // optional int32 score = 53;
    if (has_score()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score());
    }
    
    // optional int32 kills = 54;
    if (has_kills()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->kills());
    }
    
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional int32 deaths = 55;
    if (has_deaths()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deaths());
    }
    
    // optional int32 lives = 56;
    if (has_lives()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lives());
    }
    
    // optional int32 bankedShards = 57;
    if (has_bankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bankedshards());
    }
    
    // optional int32 unbankedShards = 58;
    if (has_unbankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unbankedshards());
    }
    
    // optional int32 totalBankedShards = 59;
    if (has_totalbankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->totalbankedshards());
    }
    
    // optional uint32 ownerid = 60;
    if (has_ownerid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ownerid());
    }
    
    // optional float lifetime = 61;
    if (has_lifetime()) {
      total_size += 2 + 4;
    }
    
    // optional float timeFired = 62;
    if (has_timefired()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    // optional int32 weaponIndex = 63;
    if (has_weaponindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weaponindex());
    }
    
    // optional float damage = 64;
    if (has_damage()) {
      total_size += 2 + 4;
    }
    
    // optional float chargeTime = 65;
    if (has_chargetime()) {
      total_size += 2 + 4;
    }
    
    // optional float damagePerSecond = 66;
    if (has_damagepersecond()) {
      total_size += 2 + 4;
    }
    
    // optional float timeSinceExploded = 67;
    if (has_timesinceexploded()) {
      total_size += 2 + 4;
    }
    
    // optional bool energyHit = 68;
    if (has_energyhit()) {
      total_size += 2 + 1;
    }
    
    // optional float timeLastHitByEnergy = 69;
    if (has_timelasthitbyenergy()) {
      total_size += 2 + 4;
    }
    
    // optional bool shouldRemove = 70;
    if (has_shouldremove()) {
      total_size += 2 + 1;
    }
    
  }
  if (_has_bits_[56 / 32] & (0xffu << (56 % 32))) {
    // optional float length = 71;
    if (has_length()) {
      total_size += 2 + 4;
    }
    
    // optional int32 releasedShards = 72;
    if (has_releasedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->releasedshards());
    }
    
  }
  // repeated .ast.Weapon weapon = 5;
  total_size += 1 * this->weapon_size();
  for (int i = 0; i < this->weapon_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->weapon(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  GOOGLE_CHECK_NE(&from, this);
  weapon_.MergeFrom(from.weapon_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_position()) {
      mutable_position()->::ast::Vector::MergeFrom(from.position());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::ast::Vector::MergeFrom(from.velocity());
    }
    if (from.has_up()) {
      mutable_up()->::ast::Vector::MergeFrom(from.up());
    }
    if (from.has_right()) {
      mutable_right()->::ast::Vector::MergeFrom(from.right());
    }
    if (from.has_forward()) {
      mutable_forward()->::ast::Vector::MergeFrom(from.forward());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_axis()) {
      mutable_axis()->::ast::Vector::MergeFrom(from.axis());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_rotationspeed()) {
      set_rotationspeed(from.rotationspeed());
    }
    if (from.has_targetyawspeed()) {
      set_targetyawspeed(from.targetyawspeed());
    }
    if (from.has_targetpitchspeed()) {
      set_targetpitchspeed(from.targetpitchspeed());
    }
    if (from.has_targetrollspeed()) {
      set_targetrollspeed(from.targetrollspeed());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_healthmax()) {
      set_healthmax(from.healthmax());
    }
    if (from.has_enginelevel()) {
      set_enginelevel(from.enginelevel());
    }
    if (from.has_regenhealthlevel()) {
      set_regenhealthlevel(from.regenhealthlevel());
    }
    if (from.has_banklevel()) {
      set_banklevel(from.banklevel());
    }
    if (from.has_color1()) {
      set_color1(from.color1());
    }
    if (from.has_color2()) {
      set_color2(from.color2());
    }
    if (from.has_shotdirection()) {
      mutable_shotdirection()->::ast::Vector::MergeFrom(from.shotdirection());
    }
    if (from.has_isfiring()) {
      set_isfiring(from.isfiring());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_currentweapon()) {
      set_currentweapon(from.currentweapon());
    }
    if (from.has_isbarrelrollingleft()) {
      set_isbarrelrollingleft(from.isbarrelrollingleft());
    }
    if (from.has_isbarrelrollingright()) {
      set_isbarrelrollingright(from.isbarrelrollingright());
    }
    if (from.has_curforwardaccel()) {
      set_curforwardaccel(from.curforwardaccel());
    }
    if (from.has_currightaccel()) {
      set_currightaccel(from.currightaccel());
    }
    if (from.has_curupaccel()) {
      set_curupaccel(from.curupaccel());
    }
    if (from.has_isbraking()) {
      set_isbraking(from.isbraking());
    }
    if (from.has_bankperiod()) {
      set_bankperiod(from.bankperiod());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_flyingaienabled()) {
      set_flyingaienabled(from.flyingaienabled());
    }
    if (from.has_shootingaienabled()) {
      set_shootingaienabled(from.shootingaienabled());
    }
    if (from.has_banktimer()) {
      mutable_banktimer()->::ast::Timer::MergeFrom(from.banktimer());
    }
    if (from.has_alivetimer()) {
      mutable_alivetimer()->::ast::Timer::MergeFrom(from.alivetimer());
    }
    if (from.has_respawntimer()) {
      mutable_respawntimer()->::ast::Timer::MergeFrom(from.respawntimer());
    }
    if (from.has_timelefttorespawn()) {
      set_timelefttorespawn(from.timelefttorespawn());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_kills()) {
      set_kills(from.kills());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_deaths()) {
      set_deaths(from.deaths());
    }
    if (from.has_lives()) {
      set_lives(from.lives());
    }
    if (from.has_bankedshards()) {
      set_bankedshards(from.bankedshards());
    }
    if (from.has_unbankedshards()) {
      set_unbankedshards(from.unbankedshards());
    }
    if (from.has_totalbankedshards()) {
      set_totalbankedshards(from.totalbankedshards());
    }
    if (from.has_ownerid()) {
      set_ownerid(from.ownerid());
    }
    if (from.has_lifetime()) {
      set_lifetime(from.lifetime());
    }
    if (from.has_timefired()) {
      set_timefired(from.timefired());
    }
  }
  if (from._has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    if (from.has_weaponindex()) {
      set_weaponindex(from.weaponindex());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
    if (from.has_chargetime()) {
      set_chargetime(from.chargetime());
    }
    if (from.has_damagepersecond()) {
      set_damagepersecond(from.damagepersecond());
    }
    if (from.has_timesinceexploded()) {
      set_timesinceexploded(from.timesinceexploded());
    }
    if (from.has_energyhit()) {
      set_energyhit(from.energyhit());
    }
    if (from.has_timelasthitbyenergy()) {
      set_timelasthitbyenergy(from.timelasthitbyenergy());
    }
    if (from.has_shouldremove()) {
      set_shouldremove(from.shouldremove());
    }
  }
  if (from._has_bits_[56 / 32] & (0xffu << (56 % 32))) {
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_releasedshards()) {
      set_releasedshards(from.releasedshards());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {
  
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_velocity()) {
    if (!this->velocity().IsInitialized()) return false;
  }
  for (int i = 0; i < weapon_size(); i++) {
    if (!this->weapon(i).IsInitialized()) return false;
  }
  if (has_up()) {
    if (!this->up().IsInitialized()) return false;
  }
  if (has_right()) {
    if (!this->right().IsInitialized()) return false;
  }
  if (has_forward()) {
    if (!this->forward().IsInitialized()) return false;
  }
  if (has_axis()) {
    if (!this->axis().IsInitialized()) return false;
  }
  if (has_shotdirection()) {
    if (!this->shotdirection().IsInitialized()) return false;
  }
  return true;
}

void Entity::Swap(Entity* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    weapon_.Swap(&other->weapon_);
    std::swap(up_, other->up_);
    std::swap(right_, other->right_);
    std::swap(forward_, other->forward_);
    std::swap(radius_, other->radius_);
    std::swap(axis_, other->axis_);
    std::swap(angle_, other->angle_);
    std::swap(rotationspeed_, other->rotationspeed_);
    std::swap(targetyawspeed_, other->targetyawspeed_);
    std::swap(targetpitchspeed_, other->targetpitchspeed_);
    std::swap(targetrollspeed_, other->targetrollspeed_);
    std::swap(health_, other->health_);
    std::swap(healthmax_, other->healthmax_);
    std::swap(enginelevel_, other->enginelevel_);
    std::swap(regenhealthlevel_, other->regenhealthlevel_);
    std::swap(banklevel_, other->banklevel_);
    std::swap(color1_, other->color1_);
    std::swap(color2_, other->color2_);
    std::swap(shotdirection_, other->shotdirection_);
    std::swap(isfiring_, other->isfiring_);
    std::swap(currentweapon_, other->currentweapon_);
    std::swap(isbarrelrollingleft_, other->isbarrelrollingleft_);
    std::swap(isbarrelrollingright_, other->isbarrelrollingright_);
    std::swap(curforwardaccel_, other->curforwardaccel_);
    std::swap(currightaccel_, other->currightaccel_);
    std::swap(curupaccel_, other->curupaccel_);
    std::swap(isbraking_, other->isbraking_);
    std::swap(bankperiod_, other->bankperiod_);
    std::swap(flyingaienabled_, other->flyingaienabled_);
    std::swap(shootingaienabled_, other->shootingaienabled_);
    std::swap(banktimer_, other->banktimer_);
    std::swap(alivetimer_, other->alivetimer_);
    std::swap(respawntimer_, other->respawntimer_);
    std::swap(timelefttorespawn_, other->timelefttorespawn_);
    std::swap(score_, other->score_);
    std::swap(kills_, other->kills_);
    std::swap(deaths_, other->deaths_);
    std::swap(lives_, other->lives_);
    std::swap(bankedshards_, other->bankedshards_);
    std::swap(unbankedshards_, other->unbankedshards_);
    std::swap(totalbankedshards_, other->totalbankedshards_);
    std::swap(ownerid_, other->ownerid_);
    std::swap(lifetime_, other->lifetime_);
    std::swap(timefired_, other->timefired_);
    std::swap(weaponindex_, other->weaponindex_);
    std::swap(damage_, other->damage_);
    std::swap(chargetime_, other->chargetime_);
    std::swap(damagepersecond_, other->damagepersecond_);
    std::swap(timesinceexploded_, other->timesinceexploded_);
    std::swap(energyhit_, other->energyhit_);
    std::swap(timelasthitbyenergy_, other->timelasthitbyenergy_);
    std::swap(shouldremove_, other->shouldremove_);
    std::swap(length_, other->length_);
    std::swap(releasedshards_, other->releasedshards_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Weapon::kIndexFieldNumber;
const int Weapon::kActivationTimerFieldNumber;
const int Weapon::kTimeLastFiredFieldNumber;
const int Weapon::kCoolDownFieldNumber;
const int Weapon::kDamageFieldNumber;
const int Weapon::kCurrentHeatFieldNumber;
const int Weapon::kShotsFiredFieldNumber;
const int Weapon::kTimeStartedFiringFieldNumber;
const int Weapon::kShotidFieldNumber;
const int Weapon::kPurchasedFieldNumber;
const int Weapon::kWeaponPriceFieldNumber;
const int Weapon::kLevelFieldNumber;
const int Weapon::kRangeFieldNumber;
const int Weapon::kOverheatLevelFieldNumber;
const int Weapon::kHeatPerShotFieldNumber;
#endif  // !_MSC_VER

Weapon::Weapon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Weapon::InitAsDefaultInstance() {
  activationtimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
}

Weapon::Weapon(const Weapon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Weapon::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  activationtimer_ = NULL;
  timelastfired_ = 0;
  cooldown_ = 0;
  damage_ = 0;
  currentheat_ = 0;
  shotsfired_ = 0;
  timestartedfiring_ = 0;
  shotid_ = 0u;
  purchased_ = false;
  weaponprice_ = 0;
  level_ = 0;
  range_ = 0;
  overheatlevel_ = 0;
  heatpershot_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Weapon::~Weapon() {
  SharedDtor();
}

void Weapon::SharedDtor() {
  if (this != default_instance_) {
    delete activationtimer_;
  }
}

void Weapon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Weapon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Weapon_descriptor_;
}

const Weapon& Weapon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Weapon* Weapon::default_instance_ = NULL;

Weapon* Weapon::New() const {
  return new Weapon;
}

void Weapon::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_activationtimer()) {
      if (activationtimer_ != NULL) activationtimer_->::ast::Timer::Clear();
    }
    timelastfired_ = 0;
    cooldown_ = 0;
    damage_ = 0;
    currentheat_ = 0;
    shotsfired_ = 0;
    timestartedfiring_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    shotid_ = 0u;
    purchased_ = false;
    weaponprice_ = 0;
    level_ = 0;
    range_ = 0;
    overheatlevel_ = 0;
    heatpershot_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Weapon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_activationTimer;
        break;
      }
      
      // optional .ast.Timer activationTimer = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_activationTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_activationtimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_timeLastFired;
        break;
      }
      
      // optional float timeLastFired = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeLastFired:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelastfired_)));
          set_has_timelastfired();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_coolDown;
        break;
      }
      
      // optional float coolDown = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_coolDown:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cooldown_)));
          set_has_cooldown();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_damage;
        break;
      }
      
      // optional float damage = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_currentHeat;
        break;
      }
      
      // optional float currentHeat = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_currentHeat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &currentheat_)));
          set_has_currentheat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_shotsFired;
        break;
      }
      
      // optional int32 shotsFired = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shotsFired:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &shotsfired_)));
          set_has_shotsfired();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_timeStartedFiring;
        break;
      }
      
      // optional float timeStartedFiring = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeStartedFiring:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timestartedfiring_)));
          set_has_timestartedfiring();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_shotid;
        break;
      }
      
      // optional uint32 shotid = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shotid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shotid_)));
          set_has_shotid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_purchased;
        break;
      }
      
      // optional bool purchased = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_purchased:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &purchased_)));
          set_has_purchased();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_weaponPrice;
        break;
      }
      
      // optional int32 weaponPrice = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weaponPrice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponprice_)));
          set_has_weaponprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_level;
        break;
      }
      
      // optional int32 level = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_range;
        break;
      }
      
      // optional float range = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_)));
          set_has_range();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_overheatLevel;
        break;
      }
      
      // optional float overheatLevel = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_overheatLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &overheatlevel_)));
          set_has_overheatlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_heatPerShot;
        break;
      }
      
      // optional float heatPerShot = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_heatPerShot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heatpershot_)));
          set_has_heatpershot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Weapon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }
  
  // optional .ast.Timer activationTimer = 2;
  if (has_activationtimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->activationtimer(), output);
  }
  
  // optional float timeLastFired = 3;
  if (has_timelastfired()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->timelastfired(), output);
  }
  
  // optional float coolDown = 4;
  if (has_cooldown()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->cooldown(), output);
  }
  
  // optional float damage = 5;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->damage(), output);
  }
  
  // optional float currentHeat = 6;
  if (has_currentheat()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->currentheat(), output);
  }
  
  // optional int32 shotsFired = 7;
  if (has_shotsfired()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->shotsfired(), output);
  }
  
  // optional float timeStartedFiring = 8;
  if (has_timestartedfiring()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->timestartedfiring(), output);
  }
  
  // optional uint32 shotid = 9;
  if (has_shotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->shotid(), output);
  }
  
  // optional bool purchased = 10;
  if (has_purchased()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->purchased(), output);
  }
  
  // optional int32 weaponPrice = 11;
  if (has_weaponprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->weaponprice(), output);
  }
  
  // optional int32 level = 12;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->level(), output);
  }
  
  // optional float range = 13;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->range(), output);
  }
  
  // optional float overheatLevel = 14;
  if (has_overheatlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->overheatlevel(), output);
  }
  
  // optional float heatPerShot = 15;
  if (has_heatpershot()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->heatpershot(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Weapon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }
  
  // optional .ast.Timer activationTimer = 2;
  if (has_activationtimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->activationtimer(), target);
  }
  
  // optional float timeLastFired = 3;
  if (has_timelastfired()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->timelastfired(), target);
  }
  
  // optional float coolDown = 4;
  if (has_cooldown()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->cooldown(), target);
  }
  
  // optional float damage = 5;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->damage(), target);
  }
  
  // optional float currentHeat = 6;
  if (has_currentheat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->currentheat(), target);
  }
  
  // optional int32 shotsFired = 7;
  if (has_shotsfired()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->shotsfired(), target);
  }
  
  // optional float timeStartedFiring = 8;
  if (has_timestartedfiring()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->timestartedfiring(), target);
  }
  
  // optional uint32 shotid = 9;
  if (has_shotid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->shotid(), target);
  }
  
  // optional bool purchased = 10;
  if (has_purchased()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->purchased(), target);
  }
  
  // optional int32 weaponPrice = 11;
  if (has_weaponprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->weaponprice(), target);
  }
  
  // optional int32 level = 12;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->level(), target);
  }
  
  // optional float range = 13;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->range(), target);
  }
  
  // optional float overheatLevel = 14;
  if (has_overheatlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->overheatlevel(), target);
  }
  
  // optional float heatPerShot = 15;
  if (has_heatpershot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->heatpershot(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Weapon::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }
    
    // optional .ast.Timer activationTimer = 2;
    if (has_activationtimer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->activationtimer());
    }
    
    // optional float timeLastFired = 3;
    if (has_timelastfired()) {
      total_size += 1 + 4;
    }
    
    // optional float coolDown = 4;
    if (has_cooldown()) {
      total_size += 1 + 4;
    }
    
    // optional float damage = 5;
    if (has_damage()) {
      total_size += 1 + 4;
    }
    
    // optional float currentHeat = 6;
    if (has_currentheat()) {
      total_size += 1 + 4;
    }
    
    // optional int32 shotsFired = 7;
    if (has_shotsfired()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->shotsfired());
    }
    
    // optional float timeStartedFiring = 8;
    if (has_timestartedfiring()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 shotid = 9;
    if (has_shotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shotid());
    }
    
    // optional bool purchased = 10;
    if (has_purchased()) {
      total_size += 1 + 1;
    }
    
    // optional int32 weaponPrice = 11;
    if (has_weaponprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weaponprice());
    }
    
    // optional int32 level = 12;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }
    
    // optional float range = 13;
    if (has_range()) {
      total_size += 1 + 4;
    }
    
    // optional float overheatLevel = 14;
    if (has_overheatlevel()) {
      total_size += 1 + 4;
    }
    
    // optional float heatPerShot = 15;
    if (has_heatpershot()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Weapon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Weapon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Weapon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Weapon::MergeFrom(const Weapon& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_activationtimer()) {
      mutable_activationtimer()->::ast::Timer::MergeFrom(from.activationtimer());
    }
    if (from.has_timelastfired()) {
      set_timelastfired(from.timelastfired());
    }
    if (from.has_cooldown()) {
      set_cooldown(from.cooldown());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
    if (from.has_currentheat()) {
      set_currentheat(from.currentheat());
    }
    if (from.has_shotsfired()) {
      set_shotsfired(from.shotsfired());
    }
    if (from.has_timestartedfiring()) {
      set_timestartedfiring(from.timestartedfiring());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_shotid()) {
      set_shotid(from.shotid());
    }
    if (from.has_purchased()) {
      set_purchased(from.purchased());
    }
    if (from.has_weaponprice()) {
      set_weaponprice(from.weaponprice());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_range()) {
      set_range(from.range());
    }
    if (from.has_overheatlevel()) {
      set_overheatlevel(from.overheatlevel());
    }
    if (from.has_heatpershot()) {
      set_heatpershot(from.heatpershot());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Weapon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Weapon::CopyFrom(const Weapon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Weapon::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Weapon::Swap(Weapon* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(activationtimer_, other->activationtimer_);
    std::swap(timelastfired_, other->timelastfired_);
    std::swap(cooldown_, other->cooldown_);
    std::swap(damage_, other->damage_);
    std::swap(currentheat_, other->currentheat_);
    std::swap(shotsfired_, other->shotsfired_);
    std::swap(timestartedfiring_, other->timestartedfiring_);
    std::swap(shotid_, other->shotid_);
    std::swap(purchased_, other->purchased_);
    std::swap(weaponprice_, other->weaponprice_);
    std::swap(level_, other->level_);
    std::swap(range_, other->range_);
    std::swap(overheatlevel_, other->overheatlevel_);
    std::swap(heatpershot_, other->heatpershot_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Weapon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Weapon_descriptor_;
  metadata.reflection = Weapon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientCommand::kShipIDFieldNumber;
const int ClientCommand::kForwardAccelerationFieldNumber;
const int ClientCommand::kRightAccelerationFieldNumber;
const int ClientCommand::kUpAccelerationFieldNumber;
const int ClientCommand::kBrakeFieldNumber;
const int ClientCommand::kYawSpeedFieldNumber;
const int ClientCommand::kRollSpeedFieldNumber;
const int ClientCommand::kPitchSpeedFieldNumber;
const int ClientCommand::kFireFieldNumber;
const int ClientCommand::kCurWeaponFieldNumber;
const int ClientCommand::kMouseXFieldNumber;
const int ClientCommand::kMouseYFieldNumber;
const int ClientCommand::kLastReceivedGameStateIdFieldNumber;
#endif  // !_MSC_VER

ClientCommand::ClientCommand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientCommand::InitAsDefaultInstance() {
}

ClientCommand::ClientCommand(const ClientCommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientCommand::SharedCtor() {
  _cached_size_ = 0;
  shipid_ = 0u;
  forwardacceleration_ = 0;
  rightacceleration_ = 0;
  upacceleration_ = 0;
  brake_ = false;
  yawspeed_ = 0;
  rollspeed_ = 0;
  pitchspeed_ = 0;
  fire_ = false;
  curweapon_ = 0u;
  mousex_ = 0;
  mousey_ = 0;
  lastreceivedgamestateid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientCommand::~ClientCommand() {
  SharedDtor();
}

void ClientCommand::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientCommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientCommand_descriptor_;
}

const ClientCommand& ClientCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

ClientCommand* ClientCommand::default_instance_ = NULL;

ClientCommand* ClientCommand::New() const {
  return new ClientCommand;
}

void ClientCommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    shipid_ = 0u;
    forwardacceleration_ = 0;
    rightacceleration_ = 0;
    upacceleration_ = 0;
    brake_ = false;
    yawspeed_ = 0;
    rollspeed_ = 0;
    pitchspeed_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    fire_ = false;
    curweapon_ = 0u;
    mousex_ = 0;
    mousey_ = 0;
    lastreceivedgamestateid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 shipID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shipid_)));
          set_has_shipid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_forwardAcceleration;
        break;
      }
      
      // optional sint32 forwardAcceleration = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_forwardAcceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &forwardacceleration_)));
          set_has_forwardacceleration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rightAcceleration;
        break;
      }
      
      // optional sint32 rightAcceleration = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rightAcceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &rightacceleration_)));
          set_has_rightacceleration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_upAcceleration;
        break;
      }
      
      // optional sint32 upAcceleration = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_upAcceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &upacceleration_)));
          set_has_upacceleration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_brake;
        break;
      }
      
      // optional bool brake = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_brake:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &brake_)));
          set_has_brake();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_yawSpeed;
        break;
      }
      
      // optional float yawSpeed = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_yawSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yawspeed_)));
          set_has_yawspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_rollSpeed;
        break;
      }
      
      // optional float rollSpeed = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rollSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rollspeed_)));
          set_has_rollspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_pitchSpeed;
        break;
      }
      
      // optional float pitchSpeed = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pitchSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pitchspeed_)));
          set_has_pitchspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_fire;
        break;
      }
      
      // optional bool fire = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fire:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fire_)));
          set_has_fire();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_curWeapon;
        break;
      }
      
      // optional uint32 curWeapon = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curWeapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curweapon_)));
          set_has_curweapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_mouseX;
        break;
      }
      
      // optional float mouseX = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_mouseX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mousex_)));
          set_has_mousex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_mouseY;
        break;
      }
      
      // optional float mouseY = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_mouseY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mousey_)));
          set_has_mousey();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_lastReceivedGameStateId;
        break;
      }
      
      // optional uint32 lastReceivedGameStateId = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastReceivedGameStateId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastreceivedgamestateid_)));
          set_has_lastreceivedgamestateid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 shipID = 1;
  if (has_shipid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shipid(), output);
  }
  
  // optional sint32 forwardAcceleration = 2;
  if (has_forwardacceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->forwardacceleration(), output);
  }
  
  // optional sint32 rightAcceleration = 3;
  if (has_rightacceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->rightacceleration(), output);
  }
  
  // optional sint32 upAcceleration = 4;
  if (has_upacceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->upacceleration(), output);
  }
  
  // optional bool brake = 5;
  if (has_brake()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->brake(), output);
  }
  
  // optional float yawSpeed = 6;
  if (has_yawspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->yawspeed(), output);
  }
  
  // optional float rollSpeed = 7;
  if (has_rollspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->rollspeed(), output);
  }
  
  // optional float pitchSpeed = 8;
  if (has_pitchspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->pitchspeed(), output);
  }
  
  // optional bool fire = 9;
  if (has_fire()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->fire(), output);
  }
  
  // optional uint32 curWeapon = 10;
  if (has_curweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->curweapon(), output);
  }
  
  // optional float mouseX = 11;
  if (has_mousex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->mousex(), output);
  }
  
  // optional float mouseY = 12;
  if (has_mousey()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->mousey(), output);
  }
  
  // optional uint32 lastReceivedGameStateId = 13;
  if (has_lastreceivedgamestateid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->lastreceivedgamestateid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 shipID = 1;
  if (has_shipid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->shipid(), target);
  }
  
  // optional sint32 forwardAcceleration = 2;
  if (has_forwardacceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->forwardacceleration(), target);
  }
  
  // optional sint32 rightAcceleration = 3;
  if (has_rightacceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->rightacceleration(), target);
  }
  
  // optional sint32 upAcceleration = 4;
  if (has_upacceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->upacceleration(), target);
  }
  
  // optional bool brake = 5;
  if (has_brake()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->brake(), target);
  }
  
  // optional float yawSpeed = 6;
  if (has_yawspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->yawspeed(), target);
  }
  
  // optional float rollSpeed = 7;
  if (has_rollspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->rollspeed(), target);
  }
  
  // optional float pitchSpeed = 8;
  if (has_pitchspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->pitchspeed(), target);
  }
  
  // optional bool fire = 9;
  if (has_fire()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->fire(), target);
  }
  
  // optional uint32 curWeapon = 10;
  if (has_curweapon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->curweapon(), target);
  }
  
  // optional float mouseX = 11;
  if (has_mousex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->mousex(), target);
  }
  
  // optional float mouseY = 12;
  if (has_mousey()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->mousey(), target);
  }
  
  // optional uint32 lastReceivedGameStateId = 13;
  if (has_lastreceivedgamestateid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->lastreceivedgamestateid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientCommand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 shipID = 1;
    if (has_shipid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shipid());
    }
    
    // optional sint32 forwardAcceleration = 2;
    if (has_forwardacceleration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->forwardacceleration());
    }
    
    // optional sint32 rightAcceleration = 3;
    if (has_rightacceleration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->rightacceleration());
    }
    
    // optional sint32 upAcceleration = 4;
    if (has_upacceleration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->upacceleration());
    }
    
    // optional bool brake = 5;
    if (has_brake()) {
      total_size += 1 + 1;
    }
    
    // optional float yawSpeed = 6;
    if (has_yawspeed()) {
      total_size += 1 + 4;
    }
    
    // optional float rollSpeed = 7;
    if (has_rollspeed()) {
      total_size += 1 + 4;
    }
    
    // optional float pitchSpeed = 8;
    if (has_pitchspeed()) {
      total_size += 1 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool fire = 9;
    if (has_fire()) {
      total_size += 1 + 1;
    }
    
    // optional uint32 curWeapon = 10;
    if (has_curweapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->curweapon());
    }
    
    // optional float mouseX = 11;
    if (has_mousex()) {
      total_size += 1 + 4;
    }
    
    // optional float mouseY = 12;
    if (has_mousey()) {
      total_size += 1 + 4;
    }
    
    // optional uint32 lastReceivedGameStateId = 13;
    if (has_lastreceivedgamestateid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastreceivedgamestateid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientCommand::MergeFrom(const ClientCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shipid()) {
      set_shipid(from.shipid());
    }
    if (from.has_forwardacceleration()) {
      set_forwardacceleration(from.forwardacceleration());
    }
    if (from.has_rightacceleration()) {
      set_rightacceleration(from.rightacceleration());
    }
    if (from.has_upacceleration()) {
      set_upacceleration(from.upacceleration());
    }
    if (from.has_brake()) {
      set_brake(from.brake());
    }
    if (from.has_yawspeed()) {
      set_yawspeed(from.yawspeed());
    }
    if (from.has_rollspeed()) {
      set_rollspeed(from.rollspeed());
    }
    if (from.has_pitchspeed()) {
      set_pitchspeed(from.pitchspeed());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_fire()) {
      set_fire(from.fire());
    }
    if (from.has_curweapon()) {
      set_curweapon(from.curweapon());
    }
    if (from.has_mousex()) {
      set_mousex(from.mousex());
    }
    if (from.has_mousey()) {
      set_mousey(from.mousey());
    }
    if (from.has_lastreceivedgamestateid()) {
      set_lastreceivedgamestateid(from.lastreceivedgamestateid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientCommand::CopyFrom(const ClientCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ClientCommand::Swap(ClientCommand* other) {
  if (other != this) {
    std::swap(shipid_, other->shipid_);
    std::swap(forwardacceleration_, other->forwardacceleration_);
    std::swap(rightacceleration_, other->rightacceleration_);
    std::swap(upacceleration_, other->upacceleration_);
    std::swap(brake_, other->brake_);
    std::swap(yawspeed_, other->yawspeed_);
    std::swap(rollspeed_, other->rollspeed_);
    std::swap(pitchspeed_, other->pitchspeed_);
    std::swap(fire_, other->fire_);
    std::swap(curweapon_, other->curweapon_);
    std::swap(mousex_, other->mousex_);
    std::swap(mousey_, other->mousey_);
    std::swap(lastreceivedgamestateid_, other->lastreceivedgamestateid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientCommand_descriptor_;
  metadata.reflection = ClientCommand_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Timer::kTimeStartedFieldNumber;
const int Timer::kCountDownTimeFieldNumber;
const int Timer::kTimePausedFieldNumber;
const int Timer::kIsPausedFieldNumber;
const int Timer::kIsRunningFieldNumber;
#endif  // !_MSC_VER

Timer::Timer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Timer::InitAsDefaultInstance() {
}

Timer::Timer(const Timer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Timer::SharedCtor() {
  _cached_size_ = 0;
  timestarted_ = 0;
  countdowntime_ = 0;
  timepaused_ = 0;
  ispaused_ = false;
  isrunning_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timer::~Timer() {
  SharedDtor();
}

void Timer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Timer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timer_descriptor_;
}

const Timer& Timer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Timer* Timer::default_instance_ = NULL;

Timer* Timer::New() const {
  return new Timer;
}

void Timer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestarted_ = 0;
    countdowntime_ = 0;
    timepaused_ = 0;
    ispaused_ = false;
    isrunning_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Timer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float timeStarted = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timestarted_)));
          set_has_timestarted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_countDownTime;
        break;
      }
      
      // optional float countDownTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_countDownTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &countdowntime_)));
          set_has_countdowntime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_timePaused;
        break;
      }
      
      // optional float timePaused = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timePaused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timepaused_)));
          set_has_timepaused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isPaused;
        break;
      }
      
      // optional bool isPaused = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isPaused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ispaused_)));
          set_has_ispaused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isRunning;
        break;
      }
      
      // optional bool isRunning = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isRunning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isrunning_)));
          set_has_isrunning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Timer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float timeStarted = 1;
  if (has_timestarted()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->timestarted(), output);
  }
  
  // optional float countDownTime = 2;
  if (has_countdowntime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->countdowntime(), output);
  }
  
  // optional float timePaused = 3;
  if (has_timepaused()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->timepaused(), output);
  }
  
  // optional bool isPaused = 4;
  if (has_ispaused()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->ispaused(), output);
  }
  
  // optional bool isRunning = 5;
  if (has_isrunning()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->isrunning(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Timer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float timeStarted = 1;
  if (has_timestarted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->timestarted(), target);
  }
  
  // optional float countDownTime = 2;
  if (has_countdowntime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->countdowntime(), target);
  }
  
  // optional float timePaused = 3;
  if (has_timepaused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->timepaused(), target);
  }
  
  // optional bool isPaused = 4;
  if (has_ispaused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->ispaused(), target);
  }
  
  // optional bool isRunning = 5;
  if (has_isrunning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->isrunning(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Timer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float timeStarted = 1;
    if (has_timestarted()) {
      total_size += 1 + 4;
    }
    
    // optional float countDownTime = 2;
    if (has_countdowntime()) {
      total_size += 1 + 4;
    }
    
    // optional float timePaused = 3;
    if (has_timepaused()) {
      total_size += 1 + 4;
    }
    
    // optional bool isPaused = 4;
    if (has_ispaused()) {
      total_size += 1 + 1;
    }
    
    // optional bool isRunning = 5;
    if (has_isrunning()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Timer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Timer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timer::MergeFrom(const Timer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestarted()) {
      set_timestarted(from.timestarted());
    }
    if (from.has_countdowntime()) {
      set_countdowntime(from.countdowntime());
    }
    if (from.has_timepaused()) {
      set_timepaused(from.timepaused());
    }
    if (from.has_ispaused()) {
      set_ispaused(from.ispaused());
    }
    if (from.has_isrunning()) {
      set_isrunning(from.isrunning());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Timer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timer::CopyFrom(const Timer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timer::IsInitialized() const {
  
  return true;
}

void Timer::Swap(Timer* other) {
  if (other != this) {
    std::swap(timestarted_, other->timestarted_);
    std::swap(countdowntime_, other->countdowntime_);
    std::swap(timepaused_, other->timepaused_);
    std::swap(ispaused_, other->ispaused_);
    std::swap(isrunning_, other->isrunning_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Timer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timer_descriptor_;
  metadata.reflection = Timer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GameState::kEntityFieldNumber;
const int GameState::kGameTimeFieldNumber;
const int GameState::kPlayerShipFieldNumber;
const int GameState::kLevelTimerFieldNumber;
const int GameState::kCurLevelFieldNumber;
const int GameState::kIdFieldNumber;
#endif  // !_MSC_VER

GameState::GameState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameState::InitAsDefaultInstance() {
  leveltimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
}

GameState::GameState(const GameState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameState::SharedCtor() {
  _cached_size_ = 0;
  gametime_ = 0;
  playership_ = 0u;
  leveltimer_ = NULL;
  curlevel_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameState::~GameState() {
  SharedDtor();
}

void GameState::SharedDtor() {
  if (this != default_instance_) {
    delete leveltimer_;
  }
}

void GameState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameState_descriptor_;
}

const GameState& GameState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

GameState* GameState::default_instance_ = NULL;

GameState* GameState::New() const {
  return new GameState;
}

void GameState::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    gametime_ = 0;
    playership_ = 0u;
    if (has_leveltimer()) {
      if (leveltimer_ != NULL) leveltimer_->::ast::Timer::Clear();
    }
    curlevel_ = 0;
    id_ = 0u;
  }
  entity_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ast.Entity entity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entity;
        if (input->ExpectTag(17)) goto parse_gameTime;
        break;
      }
      
      // required double gameTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_gameTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gametime_)));
          set_has_gametime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_playerShip;
        break;
      }
      
      // optional uint32 playerShip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerShip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &playership_)));
          set_has_playership();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_levelTimer;
        break;
      }
      
      // optional .ast.Timer levelTimer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_levelTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leveltimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_curLevel;
        break;
      }
      
      // optional int32 curLevel = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curlevel_)));
          set_has_curlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_id;
        break;
      }
      
      // optional uint32 id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ast.Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entity(i), output);
  }
  
  // required double gameTime = 2;
  if (has_gametime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->gametime(), output);
  }
  
  // optional uint32 playerShip = 3;
  if (has_playership()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->playership(), output);
  }
  
  // optional .ast.Timer levelTimer = 4;
  if (has_leveltimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->leveltimer(), output);
  }
  
  // optional int32 curLevel = 5;
  if (has_curlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->curlevel(), output);
  }
  
  // optional uint32 id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ast.Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entity(i), target);
  }
  
  // required double gameTime = 2;
  if (has_gametime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->gametime(), target);
  }
  
  // optional uint32 playerShip = 3;
  if (has_playership()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->playership(), target);
  }
  
  // optional .ast.Timer levelTimer = 4;
  if (has_leveltimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->leveltimer(), target);
  }
  
  // optional int32 curLevel = 5;
  if (has_curlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->curlevel(), target);
  }
  
  // optional uint32 id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameState::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required double gameTime = 2;
    if (has_gametime()) {
      total_size += 1 + 8;
    }
    
    // optional uint32 playerShip = 3;
    if (has_playership()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->playership());
    }
    
    // optional .ast.Timer levelTimer = 4;
    if (has_leveltimer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->leveltimer());
    }
    
    // optional int32 curLevel = 5;
    if (has_curlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curlevel());
    }
    
    // optional uint32 id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
  }
  // repeated .ast.Entity entity = 1;
  total_size += 1 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameState::MergeFrom(const GameState& from) {
  GOOGLE_CHECK_NE(&from, this);
  entity_.MergeFrom(from.entity_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_gametime()) {
      set_gametime(from.gametime());
    }
    if (from.has_playership()) {
      set_playership(from.playership());
    }
    if (from.has_leveltimer()) {
      mutable_leveltimer()->::ast::Timer::MergeFrom(from.leveltimer());
    }
    if (from.has_curlevel()) {
      set_curlevel(from.curlevel());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameState::CopyFrom(const GameState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  for (int i = 0; i < entity_size(); i++) {
    if (!this->entity(i).IsInitialized()) return false;
  }
  return true;
}

void GameState::Swap(GameState* other) {
  if (other != this) {
    entity_.Swap(&other->entity_);
    std::swap(gametime_, other->gametime_);
    std::swap(playership_, other->playership_);
    std::swap(leveltimer_, other->leveltimer_);
    std::swap(curlevel_, other->curlevel_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameState_descriptor_;
  metadata.reflection = GameState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CollisionMessage::kGamestateidFieldNumber;
const int CollisionMessage::kColliderFieldNumber;
const int CollisionMessage::kWallTopFieldNumber;
const int CollisionMessage::kWallBottomFieldNumber;
const int CollisionMessage::kWallLeftFieldNumber;
const int CollisionMessage::kWallRightFieldNumber;
const int CollisionMessage::kWallFrontFieldNumber;
const int CollisionMessage::kWallBackFieldNumber;
#endif  // !_MSC_VER

CollisionMessage::CollisionMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollisionMessage::InitAsDefaultInstance() {
}

CollisionMessage::CollisionMessage(const CollisionMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollisionMessage::SharedCtor() {
  _cached_size_ = 0;
  gamestateid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollisionMessage::~CollisionMessage() {
  SharedDtor();
}

void CollisionMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CollisionMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollisionMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollisionMessage_descriptor_;
}

const CollisionMessage& CollisionMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

CollisionMessage* CollisionMessage::default_instance_ = NULL;

CollisionMessage* CollisionMessage::New() const {
  return new CollisionMessage;
}

void CollisionMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gamestateid_ = 0u;
  }
  collider_.Clear();
  wall_top_.Clear();
  wall_bottom_.Clear();
  wall_left_.Clear();
  wall_right_.Clear();
  wall_front_.Clear();
  wall_back_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollisionMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gamestateid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gamestateid_)));
          set_has_gamestateid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_collider;
        break;
      }
      
      // repeated uint32 collider = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collider:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_collider())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 18, input, this->mutable_collider())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_wall_top;
        break;
      }
      
      // repeated uint32 wall_top = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_top())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26, input, this->mutable_wall_top())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_wall_bottom;
        break;
      }
      
      // repeated uint32 wall_bottom = 4 [packed = true];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_bottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_bottom())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 34, input, this->mutable_wall_bottom())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_wall_left;
        break;
      }
      
      // repeated uint32 wall_left = 5 [packed = true];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_left:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_left())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 42, input, this->mutable_wall_left())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_wall_right;
        break;
      }
      
      // repeated uint32 wall_right = 6 [packed = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_right())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 50, input, this->mutable_wall_right())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_wall_front;
        break;
      }
      
      // repeated uint32 wall_front = 7 [packed = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_front:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_front())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 58, input, this->mutable_wall_front())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_wall_back;
        break;
      }
      
      // repeated uint32 wall_back = 8 [packed = true];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_wall_back:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_wall_back())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 66, input, this->mutable_wall_back())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollisionMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 gamestateid = 1;
  if (has_gamestateid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->gamestateid(), output);
  }
  
  // repeated uint32 collider = 2 [packed = true];
  if (this->collider_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_collider_cached_byte_size_);
  }
  for (int i = 0; i < this->collider_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->collider(i), output);
  }
  
  // repeated uint32 wall_top = 3 [packed = true];
  if (this->wall_top_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_top_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_top_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_top(i), output);
  }
  
  // repeated uint32 wall_bottom = 4 [packed = true];
  if (this->wall_bottom_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_bottom_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_bottom_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_bottom(i), output);
  }
  
  // repeated uint32 wall_left = 5 [packed = true];
  if (this->wall_left_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_left_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_left_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_left(i), output);
  }
  
  // repeated uint32 wall_right = 6 [packed = true];
  if (this->wall_right_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_right_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_right_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_right(i), output);
  }
  
  // repeated uint32 wall_front = 7 [packed = true];
  if (this->wall_front_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_front_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_front_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_front(i), output);
  }
  
  // repeated uint32 wall_back = 8 [packed = true];
  if (this->wall_back_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(8, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_wall_back_cached_byte_size_);
  }
  for (int i = 0; i < this->wall_back_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->wall_back(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollisionMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 gamestateid = 1;
  if (has_gamestateid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->gamestateid(), target);
  }
  
  // repeated uint32 collider = 2 [packed = true];
  if (this->collider_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _collider_cached_byte_size_, target);
  }
  for (int i = 0; i < this->collider_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->collider(i), target);
  }
  
  // repeated uint32 wall_top = 3 [packed = true];
  if (this->wall_top_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_top_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_top_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_top(i), target);
  }
  
  // repeated uint32 wall_bottom = 4 [packed = true];
  if (this->wall_bottom_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_bottom_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_bottom_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_bottom(i), target);
  }
  
  // repeated uint32 wall_left = 5 [packed = true];
  if (this->wall_left_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_left_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_left_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_left(i), target);
  }
  
  // repeated uint32 wall_right = 6 [packed = true];
  if (this->wall_right_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_right_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_right_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_right(i), target);
  }
  
  // repeated uint32 wall_front = 7 [packed = true];
  if (this->wall_front_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      7,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_front_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_front_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_front(i), target);
  }
  
  // repeated uint32 wall_back = 8 [packed = true];
  if (this->wall_back_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      8,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _wall_back_cached_byte_size_, target);
  }
  for (int i = 0; i < this->wall_back_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->wall_back(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollisionMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 gamestateid = 1;
    if (has_gamestateid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gamestateid());
    }
    
  }
  // repeated uint32 collider = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->collider_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->collider(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _collider_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_top = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_top_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_top(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_top_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_bottom = 4 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_bottom_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_bottom(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_bottom_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_left = 5 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_left_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_left(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_left_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_right = 6 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_right_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_right(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_right_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_front = 7 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_front_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_front(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_front_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 wall_back = 8 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->wall_back_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->wall_back(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _wall_back_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollisionMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollisionMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollisionMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollisionMessage::MergeFrom(const CollisionMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  collider_.MergeFrom(from.collider_);
  wall_top_.MergeFrom(from.wall_top_);
  wall_bottom_.MergeFrom(from.wall_bottom_);
  wall_left_.MergeFrom(from.wall_left_);
  wall_right_.MergeFrom(from.wall_right_);
  wall_front_.MergeFrom(from.wall_front_);
  wall_back_.MergeFrom(from.wall_back_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gamestateid()) {
      set_gamestateid(from.gamestateid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollisionMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollisionMessage::CopyFrom(const CollisionMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollisionMessage::IsInitialized() const {
  
  return true;
}

void CollisionMessage::Swap(CollisionMessage* other) {
  if (other != this) {
    std::swap(gamestateid_, other->gamestateid_);
    collider_.Swap(&other->collider_);
    wall_top_.Swap(&other->wall_top_);
    wall_bottom_.Swap(&other->wall_bottom_);
    wall_left_.Swap(&other->wall_left_);
    wall_right_.Swap(&other->wall_right_);
    wall_front_.Swap(&other->wall_front_);
    wall_back_.Swap(&other->wall_back_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollisionMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollisionMessage_descriptor_;
  metadata.reflection = CollisionMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChatMessage::kSourceidFieldNumber;
const int ChatMessage::kTextFieldNumber;
#endif  // !_MSC_VER

ChatMessage::ChatMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChatMessage::InitAsDefaultInstance() {
}

ChatMessage::ChatMessage(const ChatMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChatMessage::SharedCtor() {
  _cached_size_ = 0;
  sourceid_ = 0u;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatMessage::~ChatMessage() {
  SharedDtor();
}

void ChatMessage::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
  }
}

void ChatMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChatMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChatMessage_descriptor_;
}

const ChatMessage& ChatMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

ChatMessage* ChatMessage::default_instance_ = NULL;

ChatMessage* ChatMessage::New() const {
  return new ChatMessage;
}

void ChatMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sourceid_ = 0u;
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChatMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sourceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sourceid_)));
          set_has_sourceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }
      
      // optional string text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 sourceid = 1;
  if (has_sourceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sourceid(), output);
  }
  
  // optional string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->text(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChatMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 sourceid = 1;
  if (has_sourceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sourceid(), target);
  }
  
  // optional string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChatMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sourceid = 1;
    if (has_sourceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sourceid());
    }
    
    // optional string text = 2;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChatMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChatMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChatMessage::MergeFrom(const ChatMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sourceid()) {
      set_sourceid(from.sourceid());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChatMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChatMessage::CopyFrom(const ChatMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMessage::IsInitialized() const {
  
  return true;
}

void ChatMessage::Swap(ChatMessage* other) {
  if (other != this) {
    std::swap(sourceid_, other->sourceid_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChatMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChatMessage_descriptor_;
  metadata.reflection = ChatMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateEntityMessage::kCreateEntityMessageidFieldNumber;
const int CreateEntityMessage::kEntityFieldNumber;
#endif  // !_MSC_VER

CreateEntityMessage::CreateEntityMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CreateEntityMessage::InitAsDefaultInstance() {
}

CreateEntityMessage::CreateEntityMessage(const CreateEntityMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CreateEntityMessage::SharedCtor() {
  _cached_size_ = 0;
  createentitymessageid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateEntityMessage::~CreateEntityMessage() {
  SharedDtor();
}

void CreateEntityMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CreateEntityMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateEntityMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateEntityMessage_descriptor_;
}

const CreateEntityMessage& CreateEntityMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

CreateEntityMessage* CreateEntityMessage::default_instance_ = NULL;

CreateEntityMessage* CreateEntityMessage::New() const {
  return new CreateEntityMessage;
}

void CreateEntityMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    createentitymessageid_ = 0u;
  }
  entity_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateEntityMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 createEntityMessageid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &createentitymessageid_)));
          set_has_createentitymessageid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_entity;
        break;
      }
      
      // repeated .ast.Entity entity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_entity;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateEntityMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 createEntityMessageid = 1;
  if (has_createentitymessageid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->createentitymessageid(), output);
  }
  
  // repeated .ast.Entity entity = 2;
  for (int i = 0; i < this->entity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entity(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CreateEntityMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 createEntityMessageid = 1;
  if (has_createentitymessageid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->createentitymessageid(), target);
  }
  
  // repeated .ast.Entity entity = 2;
  for (int i = 0; i < this->entity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entity(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CreateEntityMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 createEntityMessageid = 1;
    if (has_createentitymessageid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->createentitymessageid());
    }
    
  }
  // repeated .ast.Entity entity = 2;
  total_size += 1 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateEntityMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateEntityMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateEntityMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateEntityMessage::MergeFrom(const CreateEntityMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  entity_.MergeFrom(from.entity_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_createentitymessageid()) {
      set_createentitymessageid(from.createentitymessageid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateEntityMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateEntityMessage::CopyFrom(const CreateEntityMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateEntityMessage::IsInitialized() const {
  
  for (int i = 0; i < entity_size(); i++) {
    if (!this->entity(i).IsInitialized()) return false;
  }
  return true;
}

void CreateEntityMessage::Swap(CreateEntityMessage* other) {
  if (other != this) {
    std::swap(createentitymessageid_, other->createentitymessageid_);
    entity_.Swap(&other->entity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateEntityMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateEntityMessage_descriptor_;
  metadata.reflection = CreateEntityMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Frame::kCollisionMessageFieldNumber;
const int Frame::kChatMessageFieldNumber;
const int Frame::kSeqFieldNumber;
const int Frame::kAckFieldNumber;
const int Frame::kTimestampFieldNumber;
const int Frame::kRemoveIdFieldNumber;
const int Frame::kFiringShipsFieldNumber;
const int Frame::kDiffOfFieldNumber;
const int Frame::kGameStateFieldNumber;
const int Frame::kShipidFieldNumber;
#endif  // !_MSC_VER

Frame::Frame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Frame::InitAsDefaultInstance() {
  gamestate_ = const_cast< ::ast::GameState*>(&::ast::GameState::default_instance());
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Frame::SharedCtor() {
  _cached_size_ = 0;
  seq_ = GOOGLE_ULONGLONG(0);
  ack_ = GOOGLE_ULONGLONG(0);
  timestamp_ = 0;
  diff_of_ = 0u;
  gamestate_ = NULL;
  shipid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame::~Frame() {
  SharedDtor();
}

void Frame::SharedDtor() {
  if (this != default_instance_) {
    delete gamestate_;
  }
}

void Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Frame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_descriptor_;
}

const Frame& Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New() const {
  return new Frame;
}

void Frame::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    seq_ = GOOGLE_ULONGLONG(0);
    ack_ = GOOGLE_ULONGLONG(0);
    timestamp_ = 0;
    diff_of_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_gamestate()) {
      if (gamestate_ != NULL) gamestate_->::ast::GameState::Clear();
    }
    shipid_ = 0u;
  }
  collision_message_.Clear();
  chatmessage_.Clear();
  remove_id_.Clear();
  firing_ships_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ast.CollisionMessage collision_message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collision_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_collision_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_collision_message;
        if (input->ExpectTag(18)) goto parse_chatMessage;
        break;
      }
      
      // repeated .ast.ChatMessage chatMessage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chatMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_chatmessage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_chatMessage;
        if (input->ExpectTag(24)) goto parse_seq;
        break;
      }
      
      // optional uint64 seq = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ack;
        break;
      }
      
      // optional uint64 ack = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ack_)));
          set_has_ack();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_timestamp;
        break;
      }
      
      // optional double timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_remove_id;
        break;
      }
      
      // repeated uint32 remove_id = 6 [packed = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remove_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_remove_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 50, input, this->mutable_remove_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_firing_ships;
        break;
      }
      
      // repeated uint32 firing_ships = 7 [packed = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_firing_ships:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_firing_ships())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 58, input, this->mutable_firing_ships())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_diff_of;
        break;
      }
      
      // optional uint32 diff_of = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_diff_of:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &diff_of_)));
          set_has_diff_of();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_gameState;
        break;
      }
      
      // optional .ast.GameState gameState = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gameState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gamestate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_shipid;
        break;
      }
      
      // optional uint32 shipid = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shipid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shipid_)));
          set_has_shipid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ast.CollisionMessage collision_message = 1;
  for (int i = 0; i < this->collision_message_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->collision_message(i), output);
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  for (int i = 0; i < this->chatmessage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->chatmessage(i), output);
  }
  
  // optional uint64 seq = 3;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->seq(), output);
  }
  
  // optional uint64 ack = 4;
  if (has_ack()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->ack(), output);
  }
  
  // optional double timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->timestamp(), output);
  }
  
  // repeated uint32 remove_id = 6 [packed = true];
  if (this->remove_id_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_remove_id_cached_byte_size_);
  }
  for (int i = 0; i < this->remove_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->remove_id(i), output);
  }
  
  // repeated uint32 firing_ships = 7 [packed = true];
  if (this->firing_ships_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_firing_ships_cached_byte_size_);
  }
  for (int i = 0; i < this->firing_ships_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->firing_ships(i), output);
  }
  
  // optional uint32 diff_of = 8;
  if (has_diff_of()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->diff_of(), output);
  }
  
  // optional .ast.GameState gameState = 9;
  if (has_gamestate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->gamestate(), output);
  }
  
  // optional uint32 shipid = 10;
  if (has_shipid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->shipid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Frame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ast.CollisionMessage collision_message = 1;
  for (int i = 0; i < this->collision_message_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->collision_message(i), target);
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  for (int i = 0; i < this->chatmessage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->chatmessage(i), target);
  }
  
  // optional uint64 seq = 3;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->seq(), target);
  }
  
  // optional uint64 ack = 4;
  if (has_ack()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->ack(), target);
  }
  
  // optional double timestamp = 5;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->timestamp(), target);
  }
  
  // repeated uint32 remove_id = 6 [packed = true];
  if (this->remove_id_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _remove_id_cached_byte_size_, target);
  }
  for (int i = 0; i < this->remove_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->remove_id(i), target);
  }
  
  // repeated uint32 firing_ships = 7 [packed = true];
  if (this->firing_ships_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      7,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _firing_ships_cached_byte_size_, target);
  }
  for (int i = 0; i < this->firing_ships_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->firing_ships(i), target);
  }
  
  // optional uint32 diff_of = 8;
  if (has_diff_of()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->diff_of(), target);
  }
  
  // optional .ast.GameState gameState = 9;
  if (has_gamestate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->gamestate(), target);
  }
  
  // optional uint32 shipid = 10;
  if (has_shipid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->shipid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Frame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional uint64 seq = 3;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->seq());
    }
    
    // optional uint64 ack = 4;
    if (has_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ack());
    }
    
    // optional double timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }
    
    // optional uint32 diff_of = 8;
    if (has_diff_of()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->diff_of());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .ast.GameState gameState = 9;
    if (has_gamestate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gamestate());
    }
    
    // optional uint32 shipid = 10;
    if (has_shipid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shipid());
    }
    
  }
  // repeated .ast.CollisionMessage collision_message = 1;
  total_size += 1 * this->collision_message_size();
  for (int i = 0; i < this->collision_message_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->collision_message(i));
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  total_size += 1 * this->chatmessage_size();
  for (int i = 0; i < this->chatmessage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chatmessage(i));
  }
  
  // repeated uint32 remove_id = 6 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->remove_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->remove_id(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _remove_id_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 firing_ships = 7 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->firing_ships_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->firing_ships(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _firing_ships_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Frame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Frame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
  collision_message_.MergeFrom(from.collision_message_);
  chatmessage_.MergeFrom(from.chatmessage_);
  remove_id_.MergeFrom(from.remove_id_);
  firing_ships_.MergeFrom(from.firing_ships_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_ack()) {
      set_ack(from.ack());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_diff_of()) {
      set_diff_of(from.diff_of());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gamestate()) {
      mutable_gamestate()->::ast::GameState::MergeFrom(from.gamestate());
    }
    if (from.has_shipid()) {
      set_shipid(from.shipid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Frame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  
  if (has_gamestate()) {
    if (!this->gamestate().IsInitialized()) return false;
  }
  return true;
}

void Frame::Swap(Frame* other) {
  if (other != this) {
    collision_message_.Swap(&other->collision_message_);
    chatmessage_.Swap(&other->chatmessage_);
    std::swap(seq_, other->seq_);
    std::swap(ack_, other->ack_);
    std::swap(timestamp_, other->timestamp_);
    remove_id_.Swap(&other->remove_id_);
    firing_ships_.Swap(&other->firing_ships_);
    std::swap(diff_of_, other->diff_of_);
    std::swap(gamestate_, other->gamestate_);
    std::swap(shipid_, other->shipid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Frame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Frame_descriptor_;
  metadata.reflection = Frame_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ast

// @@protoc_insertion_point(global_scope)
