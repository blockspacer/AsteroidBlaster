// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Network/gamestate.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ast {

namespace {

const ::google::protobuf::Descriptor* Vector_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timer_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameState_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollisionMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollisionMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChatMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChatMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateEntityMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateEntityMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServerToClient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServerToClient_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Network_2fgamestate_2eproto() {
  protobuf_AddDesc_Network_2fgamestate_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Network/gamestate.proto");
  GOOGLE_CHECK(file != NULL);
  Vector_descriptor_ = file->message_type(0);
  static const int Vector_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, z_),
  };
  Vector_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vector_descriptor_,
      Vector::default_instance_,
      Vector_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vector));
  Entity_descriptor_ = file->message_type(1);
  static const int Entity_offsets_[52] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, axis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, rotationspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, up_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, forward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetyawspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetpitchspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, targetrollspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, healthmax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, enginelevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, regenhealthlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, banklevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, color1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, color2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, shotdirection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isfiring_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, currentweapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbarrelrollingleft_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbarrelrollingright_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, curforwardaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, currightaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, curupaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, isbraking_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, bankperiod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, flyingaienabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, shootingaienabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, banktimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, alivetimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, respawntimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timelefttorespawn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, kills_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, deaths_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, life_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, bankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, unbankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, totalbankedshards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, ownerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, lifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timefired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, weaponindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, damage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, chargetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, damagepersecond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, timesinceexploded_),
  };
  Entity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entity));
  Timer_descriptor_ = file->message_type(2);
  static const int Timer_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, timestarted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, countdowntime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, timepaused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, ispaused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, isrunning_),
  };
  Timer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Timer_descriptor_,
      Timer::default_instance_,
      Timer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Timer));
  GameState_descriptor_ = file->message_type(3);
  static const int GameState_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, playership_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, gametime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, leveltimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, curlevel_),
  };
  GameState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameState_descriptor_,
      GameState::default_instance_,
      GameState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameState));
  CollisionMessage_descriptor_ = file->message_type(4);
  static const int CollisionMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, messageid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, objectid1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, objectid2_),
  };
  CollisionMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollisionMessage_descriptor_,
      CollisionMessage::default_instance_,
      CollisionMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollisionMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollisionMessage));
  ChatMessage_descriptor_ = file->message_type(5);
  static const int ChatMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, sourceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, text_),
  };
  ChatMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChatMessage_descriptor_,
      ChatMessage::default_instance_,
      ChatMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChatMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChatMessage));
  CreateEntityMessage_descriptor_ = file->message_type(6);
  static const int CreateEntityMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, createentitymessageid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, entity_),
  };
  CreateEntityMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateEntityMessage_descriptor_,
      CreateEntityMessage::default_instance_,
      CreateEntityMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateEntityMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateEntityMessage));
  ServerToClient_descriptor_ = file->message_type(7);
  static const int ServerToClient_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, ack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, gamestate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, collisionmessage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, chatmessage_),
  };
  ServerToClient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServerToClient_descriptor_,
      ServerToClient::default_instance_,
      ServerToClient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServerToClient));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Network_2fgamestate_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vector_descriptor_, &Vector::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Timer_descriptor_, &Timer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameState_descriptor_, &GameState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollisionMessage_descriptor_, &CollisionMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChatMessage_descriptor_, &ChatMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateEntityMessage_descriptor_, &CreateEntityMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServerToClient_descriptor_, &ServerToClient::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Network_2fgamestate_2eproto() {
  delete Vector::default_instance_;
  delete Vector_reflection_;
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete Timer::default_instance_;
  delete Timer_reflection_;
  delete GameState::default_instance_;
  delete GameState_reflection_;
  delete CollisionMessage::default_instance_;
  delete CollisionMessage_reflection_;
  delete ChatMessage::default_instance_;
  delete ChatMessage_reflection_;
  delete CreateEntityMessage::default_instance_;
  delete CreateEntityMessage_reflection_;
  delete ServerToClient::default_instance_;
  delete ServerToClient_reflection_;
}

void protobuf_AddDesc_Network_2fgamestate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\027Network/gamestate.proto\022\003ast\")\n\006Vector"
    "\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\237\t\n\006En"
    "tity\022\n\n\002id\030\001 \001(\r\022\014\n\004type\030\002 \001(\r\022\035\n\010positi"
    "on\030\003 \001(\0132\013.ast.Vector\022\035\n\010velocity\030\004 \001(\0132"
    "\013.ast.Vector\022\016\n\006radius\030\023 \001(\002\022\031\n\004axis\030\025 \001"
    "(\0132\013.ast.Vector\022\r\n\005angle\030\031 \001(\002\022\025\n\rrotati"
    "onSpeed\030\032 \001(\002\022\027\n\002up\030\026 \001(\0132\013.ast.Vector\022\032"
    "\n\005right\030\027 \001(\0132\013.ast.Vector\022\034\n\007forward\030\030 "
    "\001(\0132\013.ast.Vector\022\026\n\016targetYawSpeed\030\033 \001(\002"
    "\022\030\n\020targetPitchSpeed\030\034 \001(\002\022\027\n\017targetRoll"
    "Speed\030\035 \001(\002\022\016\n\006health\030\036 \001(\002\022\021\n\thealthMax"
    "\030\037 \001(\002\022\023\n\013engineLevel\030  \001(\005\022\030\n\020regenHeal"
    "thLevel\030! \001(\005\022\021\n\tbankLevel\030\" \001(\005\022\016\n\006colo"
    "r1\030# \001(\002\022\016\n\006color2\030$ \001(\002\022\"\n\rshotDirectio"
    "n\030% \001(\0132\013.ast.Vector\022\020\n\010isFiring\030& \001(\010\022\025"
    "\n\rcurrentWeapon\030\' \001(\005\022\033\n\023isBarrelRolling"
    "Left\030( \001(\002\022\034\n\024isBarrelRollingRight\030) \001(\002"
    "\022\027\n\017curForwardAccel\030* \001(\002\022\025\n\rcurRightAcc"
    "el\030+ \001(\002\022\022\n\ncurUpAccel\030, \001(\002\022\021\n\tisBrakin"
    "g\030- \001(\010\022\022\n\nbankPeriod\030. \001(\002\022\027\n\017flyingAIE"
    "nabled\030/ \001(\010\022\031\n\021shootingAIEnabled\0300 \001(\010\022"
    "\035\n\tbankTimer\0301 \001(\0132\n.ast.Timer\022\036\n\naliveT"
    "imer\0302 \001(\0132\n.ast.Timer\022 \n\014respawnTimer\0303"
    " \001(\0132\n.ast.Timer\022\031\n\021timeLeftToRespawn\0304 "
    "\001(\002\022\r\n\005score\0305 \001(\005\022\r\n\005kills\0306 \001(\005\022\016\n\006dea"
    "ths\0307 \001(\005\022\014\n\004life\0308 \001(\005\022\024\n\014bankedShards\030"
    "9 \001(\005\022\026\n\016unbankedShards\030: \001(\005\022\031\n\021totalBa"
    "nkedShards\030; \001(\005\022\017\n\007ownerid\030< \001(\r\022\020\n\010lif"
    "etime\030= \001(\002\022\021\n\ttimeFired\030> \001(\002\022\023\n\013weapon"
    "Index\030\? \001(\005\022\016\n\006damage\030@ \001(\002\022\022\n\nchargeTim"
    "e\030A \001(\002\022\027\n\017damagePerSecond\030B \001(\002\022\031\n\021time"
    "SinceExploded\030C \001(\002\"l\n\005Timer\022\023\n\013timeStar"
    "ted\030\001 \001(\002\022\025\n\rcountDownTime\030\002 \001(\002\022\022\n\ntime"
    "Paused\030\003 \001(\002\022\020\n\010isPaused\030\004 \001(\010\022\021\n\tisRunn"
    "ing\030\005 \001(\010\"\200\001\n\tGameState\022\022\n\nplayerShip\030\003 "
    "\001(\r\022\020\n\010gameTime\030\002 \002(\001\022\036\n\nlevelTimer\030\004 \001("
    "\0132\n.ast.Timer\022\033\n\006entity\030\001 \003(\0132\013.ast.Enti"
    "ty\022\020\n\010curLevel\030\005 \001(\005\"^\n\020CollisionMessage"
    "\022\021\n\tmessageid\030\004 \001(\r\022\021\n\ttimestamp\030\001 \001(\001\022\021"
    "\n\tobjectId1\030\002 \001(\r\022\021\n\tobjectId2\030\003 \001(\r\"-\n\013"
    "ChatMessage\022\020\n\010sourceid\030\001 \001(\r\022\014\n\004text\030\002 "
    "\001(\t\"Q\n\023CreateEntityMessage\022\035\n\025createEnti"
    "tyMessageid\030\001 \001(\r\022\033\n\006entity\030\002 \003(\0132\013.ast."
    "Entity\"\270\001\n\016ServerToClient\022\013\n\003seq\030\003 \001(\004\022\013"
    "\n\003ack\030\004 \001(\004\022\021\n\ttimestamp\030\005 \001(\001\022!\n\tgameSt"
    "ate\030\021 \001(\0132\016.ast.GameState\022/\n\020collisionMe"
    "ssage\030\001 \003(\0132\025.ast.CollisionMessage\022%\n\013ch"
    "atMessage\030\002 \003(\0132\020.ast.ChatMessage", 1913);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Network/gamestate.proto", &protobuf_RegisterTypes);
  Vector::default_instance_ = new Vector();
  Entity::default_instance_ = new Entity();
  Timer::default_instance_ = new Timer();
  GameState::default_instance_ = new GameState();
  CollisionMessage::default_instance_ = new CollisionMessage();
  ChatMessage::default_instance_ = new ChatMessage();
  CreateEntityMessage::default_instance_ = new CreateEntityMessage();
  ServerToClient::default_instance_ = new ServerToClient();
  Vector::default_instance_->InitAsDefaultInstance();
  Entity::default_instance_->InitAsDefaultInstance();
  Timer::default_instance_->InitAsDefaultInstance();
  GameState::default_instance_->InitAsDefaultInstance();
  CollisionMessage::default_instance_->InitAsDefaultInstance();
  ChatMessage::default_instance_->InitAsDefaultInstance();
  CreateEntityMessage::default_instance_->InitAsDefaultInstance();
  ServerToClient::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Network_2fgamestate_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Network_2fgamestate_2eproto {
  StaticDescriptorInitializer_Network_2fgamestate_2eproto() {
    protobuf_AddDesc_Network_2fgamestate_2eproto();
  }
} static_descriptor_initializer_Network_2fgamestate_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Vector::kXFieldNumber;
const int Vector::kYFieldNumber;
const int Vector::kZFieldNumber;
#endif  // !_MSC_VER

Vector::Vector()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Vector::InitAsDefaultInstance() {
}

Vector::Vector(const Vector& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Vector::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector::~Vector() {
  SharedDtor();
}

void Vector::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector_descriptor_;
}

const Vector& Vector::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Vector* Vector::default_instance_ = NULL;

Vector* Vector::New() const {
  return new Vector;
}

void Vector::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }
      
      // required double y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }
      
      // required double z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }
  
  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }
  
  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Vector::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }
  
  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }
  
  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Vector::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }
    
    // required double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }
    
    // required double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vector* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vector*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vector::MergeFrom(const Vector& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vector::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector::CopyFrom(const Vector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Vector::Swap(Vector* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vector::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector_descriptor_;
  metadata.reflection = Vector_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entity::kIdFieldNumber;
const int Entity::kTypeFieldNumber;
const int Entity::kPositionFieldNumber;
const int Entity::kVelocityFieldNumber;
const int Entity::kRadiusFieldNumber;
const int Entity::kAxisFieldNumber;
const int Entity::kAngleFieldNumber;
const int Entity::kRotationSpeedFieldNumber;
const int Entity::kUpFieldNumber;
const int Entity::kRightFieldNumber;
const int Entity::kForwardFieldNumber;
const int Entity::kTargetYawSpeedFieldNumber;
const int Entity::kTargetPitchSpeedFieldNumber;
const int Entity::kTargetRollSpeedFieldNumber;
const int Entity::kHealthFieldNumber;
const int Entity::kHealthMaxFieldNumber;
const int Entity::kEngineLevelFieldNumber;
const int Entity::kRegenHealthLevelFieldNumber;
const int Entity::kBankLevelFieldNumber;
const int Entity::kColor1FieldNumber;
const int Entity::kColor2FieldNumber;
const int Entity::kShotDirectionFieldNumber;
const int Entity::kIsFiringFieldNumber;
const int Entity::kCurrentWeaponFieldNumber;
const int Entity::kIsBarrelRollingLeftFieldNumber;
const int Entity::kIsBarrelRollingRightFieldNumber;
const int Entity::kCurForwardAccelFieldNumber;
const int Entity::kCurRightAccelFieldNumber;
const int Entity::kCurUpAccelFieldNumber;
const int Entity::kIsBrakingFieldNumber;
const int Entity::kBankPeriodFieldNumber;
const int Entity::kFlyingAIEnabledFieldNumber;
const int Entity::kShootingAIEnabledFieldNumber;
const int Entity::kBankTimerFieldNumber;
const int Entity::kAliveTimerFieldNumber;
const int Entity::kRespawnTimerFieldNumber;
const int Entity::kTimeLeftToRespawnFieldNumber;
const int Entity::kScoreFieldNumber;
const int Entity::kKillsFieldNumber;
const int Entity::kDeathsFieldNumber;
const int Entity::kLifeFieldNumber;
const int Entity::kBankedShardsFieldNumber;
const int Entity::kUnbankedShardsFieldNumber;
const int Entity::kTotalBankedShardsFieldNumber;
const int Entity::kOwneridFieldNumber;
const int Entity::kLifetimeFieldNumber;
const int Entity::kTimeFiredFieldNumber;
const int Entity::kWeaponIndexFieldNumber;
const int Entity::kDamageFieldNumber;
const int Entity::kChargeTimeFieldNumber;
const int Entity::kDamagePerSecondFieldNumber;
const int Entity::kTimeSinceExplodedFieldNumber;
#endif  // !_MSC_VER

Entity::Entity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entity::InitAsDefaultInstance() {
  position_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  velocity_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  axis_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  up_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  right_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  forward_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  shotdirection_ = const_cast< ::ast::Vector*>(&::ast::Vector::default_instance());
  banktimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
  alivetimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
  respawntimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entity::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  type_ = 0u;
  position_ = NULL;
  velocity_ = NULL;
  radius_ = 0;
  axis_ = NULL;
  angle_ = 0;
  rotationspeed_ = 0;
  up_ = NULL;
  right_ = NULL;
  forward_ = NULL;
  targetyawspeed_ = 0;
  targetpitchspeed_ = 0;
  targetrollspeed_ = 0;
  health_ = 0;
  healthmax_ = 0;
  enginelevel_ = 0;
  regenhealthlevel_ = 0;
  banklevel_ = 0;
  color1_ = 0;
  color2_ = 0;
  shotdirection_ = NULL;
  isfiring_ = false;
  currentweapon_ = 0;
  isbarrelrollingleft_ = 0;
  isbarrelrollingright_ = 0;
  curforwardaccel_ = 0;
  currightaccel_ = 0;
  curupaccel_ = 0;
  isbraking_ = false;
  bankperiod_ = 0;
  flyingaienabled_ = false;
  shootingaienabled_ = false;
  banktimer_ = NULL;
  alivetimer_ = NULL;
  respawntimer_ = NULL;
  timelefttorespawn_ = 0;
  score_ = 0;
  kills_ = 0;
  deaths_ = 0;
  life_ = 0;
  bankedshards_ = 0;
  unbankedshards_ = 0;
  totalbankedshards_ = 0;
  ownerid_ = 0u;
  lifetime_ = 0;
  timefired_ = 0;
  weaponindex_ = 0;
  damage_ = 0;
  chargetime_ = 0;
  damagepersecond_ = 0;
  timesinceexploded_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  SharedDtor();
}

void Entity::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete velocity_;
    delete axis_;
    delete up_;
    delete right_;
    delete forward_;
    delete shotdirection_;
    delete banktimer_;
    delete alivetimer_;
    delete respawntimer_;
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New() const {
  return new Entity;
}

void Entity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    type_ = 0u;
    if (has_position()) {
      if (position_ != NULL) position_->::ast::Vector::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::ast::Vector::Clear();
    }
    radius_ = 0;
    if (has_axis()) {
      if (axis_ != NULL) axis_->::ast::Vector::Clear();
    }
    angle_ = 0;
    rotationspeed_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_up()) {
      if (up_ != NULL) up_->::ast::Vector::Clear();
    }
    if (has_right()) {
      if (right_ != NULL) right_->::ast::Vector::Clear();
    }
    if (has_forward()) {
      if (forward_ != NULL) forward_->::ast::Vector::Clear();
    }
    targetyawspeed_ = 0;
    targetpitchspeed_ = 0;
    targetrollspeed_ = 0;
    health_ = 0;
    healthmax_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    enginelevel_ = 0;
    regenhealthlevel_ = 0;
    banklevel_ = 0;
    color1_ = 0;
    color2_ = 0;
    if (has_shotdirection()) {
      if (shotdirection_ != NULL) shotdirection_->::ast::Vector::Clear();
    }
    isfiring_ = false;
    currentweapon_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    isbarrelrollingleft_ = 0;
    isbarrelrollingright_ = 0;
    curforwardaccel_ = 0;
    currightaccel_ = 0;
    curupaccel_ = 0;
    isbraking_ = false;
    bankperiod_ = 0;
    flyingaienabled_ = false;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    shootingaienabled_ = false;
    if (has_banktimer()) {
      if (banktimer_ != NULL) banktimer_->::ast::Timer::Clear();
    }
    if (has_alivetimer()) {
      if (alivetimer_ != NULL) alivetimer_->::ast::Timer::Clear();
    }
    if (has_respawntimer()) {
      if (respawntimer_ != NULL) respawntimer_->::ast::Timer::Clear();
    }
    timelefttorespawn_ = 0;
    score_ = 0;
    kills_ = 0;
    deaths_ = 0;
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    life_ = 0;
    bankedshards_ = 0;
    unbankedshards_ = 0;
    totalbankedshards_ = 0;
    ownerid_ = 0u;
    lifetime_ = 0;
    timefired_ = 0;
    weaponindex_ = 0;
  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    damage_ = 0;
    chargetime_ = 0;
    damagepersecond_ = 0;
    timesinceexploded_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // optional uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }
      
      // optional .ast.Vector position = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_velocity;
        break;
      }
      
      // optional .ast.Vector velocity = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(157)) goto parse_radius;
        break;
      }
      
      // optional float radius = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_axis;
        break;
      }
      
      // optional .ast.Vector axis = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_axis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axis()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_up;
        break;
      }
      
      // optional .ast.Vector up = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_up:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_up()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_right;
        break;
      }
      
      // optional .ast.Vector right = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_forward;
        break;
      }
      
      // optional .ast.Vector forward = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_forward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_forward()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(205)) goto parse_angle;
        break;
      }
      
      // optional float angle = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(213)) goto parse_rotationSpeed;
        break;
      }
      
      // optional float rotationSpeed = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rotationSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotationspeed_)));
          set_has_rotationspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(221)) goto parse_targetYawSpeed;
        break;
      }
      
      // optional float targetYawSpeed = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetYawSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetyawspeed_)));
          set_has_targetyawspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(229)) goto parse_targetPitchSpeed;
        break;
      }
      
      // optional float targetPitchSpeed = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetPitchSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetpitchspeed_)));
          set_has_targetpitchspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(237)) goto parse_targetRollSpeed;
        break;
      }
      
      // optional float targetRollSpeed = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_targetRollSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetrollspeed_)));
          set_has_targetrollspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(245)) goto parse_health;
        break;
      }
      
      // optional float health = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(253)) goto parse_healthMax;
        break;
      }
      
      // optional float healthMax = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_healthMax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &healthmax_)));
          set_has_healthmax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(256)) goto parse_engineLevel;
        break;
      }
      
      // optional int32 engineLevel = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_engineLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enginelevel_)));
          set_has_enginelevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(264)) goto parse_regenHealthLevel;
        break;
      }
      
      // optional int32 regenHealthLevel = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_regenHealthLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &regenhealthlevel_)));
          set_has_regenhealthlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(272)) goto parse_bankLevel;
        break;
      }
      
      // optional int32 bankLevel = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bankLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &banklevel_)));
          set_has_banklevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(285)) goto parse_color1;
        break;
      }
      
      // optional float color1 = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color1_)));
          set_has_color1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(293)) goto parse_color2;
        break;
      }
      
      // optional float color2 = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_color2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color2_)));
          set_has_color2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_shotDirection;
        break;
      }
      
      // optional .ast.Vector shotDirection = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shotDirection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shotdirection()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_isFiring;
        break;
      }
      
      // optional bool isFiring = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isFiring:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isfiring_)));
          set_has_isfiring();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(312)) goto parse_currentWeapon;
        break;
      }
      
      // optional int32 currentWeapon = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_currentWeapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentweapon_)));
          set_has_currentweapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_isBarrelRollingLeft;
        break;
      }
      
      // optional float isBarrelRollingLeft = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_isBarrelRollingLeft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &isbarrelrollingleft_)));
          set_has_isbarrelrollingleft();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(333)) goto parse_isBarrelRollingRight;
        break;
      }
      
      // optional float isBarrelRollingRight = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_isBarrelRollingRight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &isbarrelrollingright_)));
          set_has_isbarrelrollingright();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(341)) goto parse_curForwardAccel;
        break;
      }
      
      // optional float curForwardAccel = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curForwardAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &curforwardaccel_)));
          set_has_curforwardaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(349)) goto parse_curRightAccel;
        break;
      }
      
      // optional float curRightAccel = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curRightAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &currightaccel_)));
          set_has_currightaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(357)) goto parse_curUpAccel;
        break;
      }
      
      // optional float curUpAccel = 44;
      case 44: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_curUpAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &curupaccel_)));
          set_has_curupaccel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(360)) goto parse_isBraking;
        break;
      }
      
      // optional bool isBraking = 45;
      case 45: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isBraking:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isbraking_)));
          set_has_isbraking();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(373)) goto parse_bankPeriod;
        break;
      }
      
      // optional float bankPeriod = 46;
      case 46: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bankPeriod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bankperiod_)));
          set_has_bankperiod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(376)) goto parse_flyingAIEnabled;
        break;
      }
      
      // optional bool flyingAIEnabled = 47;
      case 47: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flyingAIEnabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flyingaienabled_)));
          set_has_flyingaienabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(384)) goto parse_shootingAIEnabled;
        break;
      }
      
      // optional bool shootingAIEnabled = 48;
      case 48: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shootingAIEnabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shootingaienabled_)));
          set_has_shootingaienabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(394)) goto parse_bankTimer;
        break;
      }
      
      // optional .ast.Timer bankTimer = 49;
      case 49: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bankTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_banktimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_aliveTimer;
        break;
      }
      
      // optional .ast.Timer aliveTimer = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aliveTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alivetimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(410)) goto parse_respawnTimer;
        break;
      }
      
      // optional .ast.Timer respawnTimer = 51;
      case 51: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_respawnTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_respawntimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(421)) goto parse_timeLeftToRespawn;
        break;
      }
      
      // optional float timeLeftToRespawn = 52;
      case 52: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeLeftToRespawn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelefttorespawn_)));
          set_has_timelefttorespawn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(424)) goto parse_score;
        break;
      }
      
      // optional int32 score = 53;
      case 53: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(432)) goto parse_kills;
        break;
      }
      
      // optional int32 kills = 54;
      case 54: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_kills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &kills_)));
          set_has_kills();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(440)) goto parse_deaths;
        break;
      }
      
      // optional int32 deaths = 55;
      case 55: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deaths:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deaths_)));
          set_has_deaths();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(448)) goto parse_life;
        break;
      }
      
      // optional int32 life = 56;
      case 56: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_life:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &life_)));
          set_has_life();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(456)) goto parse_bankedShards;
        break;
      }
      
      // optional int32 bankedShards = 57;
      case 57: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bankedshards_)));
          set_has_bankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(464)) goto parse_unbankedShards;
        break;
      }
      
      // optional int32 unbankedShards = 58;
      case 58: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unbankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unbankedshards_)));
          set_has_unbankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(472)) goto parse_totalBankedShards;
        break;
      }
      
      // optional int32 totalBankedShards = 59;
      case 59: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_totalBankedShards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totalbankedshards_)));
          set_has_totalbankedshards();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(480)) goto parse_ownerid;
        break;
      }
      
      // optional uint32 ownerid = 60;
      case 60: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ownerid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ownerid_)));
          set_has_ownerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(493)) goto parse_lifetime;
        break;
      }
      
      // optional float lifetime = 61;
      case 61: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_lifetime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lifetime_)));
          set_has_lifetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(501)) goto parse_timeFired;
        break;
      }
      
      // optional float timeFired = 62;
      case 62: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeFired:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timefired_)));
          set_has_timefired();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(504)) goto parse_weaponIndex;
        break;
      }
      
      // optional int32 weaponIndex = 63;
      case 63: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weaponIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponindex_)));
          set_has_weaponindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(517)) goto parse_damage;
        break;
      }
      
      // optional float damage = 64;
      case 64: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(525)) goto parse_chargeTime;
        break;
      }
      
      // optional float chargeTime = 65;
      case 65: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_chargeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &chargetime_)));
          set_has_chargetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(533)) goto parse_damagePerSecond;
        break;
      }
      
      // optional float damagePerSecond = 66;
      case 66: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damagePerSecond:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damagepersecond_)));
          set_has_damagepersecond();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(541)) goto parse_timeSinceExploded;
        break;
      }
      
      // optional float timeSinceExploded = 67;
      case 67: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timeSinceExploded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timesinceexploded_)));
          set_has_timesinceexploded();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }
  
  // optional uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }
  
  // optional .ast.Vector position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->position(), output);
  }
  
  // optional .ast.Vector velocity = 4;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->velocity(), output);
  }
  
  // optional float radius = 19;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(19, this->radius(), output);
  }
  
  // optional .ast.Vector axis = 21;
  if (has_axis()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->axis(), output);
  }
  
  // optional .ast.Vector up = 22;
  if (has_up()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, this->up(), output);
  }
  
  // optional .ast.Vector right = 23;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, this->right(), output);
  }
  
  // optional .ast.Vector forward = 24;
  if (has_forward()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, this->forward(), output);
  }
  
  // optional float angle = 25;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(25, this->angle(), output);
  }
  
  // optional float rotationSpeed = 26;
  if (has_rotationspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(26, this->rotationspeed(), output);
  }
  
  // optional float targetYawSpeed = 27;
  if (has_targetyawspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(27, this->targetyawspeed(), output);
  }
  
  // optional float targetPitchSpeed = 28;
  if (has_targetpitchspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(28, this->targetpitchspeed(), output);
  }
  
  // optional float targetRollSpeed = 29;
  if (has_targetrollspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(29, this->targetrollspeed(), output);
  }
  
  // optional float health = 30;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(30, this->health(), output);
  }
  
  // optional float healthMax = 31;
  if (has_healthmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(31, this->healthmax(), output);
  }
  
  // optional int32 engineLevel = 32;
  if (has_enginelevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(32, this->enginelevel(), output);
  }
  
  // optional int32 regenHealthLevel = 33;
  if (has_regenhealthlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(33, this->regenhealthlevel(), output);
  }
  
  // optional int32 bankLevel = 34;
  if (has_banklevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(34, this->banklevel(), output);
  }
  
  // optional float color1 = 35;
  if (has_color1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(35, this->color1(), output);
  }
  
  // optional float color2 = 36;
  if (has_color2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(36, this->color2(), output);
  }
  
  // optional .ast.Vector shotDirection = 37;
  if (has_shotdirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      37, this->shotdirection(), output);
  }
  
  // optional bool isFiring = 38;
  if (has_isfiring()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->isfiring(), output);
  }
  
  // optional int32 currentWeapon = 39;
  if (has_currentweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(39, this->currentweapon(), output);
  }
  
  // optional float isBarrelRollingLeft = 40;
  if (has_isbarrelrollingleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->isbarrelrollingleft(), output);
  }
  
  // optional float isBarrelRollingRight = 41;
  if (has_isbarrelrollingright()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(41, this->isbarrelrollingright(), output);
  }
  
  // optional float curForwardAccel = 42;
  if (has_curforwardaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(42, this->curforwardaccel(), output);
  }
  
  // optional float curRightAccel = 43;
  if (has_currightaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(43, this->currightaccel(), output);
  }
  
  // optional float curUpAccel = 44;
  if (has_curupaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(44, this->curupaccel(), output);
  }
  
  // optional bool isBraking = 45;
  if (has_isbraking()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(45, this->isbraking(), output);
  }
  
  // optional float bankPeriod = 46;
  if (has_bankperiod()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(46, this->bankperiod(), output);
  }
  
  // optional bool flyingAIEnabled = 47;
  if (has_flyingaienabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(47, this->flyingaienabled(), output);
  }
  
  // optional bool shootingAIEnabled = 48;
  if (has_shootingaienabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(48, this->shootingaienabled(), output);
  }
  
  // optional .ast.Timer bankTimer = 49;
  if (has_banktimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      49, this->banktimer(), output);
  }
  
  // optional .ast.Timer aliveTimer = 50;
  if (has_alivetimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      50, this->alivetimer(), output);
  }
  
  // optional .ast.Timer respawnTimer = 51;
  if (has_respawntimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      51, this->respawntimer(), output);
  }
  
  // optional float timeLeftToRespawn = 52;
  if (has_timelefttorespawn()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(52, this->timelefttorespawn(), output);
  }
  
  // optional int32 score = 53;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(53, this->score(), output);
  }
  
  // optional int32 kills = 54;
  if (has_kills()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(54, this->kills(), output);
  }
  
  // optional int32 deaths = 55;
  if (has_deaths()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(55, this->deaths(), output);
  }
  
  // optional int32 life = 56;
  if (has_life()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(56, this->life(), output);
  }
  
  // optional int32 bankedShards = 57;
  if (has_bankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(57, this->bankedshards(), output);
  }
  
  // optional int32 unbankedShards = 58;
  if (has_unbankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(58, this->unbankedshards(), output);
  }
  
  // optional int32 totalBankedShards = 59;
  if (has_totalbankedshards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(59, this->totalbankedshards(), output);
  }
  
  // optional uint32 ownerid = 60;
  if (has_ownerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(60, this->ownerid(), output);
  }
  
  // optional float lifetime = 61;
  if (has_lifetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(61, this->lifetime(), output);
  }
  
  // optional float timeFired = 62;
  if (has_timefired()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(62, this->timefired(), output);
  }
  
  // optional int32 weaponIndex = 63;
  if (has_weaponindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(63, this->weaponindex(), output);
  }
  
  // optional float damage = 64;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(64, this->damage(), output);
  }
  
  // optional float chargeTime = 65;
  if (has_chargetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(65, this->chargetime(), output);
  }
  
  // optional float damagePerSecond = 66;
  if (has_damagepersecond()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(66, this->damagepersecond(), output);
  }
  
  // optional float timeSinceExploded = 67;
  if (has_timesinceexploded()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(67, this->timesinceexploded(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }
  
  // optional uint32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
  }
  
  // optional .ast.Vector position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->position(), target);
  }
  
  // optional .ast.Vector velocity = 4;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->velocity(), target);
  }
  
  // optional float radius = 19;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(19, this->radius(), target);
  }
  
  // optional .ast.Vector axis = 21;
  if (has_axis()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->axis(), target);
  }
  
  // optional .ast.Vector up = 22;
  if (has_up()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, this->up(), target);
  }
  
  // optional .ast.Vector right = 23;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, this->right(), target);
  }
  
  // optional .ast.Vector forward = 24;
  if (has_forward()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, this->forward(), target);
  }
  
  // optional float angle = 25;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(25, this->angle(), target);
  }
  
  // optional float rotationSpeed = 26;
  if (has_rotationspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(26, this->rotationspeed(), target);
  }
  
  // optional float targetYawSpeed = 27;
  if (has_targetyawspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(27, this->targetyawspeed(), target);
  }
  
  // optional float targetPitchSpeed = 28;
  if (has_targetpitchspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(28, this->targetpitchspeed(), target);
  }
  
  // optional float targetRollSpeed = 29;
  if (has_targetrollspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(29, this->targetrollspeed(), target);
  }
  
  // optional float health = 30;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(30, this->health(), target);
  }
  
  // optional float healthMax = 31;
  if (has_healthmax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(31, this->healthmax(), target);
  }
  
  // optional int32 engineLevel = 32;
  if (has_enginelevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(32, this->enginelevel(), target);
  }
  
  // optional int32 regenHealthLevel = 33;
  if (has_regenhealthlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(33, this->regenhealthlevel(), target);
  }
  
  // optional int32 bankLevel = 34;
  if (has_banklevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(34, this->banklevel(), target);
  }
  
  // optional float color1 = 35;
  if (has_color1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(35, this->color1(), target);
  }
  
  // optional float color2 = 36;
  if (has_color2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(36, this->color2(), target);
  }
  
  // optional .ast.Vector shotDirection = 37;
  if (has_shotdirection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        37, this->shotdirection(), target);
  }
  
  // optional bool isFiring = 38;
  if (has_isfiring()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(38, this->isfiring(), target);
  }
  
  // optional int32 currentWeapon = 39;
  if (has_currentweapon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(39, this->currentweapon(), target);
  }
  
  // optional float isBarrelRollingLeft = 40;
  if (has_isbarrelrollingleft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(40, this->isbarrelrollingleft(), target);
  }
  
  // optional float isBarrelRollingRight = 41;
  if (has_isbarrelrollingright()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(41, this->isbarrelrollingright(), target);
  }
  
  // optional float curForwardAccel = 42;
  if (has_curforwardaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(42, this->curforwardaccel(), target);
  }
  
  // optional float curRightAccel = 43;
  if (has_currightaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(43, this->currightaccel(), target);
  }
  
  // optional float curUpAccel = 44;
  if (has_curupaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(44, this->curupaccel(), target);
  }
  
  // optional bool isBraking = 45;
  if (has_isbraking()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(45, this->isbraking(), target);
  }
  
  // optional float bankPeriod = 46;
  if (has_bankperiod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(46, this->bankperiod(), target);
  }
  
  // optional bool flyingAIEnabled = 47;
  if (has_flyingaienabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(47, this->flyingaienabled(), target);
  }
  
  // optional bool shootingAIEnabled = 48;
  if (has_shootingaienabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(48, this->shootingaienabled(), target);
  }
  
  // optional .ast.Timer bankTimer = 49;
  if (has_banktimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        49, this->banktimer(), target);
  }
  
  // optional .ast.Timer aliveTimer = 50;
  if (has_alivetimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        50, this->alivetimer(), target);
  }
  
  // optional .ast.Timer respawnTimer = 51;
  if (has_respawntimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        51, this->respawntimer(), target);
  }
  
  // optional float timeLeftToRespawn = 52;
  if (has_timelefttorespawn()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(52, this->timelefttorespawn(), target);
  }
  
  // optional int32 score = 53;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(53, this->score(), target);
  }
  
  // optional int32 kills = 54;
  if (has_kills()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(54, this->kills(), target);
  }
  
  // optional int32 deaths = 55;
  if (has_deaths()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(55, this->deaths(), target);
  }
  
  // optional int32 life = 56;
  if (has_life()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(56, this->life(), target);
  }
  
  // optional int32 bankedShards = 57;
  if (has_bankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(57, this->bankedshards(), target);
  }
  
  // optional int32 unbankedShards = 58;
  if (has_unbankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(58, this->unbankedshards(), target);
  }
  
  // optional int32 totalBankedShards = 59;
  if (has_totalbankedshards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(59, this->totalbankedshards(), target);
  }
  
  // optional uint32 ownerid = 60;
  if (has_ownerid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(60, this->ownerid(), target);
  }
  
  // optional float lifetime = 61;
  if (has_lifetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(61, this->lifetime(), target);
  }
  
  // optional float timeFired = 62;
  if (has_timefired()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(62, this->timefired(), target);
  }
  
  // optional int32 weaponIndex = 63;
  if (has_weaponindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(63, this->weaponindex(), target);
  }
  
  // optional float damage = 64;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(64, this->damage(), target);
  }
  
  // optional float chargeTime = 65;
  if (has_chargetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(65, this->chargetime(), target);
  }
  
  // optional float damagePerSecond = 66;
  if (has_damagepersecond()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(66, this->damagepersecond(), target);
  }
  
  // optional float timeSinceExploded = 67;
  if (has_timesinceexploded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(67, this->timesinceexploded(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }
    
    // optional uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }
    
    // optional .ast.Vector position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }
    
    // optional .ast.Vector velocity = 4;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }
    
    // optional float radius = 19;
    if (has_radius()) {
      total_size += 2 + 4;
    }
    
    // optional .ast.Vector axis = 21;
    if (has_axis()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->axis());
    }
    
    // optional float angle = 25;
    if (has_angle()) {
      total_size += 2 + 4;
    }
    
    // optional float rotationSpeed = 26;
    if (has_rotationspeed()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .ast.Vector up = 22;
    if (has_up()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->up());
    }
    
    // optional .ast.Vector right = 23;
    if (has_right()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->right());
    }
    
    // optional .ast.Vector forward = 24;
    if (has_forward()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->forward());
    }
    
    // optional float targetYawSpeed = 27;
    if (has_targetyawspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float targetPitchSpeed = 28;
    if (has_targetpitchspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float targetRollSpeed = 29;
    if (has_targetrollspeed()) {
      total_size += 2 + 4;
    }
    
    // optional float health = 30;
    if (has_health()) {
      total_size += 2 + 4;
    }
    
    // optional float healthMax = 31;
    if (has_healthmax()) {
      total_size += 2 + 4;
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 engineLevel = 32;
    if (has_enginelevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enginelevel());
    }
    
    // optional int32 regenHealthLevel = 33;
    if (has_regenhealthlevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->regenhealthlevel());
    }
    
    // optional int32 bankLevel = 34;
    if (has_banklevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->banklevel());
    }
    
    // optional float color1 = 35;
    if (has_color1()) {
      total_size += 2 + 4;
    }
    
    // optional float color2 = 36;
    if (has_color2()) {
      total_size += 2 + 4;
    }
    
    // optional .ast.Vector shotDirection = 37;
    if (has_shotdirection()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shotdirection());
    }
    
    // optional bool isFiring = 38;
    if (has_isfiring()) {
      total_size += 2 + 1;
    }
    
    // optional int32 currentWeapon = 39;
    if (has_currentweapon()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentweapon());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional float isBarrelRollingLeft = 40;
    if (has_isbarrelrollingleft()) {
      total_size += 2 + 4;
    }
    
    // optional float isBarrelRollingRight = 41;
    if (has_isbarrelrollingright()) {
      total_size += 2 + 4;
    }
    
    // optional float curForwardAccel = 42;
    if (has_curforwardaccel()) {
      total_size += 2 + 4;
    }
    
    // optional float curRightAccel = 43;
    if (has_currightaccel()) {
      total_size += 2 + 4;
    }
    
    // optional float curUpAccel = 44;
    if (has_curupaccel()) {
      total_size += 2 + 4;
    }
    
    // optional bool isBraking = 45;
    if (has_isbraking()) {
      total_size += 2 + 1;
    }
    
    // optional float bankPeriod = 46;
    if (has_bankperiod()) {
      total_size += 2 + 4;
    }
    
    // optional bool flyingAIEnabled = 47;
    if (has_flyingaienabled()) {
      total_size += 2 + 1;
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional bool shootingAIEnabled = 48;
    if (has_shootingaienabled()) {
      total_size += 2 + 1;
    }
    
    // optional .ast.Timer bankTimer = 49;
    if (has_banktimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->banktimer());
    }
    
    // optional .ast.Timer aliveTimer = 50;
    if (has_alivetimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->alivetimer());
    }
    
    // optional .ast.Timer respawnTimer = 51;
    if (has_respawntimer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->respawntimer());
    }
    
    // optional float timeLeftToRespawn = 52;
    if (has_timelefttorespawn()) {
      total_size += 2 + 4;
    }
    
    // optional int32 score = 53;
    if (has_score()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score());
    }
    
    // optional int32 kills = 54;
    if (has_kills()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->kills());
    }
    
    // optional int32 deaths = 55;
    if (has_deaths()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deaths());
    }
    
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional int32 life = 56;
    if (has_life()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->life());
    }
    
    // optional int32 bankedShards = 57;
    if (has_bankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bankedshards());
    }
    
    // optional int32 unbankedShards = 58;
    if (has_unbankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unbankedshards());
    }
    
    // optional int32 totalBankedShards = 59;
    if (has_totalbankedshards()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->totalbankedshards());
    }
    
    // optional uint32 ownerid = 60;
    if (has_ownerid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ownerid());
    }
    
    // optional float lifetime = 61;
    if (has_lifetime()) {
      total_size += 2 + 4;
    }
    
    // optional float timeFired = 62;
    if (has_timefired()) {
      total_size += 2 + 4;
    }
    
    // optional int32 weaponIndex = 63;
    if (has_weaponindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->weaponindex());
    }
    
  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    // optional float damage = 64;
    if (has_damage()) {
      total_size += 2 + 4;
    }
    
    // optional float chargeTime = 65;
    if (has_chargetime()) {
      total_size += 2 + 4;
    }
    
    // optional float damagePerSecond = 66;
    if (has_damagepersecond()) {
      total_size += 2 + 4;
    }
    
    // optional float timeSinceExploded = 67;
    if (has_timesinceexploded()) {
      total_size += 2 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_position()) {
      mutable_position()->::ast::Vector::MergeFrom(from.position());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::ast::Vector::MergeFrom(from.velocity());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_axis()) {
      mutable_axis()->::ast::Vector::MergeFrom(from.axis());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_rotationspeed()) {
      set_rotationspeed(from.rotationspeed());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_up()) {
      mutable_up()->::ast::Vector::MergeFrom(from.up());
    }
    if (from.has_right()) {
      mutable_right()->::ast::Vector::MergeFrom(from.right());
    }
    if (from.has_forward()) {
      mutable_forward()->::ast::Vector::MergeFrom(from.forward());
    }
    if (from.has_targetyawspeed()) {
      set_targetyawspeed(from.targetyawspeed());
    }
    if (from.has_targetpitchspeed()) {
      set_targetpitchspeed(from.targetpitchspeed());
    }
    if (from.has_targetrollspeed()) {
      set_targetrollspeed(from.targetrollspeed());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
    if (from.has_healthmax()) {
      set_healthmax(from.healthmax());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_enginelevel()) {
      set_enginelevel(from.enginelevel());
    }
    if (from.has_regenhealthlevel()) {
      set_regenhealthlevel(from.regenhealthlevel());
    }
    if (from.has_banklevel()) {
      set_banklevel(from.banklevel());
    }
    if (from.has_color1()) {
      set_color1(from.color1());
    }
    if (from.has_color2()) {
      set_color2(from.color2());
    }
    if (from.has_shotdirection()) {
      mutable_shotdirection()->::ast::Vector::MergeFrom(from.shotdirection());
    }
    if (from.has_isfiring()) {
      set_isfiring(from.isfiring());
    }
    if (from.has_currentweapon()) {
      set_currentweapon(from.currentweapon());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_isbarrelrollingleft()) {
      set_isbarrelrollingleft(from.isbarrelrollingleft());
    }
    if (from.has_isbarrelrollingright()) {
      set_isbarrelrollingright(from.isbarrelrollingright());
    }
    if (from.has_curforwardaccel()) {
      set_curforwardaccel(from.curforwardaccel());
    }
    if (from.has_currightaccel()) {
      set_currightaccel(from.currightaccel());
    }
    if (from.has_curupaccel()) {
      set_curupaccel(from.curupaccel());
    }
    if (from.has_isbraking()) {
      set_isbraking(from.isbraking());
    }
    if (from.has_bankperiod()) {
      set_bankperiod(from.bankperiod());
    }
    if (from.has_flyingaienabled()) {
      set_flyingaienabled(from.flyingaienabled());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_shootingaienabled()) {
      set_shootingaienabled(from.shootingaienabled());
    }
    if (from.has_banktimer()) {
      mutable_banktimer()->::ast::Timer::MergeFrom(from.banktimer());
    }
    if (from.has_alivetimer()) {
      mutable_alivetimer()->::ast::Timer::MergeFrom(from.alivetimer());
    }
    if (from.has_respawntimer()) {
      mutable_respawntimer()->::ast::Timer::MergeFrom(from.respawntimer());
    }
    if (from.has_timelefttorespawn()) {
      set_timelefttorespawn(from.timelefttorespawn());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_kills()) {
      set_kills(from.kills());
    }
    if (from.has_deaths()) {
      set_deaths(from.deaths());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_life()) {
      set_life(from.life());
    }
    if (from.has_bankedshards()) {
      set_bankedshards(from.bankedshards());
    }
    if (from.has_unbankedshards()) {
      set_unbankedshards(from.unbankedshards());
    }
    if (from.has_totalbankedshards()) {
      set_totalbankedshards(from.totalbankedshards());
    }
    if (from.has_ownerid()) {
      set_ownerid(from.ownerid());
    }
    if (from.has_lifetime()) {
      set_lifetime(from.lifetime());
    }
    if (from.has_timefired()) {
      set_timefired(from.timefired());
    }
    if (from.has_weaponindex()) {
      set_weaponindex(from.weaponindex());
    }
  }
  if (from._has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    if (from.has_damage()) {
      set_damage(from.damage());
    }
    if (from.has_chargetime()) {
      set_chargetime(from.chargetime());
    }
    if (from.has_damagepersecond()) {
      set_damagepersecond(from.damagepersecond());
    }
    if (from.has_timesinceexploded()) {
      set_timesinceexploded(from.timesinceexploded());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {
  
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_velocity()) {
    if (!this->velocity().IsInitialized()) return false;
  }
  if (has_axis()) {
    if (!this->axis().IsInitialized()) return false;
  }
  if (has_up()) {
    if (!this->up().IsInitialized()) return false;
  }
  if (has_right()) {
    if (!this->right().IsInitialized()) return false;
  }
  if (has_forward()) {
    if (!this->forward().IsInitialized()) return false;
  }
  if (has_shotdirection()) {
    if (!this->shotdirection().IsInitialized()) return false;
  }
  return true;
}

void Entity::Swap(Entity* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(radius_, other->radius_);
    std::swap(axis_, other->axis_);
    std::swap(angle_, other->angle_);
    std::swap(rotationspeed_, other->rotationspeed_);
    std::swap(up_, other->up_);
    std::swap(right_, other->right_);
    std::swap(forward_, other->forward_);
    std::swap(targetyawspeed_, other->targetyawspeed_);
    std::swap(targetpitchspeed_, other->targetpitchspeed_);
    std::swap(targetrollspeed_, other->targetrollspeed_);
    std::swap(health_, other->health_);
    std::swap(healthmax_, other->healthmax_);
    std::swap(enginelevel_, other->enginelevel_);
    std::swap(regenhealthlevel_, other->regenhealthlevel_);
    std::swap(banklevel_, other->banklevel_);
    std::swap(color1_, other->color1_);
    std::swap(color2_, other->color2_);
    std::swap(shotdirection_, other->shotdirection_);
    std::swap(isfiring_, other->isfiring_);
    std::swap(currentweapon_, other->currentweapon_);
    std::swap(isbarrelrollingleft_, other->isbarrelrollingleft_);
    std::swap(isbarrelrollingright_, other->isbarrelrollingright_);
    std::swap(curforwardaccel_, other->curforwardaccel_);
    std::swap(currightaccel_, other->currightaccel_);
    std::swap(curupaccel_, other->curupaccel_);
    std::swap(isbraking_, other->isbraking_);
    std::swap(bankperiod_, other->bankperiod_);
    std::swap(flyingaienabled_, other->flyingaienabled_);
    std::swap(shootingaienabled_, other->shootingaienabled_);
    std::swap(banktimer_, other->banktimer_);
    std::swap(alivetimer_, other->alivetimer_);
    std::swap(respawntimer_, other->respawntimer_);
    std::swap(timelefttorespawn_, other->timelefttorespawn_);
    std::swap(score_, other->score_);
    std::swap(kills_, other->kills_);
    std::swap(deaths_, other->deaths_);
    std::swap(life_, other->life_);
    std::swap(bankedshards_, other->bankedshards_);
    std::swap(unbankedshards_, other->unbankedshards_);
    std::swap(totalbankedshards_, other->totalbankedshards_);
    std::swap(ownerid_, other->ownerid_);
    std::swap(lifetime_, other->lifetime_);
    std::swap(timefired_, other->timefired_);
    std::swap(weaponindex_, other->weaponindex_);
    std::swap(damage_, other->damage_);
    std::swap(chargetime_, other->chargetime_);
    std::swap(damagepersecond_, other->damagepersecond_);
    std::swap(timesinceexploded_, other->timesinceexploded_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Timer::kTimeStartedFieldNumber;
const int Timer::kCountDownTimeFieldNumber;
const int Timer::kTimePausedFieldNumber;
const int Timer::kIsPausedFieldNumber;
const int Timer::kIsRunningFieldNumber;
#endif  // !_MSC_VER

Timer::Timer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Timer::InitAsDefaultInstance() {
}

Timer::Timer(const Timer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Timer::SharedCtor() {
  _cached_size_ = 0;
  timestarted_ = 0;
  countdowntime_ = 0;
  timepaused_ = 0;
  ispaused_ = false;
  isrunning_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timer::~Timer() {
  SharedDtor();
}

void Timer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Timer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timer_descriptor_;
}

const Timer& Timer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

Timer* Timer::default_instance_ = NULL;

Timer* Timer::New() const {
  return new Timer;
}

void Timer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestarted_ = 0;
    countdowntime_ = 0;
    timepaused_ = 0;
    ispaused_ = false;
    isrunning_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Timer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float timeStarted = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timestarted_)));
          set_has_timestarted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_countDownTime;
        break;
      }
      
      // optional float countDownTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_countDownTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &countdowntime_)));
          set_has_countdowntime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_timePaused;
        break;
      }
      
      // optional float timePaused = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timePaused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timepaused_)));
          set_has_timepaused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isPaused;
        break;
      }
      
      // optional bool isPaused = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isPaused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ispaused_)));
          set_has_ispaused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isRunning;
        break;
      }
      
      // optional bool isRunning = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isRunning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isrunning_)));
          set_has_isrunning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Timer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float timeStarted = 1;
  if (has_timestarted()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->timestarted(), output);
  }
  
  // optional float countDownTime = 2;
  if (has_countdowntime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->countdowntime(), output);
  }
  
  // optional float timePaused = 3;
  if (has_timepaused()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->timepaused(), output);
  }
  
  // optional bool isPaused = 4;
  if (has_ispaused()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->ispaused(), output);
  }
  
  // optional bool isRunning = 5;
  if (has_isrunning()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->isrunning(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Timer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float timeStarted = 1;
  if (has_timestarted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->timestarted(), target);
  }
  
  // optional float countDownTime = 2;
  if (has_countdowntime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->countdowntime(), target);
  }
  
  // optional float timePaused = 3;
  if (has_timepaused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->timepaused(), target);
  }
  
  // optional bool isPaused = 4;
  if (has_ispaused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->ispaused(), target);
  }
  
  // optional bool isRunning = 5;
  if (has_isrunning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->isrunning(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Timer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float timeStarted = 1;
    if (has_timestarted()) {
      total_size += 1 + 4;
    }
    
    // optional float countDownTime = 2;
    if (has_countdowntime()) {
      total_size += 1 + 4;
    }
    
    // optional float timePaused = 3;
    if (has_timepaused()) {
      total_size += 1 + 4;
    }
    
    // optional bool isPaused = 4;
    if (has_ispaused()) {
      total_size += 1 + 1;
    }
    
    // optional bool isRunning = 5;
    if (has_isrunning()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Timer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Timer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timer::MergeFrom(const Timer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestarted()) {
      set_timestarted(from.timestarted());
    }
    if (from.has_countdowntime()) {
      set_countdowntime(from.countdowntime());
    }
    if (from.has_timepaused()) {
      set_timepaused(from.timepaused());
    }
    if (from.has_ispaused()) {
      set_ispaused(from.ispaused());
    }
    if (from.has_isrunning()) {
      set_isrunning(from.isrunning());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Timer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timer::CopyFrom(const Timer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timer::IsInitialized() const {
  
  return true;
}

void Timer::Swap(Timer* other) {
  if (other != this) {
    std::swap(timestarted_, other->timestarted_);
    std::swap(countdowntime_, other->countdowntime_);
    std::swap(timepaused_, other->timepaused_);
    std::swap(ispaused_, other->ispaused_);
    std::swap(isrunning_, other->isrunning_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Timer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timer_descriptor_;
  metadata.reflection = Timer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GameState::kPlayerShipFieldNumber;
const int GameState::kGameTimeFieldNumber;
const int GameState::kLevelTimerFieldNumber;
const int GameState::kEntityFieldNumber;
const int GameState::kCurLevelFieldNumber;
#endif  // !_MSC_VER

GameState::GameState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameState::InitAsDefaultInstance() {
  leveltimer_ = const_cast< ::ast::Timer*>(&::ast::Timer::default_instance());
}

GameState::GameState(const GameState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameState::SharedCtor() {
  _cached_size_ = 0;
  playership_ = 0u;
  gametime_ = 0;
  leveltimer_ = NULL;
  curlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameState::~GameState() {
  SharedDtor();
}

void GameState::SharedDtor() {
  if (this != default_instance_) {
    delete leveltimer_;
  }
}

void GameState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameState_descriptor_;
}

const GameState& GameState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

GameState* GameState::default_instance_ = NULL;

GameState* GameState::New() const {
  return new GameState;
}

void GameState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    playership_ = 0u;
    gametime_ = 0;
    if (has_leveltimer()) {
      if (leveltimer_ != NULL) leveltimer_->::ast::Timer::Clear();
    }
    curlevel_ = 0;
  }
  entity_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ast.Entity entity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entity;
        if (input->ExpectTag(17)) goto parse_gameTime;
        break;
      }
      
      // required double gameTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_gameTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gametime_)));
          set_has_gametime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_playerShip;
        break;
      }
      
      // optional uint32 playerShip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerShip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &playership_)));
          set_has_playership();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_levelTimer;
        break;
      }
      
      // optional .ast.Timer levelTimer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_levelTimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leveltimer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_curLevel;
        break;
      }
      
      // optional int32 curLevel = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curlevel_)));
          set_has_curlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ast.Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entity(i), output);
  }
  
  // required double gameTime = 2;
  if (has_gametime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->gametime(), output);
  }
  
  // optional uint32 playerShip = 3;
  if (has_playership()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->playership(), output);
  }
  
  // optional .ast.Timer levelTimer = 4;
  if (has_leveltimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->leveltimer(), output);
  }
  
  // optional int32 curLevel = 5;
  if (has_curlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->curlevel(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ast.Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entity(i), target);
  }
  
  // required double gameTime = 2;
  if (has_gametime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->gametime(), target);
  }
  
  // optional uint32 playerShip = 3;
  if (has_playership()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->playership(), target);
  }
  
  // optional .ast.Timer levelTimer = 4;
  if (has_leveltimer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->leveltimer(), target);
  }
  
  // optional int32 curLevel = 5;
  if (has_curlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->curlevel(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameState::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 playerShip = 3;
    if (has_playership()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->playership());
    }
    
    // required double gameTime = 2;
    if (has_gametime()) {
      total_size += 1 + 8;
    }
    
    // optional .ast.Timer levelTimer = 4;
    if (has_leveltimer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->leveltimer());
    }
    
    // optional int32 curLevel = 5;
    if (has_curlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curlevel());
    }
    
  }
  // repeated .ast.Entity entity = 1;
  total_size += 1 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameState::MergeFrom(const GameState& from) {
  GOOGLE_CHECK_NE(&from, this);
  entity_.MergeFrom(from.entity_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playership()) {
      set_playership(from.playership());
    }
    if (from.has_gametime()) {
      set_gametime(from.gametime());
    }
    if (from.has_leveltimer()) {
      mutable_leveltimer()->::ast::Timer::MergeFrom(from.leveltimer());
    }
    if (from.has_curlevel()) {
      set_curlevel(from.curlevel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameState::CopyFrom(const GameState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  for (int i = 0; i < entity_size(); i++) {
    if (!this->entity(i).IsInitialized()) return false;
  }
  return true;
}

void GameState::Swap(GameState* other) {
  if (other != this) {
    std::swap(playership_, other->playership_);
    std::swap(gametime_, other->gametime_);
    std::swap(leveltimer_, other->leveltimer_);
    entity_.Swap(&other->entity_);
    std::swap(curlevel_, other->curlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameState_descriptor_;
  metadata.reflection = GameState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CollisionMessage::kMessageidFieldNumber;
const int CollisionMessage::kTimestampFieldNumber;
const int CollisionMessage::kObjectId1FieldNumber;
const int CollisionMessage::kObjectId2FieldNumber;
#endif  // !_MSC_VER

CollisionMessage::CollisionMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollisionMessage::InitAsDefaultInstance() {
}

CollisionMessage::CollisionMessage(const CollisionMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollisionMessage::SharedCtor() {
  _cached_size_ = 0;
  messageid_ = 0u;
  timestamp_ = 0;
  objectid1_ = 0u;
  objectid2_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollisionMessage::~CollisionMessage() {
  SharedDtor();
}

void CollisionMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CollisionMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollisionMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollisionMessage_descriptor_;
}

const CollisionMessage& CollisionMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

CollisionMessage* CollisionMessage::default_instance_ = NULL;

CollisionMessage* CollisionMessage::New() const {
  return new CollisionMessage;
}

void CollisionMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    messageid_ = 0u;
    timestamp_ = 0;
    objectid1_ = 0u;
    objectid2_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollisionMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_objectId1;
        break;
      }
      
      // optional uint32 objectId1 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_objectId1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &objectid1_)));
          set_has_objectid1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_objectId2;
        break;
      }
      
      // optional uint32 objectId2 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_objectId2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &objectid2_)));
          set_has_objectid2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_messageid;
        break;
      }
      
      // optional uint32 messageid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_messageid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &messageid_)));
          set_has_messageid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollisionMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }
  
  // optional uint32 objectId1 = 2;
  if (has_objectid1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->objectid1(), output);
  }
  
  // optional uint32 objectId2 = 3;
  if (has_objectid2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->objectid2(), output);
  }
  
  // optional uint32 messageid = 4;
  if (has_messageid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->messageid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollisionMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional double timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->timestamp(), target);
  }
  
  // optional uint32 objectId1 = 2;
  if (has_objectid1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->objectid1(), target);
  }
  
  // optional uint32 objectId2 = 3;
  if (has_objectid2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->objectid2(), target);
  }
  
  // optional uint32 messageid = 4;
  if (has_messageid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->messageid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollisionMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 messageid = 4;
    if (has_messageid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->messageid());
    }
    
    // optional double timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }
    
    // optional uint32 objectId1 = 2;
    if (has_objectid1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->objectid1());
    }
    
    // optional uint32 objectId2 = 3;
    if (has_objectid2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->objectid2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollisionMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollisionMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollisionMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollisionMessage::MergeFrom(const CollisionMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_messageid()) {
      set_messageid(from.messageid());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_objectid1()) {
      set_objectid1(from.objectid1());
    }
    if (from.has_objectid2()) {
      set_objectid2(from.objectid2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollisionMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollisionMessage::CopyFrom(const CollisionMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollisionMessage::IsInitialized() const {
  
  return true;
}

void CollisionMessage::Swap(CollisionMessage* other) {
  if (other != this) {
    std::swap(messageid_, other->messageid_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(objectid1_, other->objectid1_);
    std::swap(objectid2_, other->objectid2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollisionMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollisionMessage_descriptor_;
  metadata.reflection = CollisionMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChatMessage::kSourceidFieldNumber;
const int ChatMessage::kTextFieldNumber;
#endif  // !_MSC_VER

ChatMessage::ChatMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChatMessage::InitAsDefaultInstance() {
}

ChatMessage::ChatMessage(const ChatMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChatMessage::SharedCtor() {
  _cached_size_ = 0;
  sourceid_ = 0u;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChatMessage::~ChatMessage() {
  SharedDtor();
}

void ChatMessage::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
  }
}

void ChatMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChatMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChatMessage_descriptor_;
}

const ChatMessage& ChatMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

ChatMessage* ChatMessage::default_instance_ = NULL;

ChatMessage* ChatMessage::New() const {
  return new ChatMessage;
}

void ChatMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sourceid_ = 0u;
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChatMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sourceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sourceid_)));
          set_has_sourceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }
      
      // optional string text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChatMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 sourceid = 1;
  if (has_sourceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sourceid(), output);
  }
  
  // optional string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->text(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChatMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 sourceid = 1;
  if (has_sourceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sourceid(), target);
  }
  
  // optional string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChatMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sourceid = 1;
    if (has_sourceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sourceid());
    }
    
    // optional string text = 2;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChatMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChatMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChatMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChatMessage::MergeFrom(const ChatMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sourceid()) {
      set_sourceid(from.sourceid());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChatMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChatMessage::CopyFrom(const ChatMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChatMessage::IsInitialized() const {
  
  return true;
}

void ChatMessage::Swap(ChatMessage* other) {
  if (other != this) {
    std::swap(sourceid_, other->sourceid_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChatMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChatMessage_descriptor_;
  metadata.reflection = ChatMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateEntityMessage::kCreateEntityMessageidFieldNumber;
const int CreateEntityMessage::kEntityFieldNumber;
#endif  // !_MSC_VER

CreateEntityMessage::CreateEntityMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CreateEntityMessage::InitAsDefaultInstance() {
}

CreateEntityMessage::CreateEntityMessage(const CreateEntityMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CreateEntityMessage::SharedCtor() {
  _cached_size_ = 0;
  createentitymessageid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateEntityMessage::~CreateEntityMessage() {
  SharedDtor();
}

void CreateEntityMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CreateEntityMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateEntityMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateEntityMessage_descriptor_;
}

const CreateEntityMessage& CreateEntityMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

CreateEntityMessage* CreateEntityMessage::default_instance_ = NULL;

CreateEntityMessage* CreateEntityMessage::New() const {
  return new CreateEntityMessage;
}

void CreateEntityMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    createentitymessageid_ = 0u;
  }
  entity_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateEntityMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 createEntityMessageid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &createentitymessageid_)));
          set_has_createentitymessageid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_entity;
        break;
      }
      
      // repeated .ast.Entity entity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_entity;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateEntityMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 createEntityMessageid = 1;
  if (has_createentitymessageid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->createentitymessageid(), output);
  }
  
  // repeated .ast.Entity entity = 2;
  for (int i = 0; i < this->entity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entity(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CreateEntityMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 createEntityMessageid = 1;
  if (has_createentitymessageid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->createentitymessageid(), target);
  }
  
  // repeated .ast.Entity entity = 2;
  for (int i = 0; i < this->entity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entity(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CreateEntityMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 createEntityMessageid = 1;
    if (has_createentitymessageid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->createentitymessageid());
    }
    
  }
  // repeated .ast.Entity entity = 2;
  total_size += 1 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateEntityMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateEntityMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateEntityMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateEntityMessage::MergeFrom(const CreateEntityMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  entity_.MergeFrom(from.entity_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_createentitymessageid()) {
      set_createentitymessageid(from.createentitymessageid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateEntityMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateEntityMessage::CopyFrom(const CreateEntityMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateEntityMessage::IsInitialized() const {
  
  for (int i = 0; i < entity_size(); i++) {
    if (!this->entity(i).IsInitialized()) return false;
  }
  return true;
}

void CreateEntityMessage::Swap(CreateEntityMessage* other) {
  if (other != this) {
    std::swap(createentitymessageid_, other->createentitymessageid_);
    entity_.Swap(&other->entity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateEntityMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateEntityMessage_descriptor_;
  metadata.reflection = CreateEntityMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServerToClient::kSeqFieldNumber;
const int ServerToClient::kAckFieldNumber;
const int ServerToClient::kTimestampFieldNumber;
const int ServerToClient::kGameStateFieldNumber;
const int ServerToClient::kCollisionMessageFieldNumber;
const int ServerToClient::kChatMessageFieldNumber;
#endif  // !_MSC_VER

ServerToClient::ServerToClient()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServerToClient::InitAsDefaultInstance() {
  gamestate_ = const_cast< ::ast::GameState*>(&::ast::GameState::default_instance());
}

ServerToClient::ServerToClient(const ServerToClient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServerToClient::SharedCtor() {
  _cached_size_ = 0;
  seq_ = GOOGLE_ULONGLONG(0);
  ack_ = GOOGLE_ULONGLONG(0);
  timestamp_ = 0;
  gamestate_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerToClient::~ServerToClient() {
  SharedDtor();
}

void ServerToClient::SharedDtor() {
  if (this != default_instance_) {
    delete gamestate_;
  }
}

void ServerToClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServerToClient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServerToClient_descriptor_;
}

const ServerToClient& ServerToClient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Network_2fgamestate_2eproto();  return *default_instance_;
}

ServerToClient* ServerToClient::default_instance_ = NULL;

ServerToClient* ServerToClient::New() const {
  return new ServerToClient;
}

void ServerToClient::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seq_ = GOOGLE_ULONGLONG(0);
    ack_ = GOOGLE_ULONGLONG(0);
    timestamp_ = 0;
    if (has_gamestate()) {
      if (gamestate_ != NULL) gamestate_->::ast::GameState::Clear();
    }
  }
  collisionmessage_.Clear();
  chatmessage_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServerToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ast.CollisionMessage collisionMessage = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_collisionMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_collisionmessage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_collisionMessage;
        if (input->ExpectTag(18)) goto parse_chatMessage;
        break;
      }
      
      // repeated .ast.ChatMessage chatMessage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chatMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_chatmessage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_chatMessage;
        if (input->ExpectTag(24)) goto parse_seq;
        break;
      }
      
      // optional uint64 seq = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ack;
        break;
      }
      
      // optional uint64 ack = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ack_)));
          set_has_ack();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_timestamp;
        break;
      }
      
      // optional double timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_gameState;
        break;
      }
      
      // optional .ast.GameState gameState = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gameState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gamestate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServerToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ast.CollisionMessage collisionMessage = 1;
  for (int i = 0; i < this->collisionmessage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->collisionmessage(i), output);
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  for (int i = 0; i < this->chatmessage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->chatmessage(i), output);
  }
  
  // optional uint64 seq = 3;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->seq(), output);
  }
  
  // optional uint64 ack = 4;
  if (has_ack()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->ack(), output);
  }
  
  // optional double timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->timestamp(), output);
  }
  
  // optional .ast.GameState gameState = 17;
  if (has_gamestate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, this->gamestate(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServerToClient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ast.CollisionMessage collisionMessage = 1;
  for (int i = 0; i < this->collisionmessage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->collisionmessage(i), target);
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  for (int i = 0; i < this->chatmessage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->chatmessage(i), target);
  }
  
  // optional uint64 seq = 3;
  if (has_seq()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->seq(), target);
  }
  
  // optional uint64 ack = 4;
  if (has_ack()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->ack(), target);
  }
  
  // optional double timestamp = 5;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->timestamp(), target);
  }
  
  // optional .ast.GameState gameState = 17;
  if (has_gamestate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, this->gamestate(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServerToClient::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 seq = 3;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->seq());
    }
    
    // optional uint64 ack = 4;
    if (has_ack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ack());
    }
    
    // optional double timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }
    
    // optional .ast.GameState gameState = 17;
    if (has_gamestate()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gamestate());
    }
    
  }
  // repeated .ast.CollisionMessage collisionMessage = 1;
  total_size += 1 * this->collisionmessage_size();
  for (int i = 0; i < this->collisionmessage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->collisionmessage(i));
  }
  
  // repeated .ast.ChatMessage chatMessage = 2;
  total_size += 1 * this->chatmessage_size();
  for (int i = 0; i < this->chatmessage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chatmessage(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerToClient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServerToClient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServerToClient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServerToClient::MergeFrom(const ServerToClient& from) {
  GOOGLE_CHECK_NE(&from, this);
  collisionmessage_.MergeFrom(from.collisionmessage_);
  chatmessage_.MergeFrom(from.chatmessage_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_ack()) {
      set_ack(from.ack());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_gamestate()) {
      mutable_gamestate()->::ast::GameState::MergeFrom(from.gamestate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServerToClient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServerToClient::CopyFrom(const ServerToClient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerToClient::IsInitialized() const {
  
  if (has_gamestate()) {
    if (!this->gamestate().IsInitialized()) return false;
  }
  return true;
}

void ServerToClient::Swap(ServerToClient* other) {
  if (other != this) {
    std::swap(seq_, other->seq_);
    std::swap(ack_, other->ack_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(gamestate_, other->gamestate_);
    collisionmessage_.Swap(&other->collisionmessage_);
    chatmessage_.Swap(&other->chatmessage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServerToClient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServerToClient_descriptor_;
  metadata.reflection = ServerToClient_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ast

// @@protoc_insertion_point(global_scope)
