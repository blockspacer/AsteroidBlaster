// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Network/gamestate.proto

#ifndef PROTOBUF_Network_2fgamestate_2eproto__INCLUDED
#define PROTOBUF_Network_2fgamestate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ast {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Network_2fgamestate_2eproto();
void protobuf_AssignDesc_Network_2fgamestate_2eproto();
void protobuf_ShutdownFile_Network_2fgamestate_2eproto();

class Vector;
class Entity;
class GameState;
class CollisionMessage;
class ChatMessage;
class CreateEntityMessage;
class ServerToClient;

// ===================================================================

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();
  
  Vector(const Vector& from);
  
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();
  
  void Swap(Vector* other);
  
  // implements Message ----------------------------------------------
  
  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);
  
  // @@protoc_insertion_point(class_scope:ast.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  double z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();
  
  Entity(const Entity& from);
  
  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();
  
  void Swap(Entity* other);
  
  // implements Message ----------------------------------------------
  
  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional .ast.Vector position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::ast::Vector& position() const;
  inline ::ast::Vector* mutable_position();
  inline ::ast::Vector* release_position();
  
  // optional .ast.Vector velocity = 4;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  inline const ::ast::Vector& velocity() const;
  inline ::ast::Vector* mutable_velocity();
  inline ::ast::Vector* release_velocity();
  
  // optional float radius = 19;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 19;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional .ast.Vector axis = 21;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 21;
  inline const ::ast::Vector& axis() const;
  inline ::ast::Vector* mutable_axis();
  inline ::ast::Vector* release_axis();
  
  // optional float angle = 25;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 25;
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional float rotationSpeed = 26;
  inline bool has_rotationspeed() const;
  inline void clear_rotationspeed();
  static const int kRotationSpeedFieldNumber = 26;
  inline float rotationspeed() const;
  inline void set_rotationspeed(float value);
  
  // optional .ast.Vector up = 22;
  inline bool has_up() const;
  inline void clear_up();
  static const int kUpFieldNumber = 22;
  inline const ::ast::Vector& up() const;
  inline ::ast::Vector* mutable_up();
  inline ::ast::Vector* release_up();
  
  // optional .ast.Vector right = 23;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 23;
  inline const ::ast::Vector& right() const;
  inline ::ast::Vector* mutable_right();
  inline ::ast::Vector* release_right();
  
  // optional .ast.Vector forward = 24;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 24;
  inline const ::ast::Vector& forward() const;
  inline ::ast::Vector* mutable_forward();
  inline ::ast::Vector* release_forward();
  
  // optional float targetYawSpeed = 27;
  inline bool has_targetyawspeed() const;
  inline void clear_targetyawspeed();
  static const int kTargetYawSpeedFieldNumber = 27;
  inline float targetyawspeed() const;
  inline void set_targetyawspeed(float value);
  
  // optional float targetPitchSpeed = 28;
  inline bool has_targetpitchspeed() const;
  inline void clear_targetpitchspeed();
  static const int kTargetPitchSpeedFieldNumber = 28;
  inline float targetpitchspeed() const;
  inline void set_targetpitchspeed(float value);
  
  // optional float targetRollSpeed = 29;
  inline bool has_targetrollspeed() const;
  inline void clear_targetrollspeed();
  static const int kTargetRollSpeedFieldNumber = 29;
  inline float targetrollspeed() const;
  inline void set_targetrollspeed(float value);
  
  // optional float health = 30;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 30;
  inline float health() const;
  inline void set_health(float value);
  
  // optional float healthMax = 31;
  inline bool has_healthmax() const;
  inline void clear_healthmax();
  static const int kHealthMaxFieldNumber = 31;
  inline float healthmax() const;
  inline void set_healthmax(float value);
  
  // optional int32 engineLevel = 32;
  inline bool has_enginelevel() const;
  inline void clear_enginelevel();
  static const int kEngineLevelFieldNumber = 32;
  inline ::google::protobuf::int32 enginelevel() const;
  inline void set_enginelevel(::google::protobuf::int32 value);
  
  // optional int32 regenHealthLevel = 33;
  inline bool has_regenhealthlevel() const;
  inline void clear_regenhealthlevel();
  static const int kRegenHealthLevelFieldNumber = 33;
  inline ::google::protobuf::int32 regenhealthlevel() const;
  inline void set_regenhealthlevel(::google::protobuf::int32 value);
  
  // optional int32 bankLevel = 34;
  inline bool has_banklevel() const;
  inline void clear_banklevel();
  static const int kBankLevelFieldNumber = 34;
  inline ::google::protobuf::int32 banklevel() const;
  inline void set_banklevel(::google::protobuf::int32 value);
  
  // optional float color1 = 35;
  inline bool has_color1() const;
  inline void clear_color1();
  static const int kColor1FieldNumber = 35;
  inline float color1() const;
  inline void set_color1(float value);
  
  // optional float color2 = 36;
  inline bool has_color2() const;
  inline void clear_color2();
  static const int kColor2FieldNumber = 36;
  inline float color2() const;
  inline void set_color2(float value);
  
  // optional .ast.Vector shotDirection = 37;
  inline bool has_shotdirection() const;
  inline void clear_shotdirection();
  static const int kShotDirectionFieldNumber = 37;
  inline const ::ast::Vector& shotdirection() const;
  inline ::ast::Vector* mutable_shotdirection();
  inline ::ast::Vector* release_shotdirection();
  
  // optional bool isFiring = 38;
  inline bool has_isfiring() const;
  inline void clear_isfiring();
  static const int kIsFiringFieldNumber = 38;
  inline bool isfiring() const;
  inline void set_isfiring(bool value);
  
  // optional int32 currentWeapon = 39;
  inline bool has_currentweapon() const;
  inline void clear_currentweapon();
  static const int kCurrentWeaponFieldNumber = 39;
  inline ::google::protobuf::int32 currentweapon() const;
  inline void set_currentweapon(::google::protobuf::int32 value);
  
  // optional float isBarrelRollingLeft = 40;
  inline bool has_isbarrelrollingleft() const;
  inline void clear_isbarrelrollingleft();
  static const int kIsBarrelRollingLeftFieldNumber = 40;
  inline float isbarrelrollingleft() const;
  inline void set_isbarrelrollingleft(float value);
  
  // optional float isBarrelRollingRight = 41;
  inline bool has_isbarrelrollingright() const;
  inline void clear_isbarrelrollingright();
  static const int kIsBarrelRollingRightFieldNumber = 41;
  inline float isbarrelrollingright() const;
  inline void set_isbarrelrollingright(float value);
  
  // optional float curForwardAccel = 42;
  inline bool has_curforwardaccel() const;
  inline void clear_curforwardaccel();
  static const int kCurForwardAccelFieldNumber = 42;
  inline float curforwardaccel() const;
  inline void set_curforwardaccel(float value);
  
  // optional float curRightAccel = 43;
  inline bool has_currightaccel() const;
  inline void clear_currightaccel();
  static const int kCurRightAccelFieldNumber = 43;
  inline float currightaccel() const;
  inline void set_currightaccel(float value);
  
  // optional float curUpAccel = 44;
  inline bool has_curupaccel() const;
  inline void clear_curupaccel();
  static const int kCurUpAccelFieldNumber = 44;
  inline float curupaccel() const;
  inline void set_curupaccel(float value);
  
  // optional bool isBraking = 45;
  inline bool has_isbraking() const;
  inline void clear_isbraking();
  static const int kIsBrakingFieldNumber = 45;
  inline bool isbraking() const;
  inline void set_isbraking(bool value);
  
  // optional float bankPeriod = 46;
  inline bool has_bankperiod() const;
  inline void clear_bankperiod();
  static const int kBankPeriodFieldNumber = 46;
  inline float bankperiod() const;
  inline void set_bankperiod(float value);
  
  // @@protoc_insertion_point(class_scope:ast.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_rotationspeed();
  inline void clear_has_rotationspeed();
  inline void set_has_up();
  inline void clear_has_up();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_targetyawspeed();
  inline void clear_has_targetyawspeed();
  inline void set_has_targetpitchspeed();
  inline void clear_has_targetpitchspeed();
  inline void set_has_targetrollspeed();
  inline void clear_has_targetrollspeed();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_healthmax();
  inline void clear_has_healthmax();
  inline void set_has_enginelevel();
  inline void clear_has_enginelevel();
  inline void set_has_regenhealthlevel();
  inline void clear_has_regenhealthlevel();
  inline void set_has_banklevel();
  inline void clear_has_banklevel();
  inline void set_has_color1();
  inline void clear_has_color1();
  inline void set_has_color2();
  inline void clear_has_color2();
  inline void set_has_shotdirection();
  inline void clear_has_shotdirection();
  inline void set_has_isfiring();
  inline void clear_has_isfiring();
  inline void set_has_currentweapon();
  inline void clear_has_currentweapon();
  inline void set_has_isbarrelrollingleft();
  inline void clear_has_isbarrelrollingleft();
  inline void set_has_isbarrelrollingright();
  inline void clear_has_isbarrelrollingright();
  inline void set_has_curforwardaccel();
  inline void clear_has_curforwardaccel();
  inline void set_has_currightaccel();
  inline void clear_has_currightaccel();
  inline void set_has_curupaccel();
  inline void clear_has_curupaccel();
  inline void set_has_isbraking();
  inline void clear_has_isbraking();
  inline void set_has_bankperiod();
  inline void clear_has_bankperiod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::ast::Vector* position_;
  ::ast::Vector* velocity_;
  ::ast::Vector* axis_;
  float radius_;
  float angle_;
  ::ast::Vector* up_;
  float rotationspeed_;
  float targetyawspeed_;
  ::ast::Vector* right_;
  ::ast::Vector* forward_;
  float targetpitchspeed_;
  float targetrollspeed_;
  float health_;
  float healthmax_;
  ::google::protobuf::int32 enginelevel_;
  ::google::protobuf::int32 regenhealthlevel_;
  ::google::protobuf::int32 banklevel_;
  float color1_;
  ::ast::Vector* shotdirection_;
  float color2_;
  ::google::protobuf::int32 currentweapon_;
  float isbarrelrollingleft_;
  float isbarrelrollingright_;
  bool isfiring_;
  bool isbraking_;
  float curforwardaccel_;
  float currightaccel_;
  float curupaccel_;
  float bankperiod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message {
 public:
  GameState();
  virtual ~GameState();
  
  GameState(const GameState& from);
  
  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();
  
  void Swap(GameState* other);
  
  // implements Message ----------------------------------------------
  
  GameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 playerShip = 3;
  inline bool has_playership() const;
  inline void clear_playership();
  static const int kPlayerShipFieldNumber = 3;
  inline ::google::protobuf::uint32 playership() const;
  inline void set_playership(::google::protobuf::uint32 value);
  
  // required double gameTime = 2;
  inline bool has_gametime() const;
  inline void clear_gametime();
  static const int kGameTimeFieldNumber = 2;
  inline double gametime() const;
  inline void set_gametime(double value);
  
  // optional double levelStartTime = 4;
  inline bool has_levelstarttime() const;
  inline void clear_levelstarttime();
  static const int kLevelStartTimeFieldNumber = 4;
  inline double levelstarttime() const;
  inline void set_levelstarttime(double value);
  
  // repeated .ast.Entity entity = 1;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::ast::Entity& entity(int index) const;
  inline ::ast::Entity* mutable_entity(int index);
  inline ::ast::Entity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
      mutable_entity();
  
  // @@protoc_insertion_point(class_scope:ast.GameState)
 private:
  inline void set_has_playership();
  inline void clear_has_playership();
  inline void set_has_gametime();
  inline void clear_has_gametime();
  inline void set_has_levelstarttime();
  inline void clear_has_levelstarttime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double gametime_;
  double levelstarttime_;
  ::google::protobuf::RepeatedPtrField< ::ast::Entity > entity_;
  ::google::protobuf::uint32 playership_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// -------------------------------------------------------------------

class CollisionMessage : public ::google::protobuf::Message {
 public:
  CollisionMessage();
  virtual ~CollisionMessage();
  
  CollisionMessage(const CollisionMessage& from);
  
  inline CollisionMessage& operator=(const CollisionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionMessage& default_instance();
  
  void Swap(CollisionMessage* other);
  
  // implements Message ----------------------------------------------
  
  CollisionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionMessage& from);
  void MergeFrom(const CollisionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 messageid = 4;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageidFieldNumber = 4;
  inline ::google::protobuf::uint32 messageid() const;
  inline void set_messageid(::google::protobuf::uint32 value);
  
  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // optional uint32 objectId1 = 2;
  inline bool has_objectid1() const;
  inline void clear_objectid1();
  static const int kObjectId1FieldNumber = 2;
  inline ::google::protobuf::uint32 objectid1() const;
  inline void set_objectid1(::google::protobuf::uint32 value);
  
  // optional uint32 objectId2 = 3;
  inline bool has_objectid2() const;
  inline void clear_objectid2();
  static const int kObjectId2FieldNumber = 3;
  inline ::google::protobuf::uint32 objectid2() const;
  inline void set_objectid2(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ast.CollisionMessage)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_objectid1();
  inline void clear_has_objectid1();
  inline void set_has_objectid2();
  inline void clear_has_objectid2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double timestamp_;
  ::google::protobuf::uint32 messageid_;
  ::google::protobuf::uint32 objectid1_;
  ::google::protobuf::uint32 objectid2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static CollisionMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::Message {
 public:
  ChatMessage();
  virtual ~ChatMessage();
  
  ChatMessage(const ChatMessage& from);
  
  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();
  
  void Swap(ChatMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 sourceid = 1;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceidFieldNumber = 1;
  inline ::google::protobuf::uint32 sourceid() const;
  inline void set_sourceid(::google::protobuf::uint32 value);
  
  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:ast.ChatMessage)
 private:
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  ::google::protobuf::uint32 sourceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class CreateEntityMessage : public ::google::protobuf::Message {
 public:
  CreateEntityMessage();
  virtual ~CreateEntityMessage();
  
  CreateEntityMessage(const CreateEntityMessage& from);
  
  inline CreateEntityMessage& operator=(const CreateEntityMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateEntityMessage& default_instance();
  
  void Swap(CreateEntityMessage* other);
  
  // implements Message ----------------------------------------------
  
  CreateEntityMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateEntityMessage& from);
  void MergeFrom(const CreateEntityMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 createEntityMessageid = 1;
  inline bool has_createentitymessageid() const;
  inline void clear_createentitymessageid();
  static const int kCreateEntityMessageidFieldNumber = 1;
  inline ::google::protobuf::uint32 createentitymessageid() const;
  inline void set_createentitymessageid(::google::protobuf::uint32 value);
  
  // repeated .ast.Entity entity = 2;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::ast::Entity& entity(int index) const;
  inline ::ast::Entity* mutable_entity(int index);
  inline ::ast::Entity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
      mutable_entity();
  
  // @@protoc_insertion_point(class_scope:ast.CreateEntityMessage)
 private:
  inline void set_has_createentitymessageid();
  inline void clear_has_createentitymessageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ast::Entity > entity_;
  ::google::protobuf::uint32 createentitymessageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static CreateEntityMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClient : public ::google::protobuf::Message {
 public:
  ServerToClient();
  virtual ~ServerToClient();
  
  ServerToClient(const ServerToClient& from);
  
  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClient& default_instance();
  
  void Swap(ServerToClient* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 seq = 3;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 3;
  inline ::google::protobuf::uint64 seq() const;
  inline void set_seq(::google::protobuf::uint64 value);
  
  // optional uint64 ack = 4;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 4;
  inline ::google::protobuf::uint64 ack() const;
  inline void set_ack(::google::protobuf::uint64 value);
  
  // optional double timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // optional .ast.GameState gameState = 17;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 17;
  inline const ::ast::GameState& gamestate() const;
  inline ::ast::GameState* mutable_gamestate();
  inline ::ast::GameState* release_gamestate();
  
  // repeated .ast.CollisionMessage collisionMessage = 1;
  inline int collisionmessage_size() const;
  inline void clear_collisionmessage();
  static const int kCollisionMessageFieldNumber = 1;
  inline const ::ast::CollisionMessage& collisionmessage(int index) const;
  inline ::ast::CollisionMessage* mutable_collisionmessage(int index);
  inline ::ast::CollisionMessage* add_collisionmessage();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >&
      collisionmessage() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >*
      mutable_collisionmessage();
  
  // repeated .ast.ChatMessage chatMessage = 2;
  inline int chatmessage_size() const;
  inline void clear_chatmessage();
  static const int kChatMessageFieldNumber = 2;
  inline const ::ast::ChatMessage& chatmessage(int index) const;
  inline ::ast::ChatMessage* mutable_chatmessage(int index);
  inline ::ast::ChatMessage* add_chatmessage();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::ChatMessage >&
      chatmessage() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::ChatMessage >*
      mutable_chatmessage();
  
  // @@protoc_insertion_point(class_scope:ast.ServerToClient)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 seq_;
  ::google::protobuf::uint64 ack_;
  double timestamp_;
  ::ast::GameState* gamestate_;
  ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage > collisionmessage_;
  ::google::protobuf::RepeatedPtrField< ::ast::ChatMessage > chatmessage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClient* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector

// required double x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector::x() const {
  return x_;
}
inline void Vector::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector::y() const {
  return y_;
}
inline void Vector::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector::z() const {
  return z_;
}
inline void Vector::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Entity

// optional uint32 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Entity::id() const {
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 type = 2;
inline bool Entity::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Entity::type() const {
  return type_;
}
inline void Entity::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .ast.Vector position = 3;
inline bool Entity::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_position() {
  if (position_ != NULL) position_->::ast::Vector::Clear();
  clear_has_position();
}
inline const ::ast::Vector& Entity::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::ast::Vector* Entity::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::ast::Vector;
  return position_;
}
inline ::ast::Vector* Entity::release_position() {
  clear_has_position();
  ::ast::Vector* temp = position_;
  position_ = NULL;
  return temp;
}

// optional .ast.Vector velocity = 4;
inline bool Entity::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::ast::Vector::Clear();
  clear_has_velocity();
}
inline const ::ast::Vector& Entity::velocity() const {
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::ast::Vector* Entity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::ast::Vector;
  return velocity_;
}
inline ::ast::Vector* Entity::release_velocity() {
  clear_has_velocity();
  ::ast::Vector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}

// optional float radius = 19;
inline bool Entity::has_radius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entity::set_has_radius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entity::clear_has_radius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entity::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Entity::radius() const {
  return radius_;
}
inline void Entity::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional .ast.Vector axis = 21;
inline bool Entity::has_axis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_axis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_axis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_axis() {
  if (axis_ != NULL) axis_->::ast::Vector::Clear();
  clear_has_axis();
}
inline const ::ast::Vector& Entity::axis() const {
  return axis_ != NULL ? *axis_ : *default_instance_->axis_;
}
inline ::ast::Vector* Entity::mutable_axis() {
  set_has_axis();
  if (axis_ == NULL) axis_ = new ::ast::Vector;
  return axis_;
}
inline ::ast::Vector* Entity::release_axis() {
  clear_has_axis();
  ::ast::Vector* temp = axis_;
  axis_ = NULL;
  return temp;
}

// optional float angle = 25;
inline bool Entity::has_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Entity::angle() const {
  return angle_;
}
inline void Entity::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float rotationSpeed = 26;
inline bool Entity::has_rotationspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_rotationspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_rotationspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_rotationspeed() {
  rotationspeed_ = 0;
  clear_has_rotationspeed();
}
inline float Entity::rotationspeed() const {
  return rotationspeed_;
}
inline void Entity::set_rotationspeed(float value) {
  set_has_rotationspeed();
  rotationspeed_ = value;
}

// optional .ast.Vector up = 22;
inline bool Entity::has_up() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_up() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_up() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_up() {
  if (up_ != NULL) up_->::ast::Vector::Clear();
  clear_has_up();
}
inline const ::ast::Vector& Entity::up() const {
  return up_ != NULL ? *up_ : *default_instance_->up_;
}
inline ::ast::Vector* Entity::mutable_up() {
  set_has_up();
  if (up_ == NULL) up_ = new ::ast::Vector;
  return up_;
}
inline ::ast::Vector* Entity::release_up() {
  clear_has_up();
  ::ast::Vector* temp = up_;
  up_ = NULL;
  return temp;
}

// optional .ast.Vector right = 23;
inline bool Entity::has_right() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_right() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_right() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_right() {
  if (right_ != NULL) right_->::ast::Vector::Clear();
  clear_has_right();
}
inline const ::ast::Vector& Entity::right() const {
  return right_ != NULL ? *right_ : *default_instance_->right_;
}
inline ::ast::Vector* Entity::mutable_right() {
  set_has_right();
  if (right_ == NULL) right_ = new ::ast::Vector;
  return right_;
}
inline ::ast::Vector* Entity::release_right() {
  clear_has_right();
  ::ast::Vector* temp = right_;
  right_ = NULL;
  return temp;
}

// optional .ast.Vector forward = 24;
inline bool Entity::has_forward() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Entity::set_has_forward() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Entity::clear_has_forward() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Entity::clear_forward() {
  if (forward_ != NULL) forward_->::ast::Vector::Clear();
  clear_has_forward();
}
inline const ::ast::Vector& Entity::forward() const {
  return forward_ != NULL ? *forward_ : *default_instance_->forward_;
}
inline ::ast::Vector* Entity::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) forward_ = new ::ast::Vector;
  return forward_;
}
inline ::ast::Vector* Entity::release_forward() {
  clear_has_forward();
  ::ast::Vector* temp = forward_;
  forward_ = NULL;
  return temp;
}

// optional float targetYawSpeed = 27;
inline bool Entity::has_targetyawspeed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Entity::set_has_targetyawspeed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Entity::clear_has_targetyawspeed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Entity::clear_targetyawspeed() {
  targetyawspeed_ = 0;
  clear_has_targetyawspeed();
}
inline float Entity::targetyawspeed() const {
  return targetyawspeed_;
}
inline void Entity::set_targetyawspeed(float value) {
  set_has_targetyawspeed();
  targetyawspeed_ = value;
}

// optional float targetPitchSpeed = 28;
inline bool Entity::has_targetpitchspeed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Entity::set_has_targetpitchspeed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Entity::clear_has_targetpitchspeed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Entity::clear_targetpitchspeed() {
  targetpitchspeed_ = 0;
  clear_has_targetpitchspeed();
}
inline float Entity::targetpitchspeed() const {
  return targetpitchspeed_;
}
inline void Entity::set_targetpitchspeed(float value) {
  set_has_targetpitchspeed();
  targetpitchspeed_ = value;
}

// optional float targetRollSpeed = 29;
inline bool Entity::has_targetrollspeed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Entity::set_has_targetrollspeed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Entity::clear_has_targetrollspeed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Entity::clear_targetrollspeed() {
  targetrollspeed_ = 0;
  clear_has_targetrollspeed();
}
inline float Entity::targetrollspeed() const {
  return targetrollspeed_;
}
inline void Entity::set_targetrollspeed(float value) {
  set_has_targetrollspeed();
  targetrollspeed_ = value;
}

// optional float health = 30;
inline bool Entity::has_health() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Entity::set_has_health() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Entity::clear_has_health() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Entity::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float Entity::health() const {
  return health_;
}
inline void Entity::set_health(float value) {
  set_has_health();
  health_ = value;
}

// optional float healthMax = 31;
inline bool Entity::has_healthmax() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Entity::set_has_healthmax() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Entity::clear_has_healthmax() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Entity::clear_healthmax() {
  healthmax_ = 0;
  clear_has_healthmax();
}
inline float Entity::healthmax() const {
  return healthmax_;
}
inline void Entity::set_healthmax(float value) {
  set_has_healthmax();
  healthmax_ = value;
}

// optional int32 engineLevel = 32;
inline bool Entity::has_enginelevel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Entity::set_has_enginelevel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Entity::clear_has_enginelevel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Entity::clear_enginelevel() {
  enginelevel_ = 0;
  clear_has_enginelevel();
}
inline ::google::protobuf::int32 Entity::enginelevel() const {
  return enginelevel_;
}
inline void Entity::set_enginelevel(::google::protobuf::int32 value) {
  set_has_enginelevel();
  enginelevel_ = value;
}

// optional int32 regenHealthLevel = 33;
inline bool Entity::has_regenhealthlevel() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Entity::set_has_regenhealthlevel() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Entity::clear_has_regenhealthlevel() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Entity::clear_regenhealthlevel() {
  regenhealthlevel_ = 0;
  clear_has_regenhealthlevel();
}
inline ::google::protobuf::int32 Entity::regenhealthlevel() const {
  return regenhealthlevel_;
}
inline void Entity::set_regenhealthlevel(::google::protobuf::int32 value) {
  set_has_regenhealthlevel();
  regenhealthlevel_ = value;
}

// optional int32 bankLevel = 34;
inline bool Entity::has_banklevel() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Entity::set_has_banklevel() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Entity::clear_has_banklevel() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Entity::clear_banklevel() {
  banklevel_ = 0;
  clear_has_banklevel();
}
inline ::google::protobuf::int32 Entity::banklevel() const {
  return banklevel_;
}
inline void Entity::set_banklevel(::google::protobuf::int32 value) {
  set_has_banklevel();
  banklevel_ = value;
}

// optional float color1 = 35;
inline bool Entity::has_color1() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Entity::set_has_color1() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Entity::clear_has_color1() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Entity::clear_color1() {
  color1_ = 0;
  clear_has_color1();
}
inline float Entity::color1() const {
  return color1_;
}
inline void Entity::set_color1(float value) {
  set_has_color1();
  color1_ = value;
}

// optional float color2 = 36;
inline bool Entity::has_color2() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Entity::set_has_color2() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Entity::clear_has_color2() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Entity::clear_color2() {
  color2_ = 0;
  clear_has_color2();
}
inline float Entity::color2() const {
  return color2_;
}
inline void Entity::set_color2(float value) {
  set_has_color2();
  color2_ = value;
}

// optional .ast.Vector shotDirection = 37;
inline bool Entity::has_shotdirection() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Entity::set_has_shotdirection() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Entity::clear_has_shotdirection() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Entity::clear_shotdirection() {
  if (shotdirection_ != NULL) shotdirection_->::ast::Vector::Clear();
  clear_has_shotdirection();
}
inline const ::ast::Vector& Entity::shotdirection() const {
  return shotdirection_ != NULL ? *shotdirection_ : *default_instance_->shotdirection_;
}
inline ::ast::Vector* Entity::mutable_shotdirection() {
  set_has_shotdirection();
  if (shotdirection_ == NULL) shotdirection_ = new ::ast::Vector;
  return shotdirection_;
}
inline ::ast::Vector* Entity::release_shotdirection() {
  clear_has_shotdirection();
  ::ast::Vector* temp = shotdirection_;
  shotdirection_ = NULL;
  return temp;
}

// optional bool isFiring = 38;
inline bool Entity::has_isfiring() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Entity::set_has_isfiring() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Entity::clear_has_isfiring() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Entity::clear_isfiring() {
  isfiring_ = false;
  clear_has_isfiring();
}
inline bool Entity::isfiring() const {
  return isfiring_;
}
inline void Entity::set_isfiring(bool value) {
  set_has_isfiring();
  isfiring_ = value;
}

// optional int32 currentWeapon = 39;
inline bool Entity::has_currentweapon() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Entity::set_has_currentweapon() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Entity::clear_has_currentweapon() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Entity::clear_currentweapon() {
  currentweapon_ = 0;
  clear_has_currentweapon();
}
inline ::google::protobuf::int32 Entity::currentweapon() const {
  return currentweapon_;
}
inline void Entity::set_currentweapon(::google::protobuf::int32 value) {
  set_has_currentweapon();
  currentweapon_ = value;
}

// optional float isBarrelRollingLeft = 40;
inline bool Entity::has_isbarrelrollingleft() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Entity::set_has_isbarrelrollingleft() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Entity::clear_has_isbarrelrollingleft() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Entity::clear_isbarrelrollingleft() {
  isbarrelrollingleft_ = 0;
  clear_has_isbarrelrollingleft();
}
inline float Entity::isbarrelrollingleft() const {
  return isbarrelrollingleft_;
}
inline void Entity::set_isbarrelrollingleft(float value) {
  set_has_isbarrelrollingleft();
  isbarrelrollingleft_ = value;
}

// optional float isBarrelRollingRight = 41;
inline bool Entity::has_isbarrelrollingright() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Entity::set_has_isbarrelrollingright() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Entity::clear_has_isbarrelrollingright() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Entity::clear_isbarrelrollingright() {
  isbarrelrollingright_ = 0;
  clear_has_isbarrelrollingright();
}
inline float Entity::isbarrelrollingright() const {
  return isbarrelrollingright_;
}
inline void Entity::set_isbarrelrollingright(float value) {
  set_has_isbarrelrollingright();
  isbarrelrollingright_ = value;
}

// optional float curForwardAccel = 42;
inline bool Entity::has_curforwardaccel() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Entity::set_has_curforwardaccel() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Entity::clear_has_curforwardaccel() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Entity::clear_curforwardaccel() {
  curforwardaccel_ = 0;
  clear_has_curforwardaccel();
}
inline float Entity::curforwardaccel() const {
  return curforwardaccel_;
}
inline void Entity::set_curforwardaccel(float value) {
  set_has_curforwardaccel();
  curforwardaccel_ = value;
}

// optional float curRightAccel = 43;
inline bool Entity::has_currightaccel() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Entity::set_has_currightaccel() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Entity::clear_has_currightaccel() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Entity::clear_currightaccel() {
  currightaccel_ = 0;
  clear_has_currightaccel();
}
inline float Entity::currightaccel() const {
  return currightaccel_;
}
inline void Entity::set_currightaccel(float value) {
  set_has_currightaccel();
  currightaccel_ = value;
}

// optional float curUpAccel = 44;
inline bool Entity::has_curupaccel() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Entity::set_has_curupaccel() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Entity::clear_has_curupaccel() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Entity::clear_curupaccel() {
  curupaccel_ = 0;
  clear_has_curupaccel();
}
inline float Entity::curupaccel() const {
  return curupaccel_;
}
inline void Entity::set_curupaccel(float value) {
  set_has_curupaccel();
  curupaccel_ = value;
}

// optional bool isBraking = 45;
inline bool Entity::has_isbraking() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Entity::set_has_isbraking() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Entity::clear_has_isbraking() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Entity::clear_isbraking() {
  isbraking_ = false;
  clear_has_isbraking();
}
inline bool Entity::isbraking() const {
  return isbraking_;
}
inline void Entity::set_isbraking(bool value) {
  set_has_isbraking();
  isbraking_ = value;
}

// optional float bankPeriod = 46;
inline bool Entity::has_bankperiod() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Entity::set_has_bankperiod() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Entity::clear_has_bankperiod() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Entity::clear_bankperiod() {
  bankperiod_ = 0;
  clear_has_bankperiod();
}
inline float Entity::bankperiod() const {
  return bankperiod_;
}
inline void Entity::set_bankperiod(float value) {
  set_has_bankperiod();
  bankperiod_ = value;
}

// -------------------------------------------------------------------

// GameState

// optional uint32 playerShip = 3;
inline bool GameState::has_playership() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState::set_has_playership() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState::clear_has_playership() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState::clear_playership() {
  playership_ = 0u;
  clear_has_playership();
}
inline ::google::protobuf::uint32 GameState::playership() const {
  return playership_;
}
inline void GameState::set_playership(::google::protobuf::uint32 value) {
  set_has_playership();
  playership_ = value;
}

// required double gameTime = 2;
inline bool GameState::has_gametime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameState::set_has_gametime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameState::clear_has_gametime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameState::clear_gametime() {
  gametime_ = 0;
  clear_has_gametime();
}
inline double GameState::gametime() const {
  return gametime_;
}
inline void GameState::set_gametime(double value) {
  set_has_gametime();
  gametime_ = value;
}

// optional double levelStartTime = 4;
inline bool GameState::has_levelstarttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameState::set_has_levelstarttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameState::clear_has_levelstarttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameState::clear_levelstarttime() {
  levelstarttime_ = 0;
  clear_has_levelstarttime();
}
inline double GameState::levelstarttime() const {
  return levelstarttime_;
}
inline void GameState::set_levelstarttime(double value) {
  set_has_levelstarttime();
  levelstarttime_ = value;
}

// repeated .ast.Entity entity = 1;
inline int GameState::entity_size() const {
  return entity_.size();
}
inline void GameState::clear_entity() {
  entity_.Clear();
}
inline const ::ast::Entity& GameState::entity(int index) const {
  return entity_.Get(index);
}
inline ::ast::Entity* GameState::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::ast::Entity* GameState::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
GameState::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
GameState::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// CollisionMessage

// optional uint32 messageid = 4;
inline bool CollisionMessage::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionMessage::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionMessage::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionMessage::clear_messageid() {
  messageid_ = 0u;
  clear_has_messageid();
}
inline ::google::protobuf::uint32 CollisionMessage::messageid() const {
  return messageid_;
}
inline void CollisionMessage::set_messageid(::google::protobuf::uint32 value) {
  set_has_messageid();
  messageid_ = value;
}

// optional double timestamp = 1;
inline bool CollisionMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionMessage::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double CollisionMessage::timestamp() const {
  return timestamp_;
}
inline void CollisionMessage::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 objectId1 = 2;
inline bool CollisionMessage::has_objectid1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionMessage::set_has_objectid1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionMessage::clear_has_objectid1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionMessage::clear_objectid1() {
  objectid1_ = 0u;
  clear_has_objectid1();
}
inline ::google::protobuf::uint32 CollisionMessage::objectid1() const {
  return objectid1_;
}
inline void CollisionMessage::set_objectid1(::google::protobuf::uint32 value) {
  set_has_objectid1();
  objectid1_ = value;
}

// optional uint32 objectId2 = 3;
inline bool CollisionMessage::has_objectid2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollisionMessage::set_has_objectid2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollisionMessage::clear_has_objectid2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollisionMessage::clear_objectid2() {
  objectid2_ = 0u;
  clear_has_objectid2();
}
inline ::google::protobuf::uint32 CollisionMessage::objectid2() const {
  return objectid2_;
}
inline void CollisionMessage::set_objectid2(::google::protobuf::uint32 value) {
  set_has_objectid2();
  objectid2_ = value;
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 sourceid = 1;
inline bool ChatMessage::has_sourceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_sourceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_sourceid() {
  sourceid_ = 0u;
  clear_has_sourceid();
}
inline ::google::protobuf::uint32 ChatMessage::sourceid() const {
  return sourceid_;
}
inline void ChatMessage::set_sourceid(::google::protobuf::uint32 value) {
  set_has_sourceid();
  sourceid_ = value;
}

// optional string text = 2;
inline bool ChatMessage::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ChatMessage::text() const {
  return *text_;
}
inline void ChatMessage::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChatMessage::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChatMessage::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ChatMessage::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreateEntityMessage

// optional uint32 createEntityMessageid = 1;
inline bool CreateEntityMessage::has_createentitymessageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateEntityMessage::set_has_createentitymessageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateEntityMessage::clear_has_createentitymessageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateEntityMessage::clear_createentitymessageid() {
  createentitymessageid_ = 0u;
  clear_has_createentitymessageid();
}
inline ::google::protobuf::uint32 CreateEntityMessage::createentitymessageid() const {
  return createentitymessageid_;
}
inline void CreateEntityMessage::set_createentitymessageid(::google::protobuf::uint32 value) {
  set_has_createentitymessageid();
  createentitymessageid_ = value;
}

// repeated .ast.Entity entity = 2;
inline int CreateEntityMessage::entity_size() const {
  return entity_.size();
}
inline void CreateEntityMessage::clear_entity() {
  entity_.Clear();
}
inline const ::ast::Entity& CreateEntityMessage::entity(int index) const {
  return entity_.Get(index);
}
inline ::ast::Entity* CreateEntityMessage::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::ast::Entity* CreateEntityMessage::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
CreateEntityMessage::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
CreateEntityMessage::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// ServerToClient

// optional uint64 seq = 3;
inline bool ServerToClient::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClient::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClient::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClient::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 ServerToClient::seq() const {
  return seq_;
}
inline void ServerToClient::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
}

// optional uint64 ack = 4;
inline bool ServerToClient::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClient::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClient::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClient::clear_ack() {
  ack_ = GOOGLE_ULONGLONG(0);
  clear_has_ack();
}
inline ::google::protobuf::uint64 ServerToClient::ack() const {
  return ack_;
}
inline void ServerToClient::set_ack(::google::protobuf::uint64 value) {
  set_has_ack();
  ack_ = value;
}

// optional double timestamp = 5;
inline bool ServerToClient::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClient::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerToClient::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerToClient::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ServerToClient::timestamp() const {
  return timestamp_;
}
inline void ServerToClient::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .ast.GameState gameState = 17;
inline bool ServerToClient::has_gamestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClient::set_has_gamestate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerToClient::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerToClient::clear_gamestate() {
  if (gamestate_ != NULL) gamestate_->::ast::GameState::Clear();
  clear_has_gamestate();
}
inline const ::ast::GameState& ServerToClient::gamestate() const {
  return gamestate_ != NULL ? *gamestate_ : *default_instance_->gamestate_;
}
inline ::ast::GameState* ServerToClient::mutable_gamestate() {
  set_has_gamestate();
  if (gamestate_ == NULL) gamestate_ = new ::ast::GameState;
  return gamestate_;
}
inline ::ast::GameState* ServerToClient::release_gamestate() {
  clear_has_gamestate();
  ::ast::GameState* temp = gamestate_;
  gamestate_ = NULL;
  return temp;
}

// repeated .ast.CollisionMessage collisionMessage = 1;
inline int ServerToClient::collisionmessage_size() const {
  return collisionmessage_.size();
}
inline void ServerToClient::clear_collisionmessage() {
  collisionmessage_.Clear();
}
inline const ::ast::CollisionMessage& ServerToClient::collisionmessage(int index) const {
  return collisionmessage_.Get(index);
}
inline ::ast::CollisionMessage* ServerToClient::mutable_collisionmessage(int index) {
  return collisionmessage_.Mutable(index);
}
inline ::ast::CollisionMessage* ServerToClient::add_collisionmessage() {
  return collisionmessage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >&
ServerToClient::collisionmessage() const {
  return collisionmessage_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >*
ServerToClient::mutable_collisionmessage() {
  return &collisionmessage_;
}

// repeated .ast.ChatMessage chatMessage = 2;
inline int ServerToClient::chatmessage_size() const {
  return chatmessage_.size();
}
inline void ServerToClient::clear_chatmessage() {
  chatmessage_.Clear();
}
inline const ::ast::ChatMessage& ServerToClient::chatmessage(int index) const {
  return chatmessage_.Get(index);
}
inline ::ast::ChatMessage* ServerToClient::mutable_chatmessage(int index) {
  return chatmessage_.Mutable(index);
}
inline ::ast::ChatMessage* ServerToClient::add_chatmessage() {
  return chatmessage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::ChatMessage >&
ServerToClient::chatmessage() const {
  return chatmessage_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::ChatMessage >*
ServerToClient::mutable_chatmessage() {
  return &chatmessage_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ast

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Network_2fgamestate_2eproto__INCLUDED
