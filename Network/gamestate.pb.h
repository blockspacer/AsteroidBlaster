// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Network/gamestate.proto

#ifndef PROTOBUF_Network_2fgamestate_2eproto__INCLUDED
#define PROTOBUF_Network_2fgamestate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ast {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Network_2fgamestate_2eproto();
void protobuf_AssignDesc_Network_2fgamestate_2eproto();
void protobuf_ShutdownFile_Network_2fgamestate_2eproto();

class Vector;
class Entity;
class Weapon;
class ClientCommand;
class Timer;
class GameState;
class CollisionMessage;
class ChatMessage;
class CreateEntityMessage;
class Frame;

// ===================================================================

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();
  
  Vector(const Vector& from);
  
  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();
  
  void Swap(Vector* other);
  
  // implements Message ----------------------------------------------
  
  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:ast.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();
  
  Entity(const Entity& from);
  
  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();
  
  void Swap(Entity* other);
  
  // implements Message ----------------------------------------------
  
  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional .ast.Vector position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::ast::Vector& position() const;
  inline ::ast::Vector* mutable_position();
  inline ::ast::Vector* release_position();
  
  // optional .ast.Vector velocity = 4;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  inline const ::ast::Vector& velocity() const;
  inline ::ast::Vector* mutable_velocity();
  inline ::ast::Vector* release_velocity();
  
  // repeated .ast.Weapon weapon = 5;
  inline int weapon_size() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 5;
  inline const ::ast::Weapon& weapon(int index) const;
  inline ::ast::Weapon* mutable_weapon(int index);
  inline ::ast::Weapon* add_weapon();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::Weapon >&
      weapon() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::Weapon >*
      mutable_weapon();
  
  // optional .ast.Vector targetup = 6;
  inline bool has_targetup() const;
  inline void clear_targetup();
  static const int kTargetupFieldNumber = 6;
  inline const ::ast::Vector& targetup() const;
  inline ::ast::Vector* mutable_targetup();
  inline ::ast::Vector* release_targetup();
  
  // optional .ast.Vector targetright = 7;
  inline bool has_targetright() const;
  inline void clear_targetright();
  static const int kTargetrightFieldNumber = 7;
  inline const ::ast::Vector& targetright() const;
  inline ::ast::Vector* mutable_targetright();
  inline ::ast::Vector* release_targetright();
  
  // optional .ast.Vector targetforward = 8;
  inline bool has_targetforward() const;
  inline void clear_targetforward();
  static const int kTargetforwardFieldNumber = 8;
  inline const ::ast::Vector& targetforward() const;
  inline ::ast::Vector* mutable_targetforward();
  inline ::ast::Vector* release_targetforward();
  
  // optional float radius = 19;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 19;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional .ast.Vector axis = 21;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 21;
  inline const ::ast::Vector& axis() const;
  inline ::ast::Vector* mutable_axis();
  inline ::ast::Vector* release_axis();
  
  // optional float angle = 25;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 25;
  inline float angle() const;
  inline void set_angle(float value);
  
  // optional float rotationSpeed = 26;
  inline bool has_rotationspeed() const;
  inline void clear_rotationspeed();
  static const int kRotationSpeedFieldNumber = 26;
  inline float rotationspeed() const;
  inline void set_rotationspeed(float value);
  
  // optional float targetYawSpeed = 27;
  inline bool has_targetyawspeed() const;
  inline void clear_targetyawspeed();
  static const int kTargetYawSpeedFieldNumber = 27;
  inline float targetyawspeed() const;
  inline void set_targetyawspeed(float value);
  
  // optional float targetPitchSpeed = 28;
  inline bool has_targetpitchspeed() const;
  inline void clear_targetpitchspeed();
  static const int kTargetPitchSpeedFieldNumber = 28;
  inline float targetpitchspeed() const;
  inline void set_targetpitchspeed(float value);
  
  // optional float targetRollSpeed = 29;
  inline bool has_targetrollspeed() const;
  inline void clear_targetrollspeed();
  static const int kTargetRollSpeedFieldNumber = 29;
  inline float targetrollspeed() const;
  inline void set_targetrollspeed(float value);
  
  // optional float health = 30;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 30;
  inline float health() const;
  inline void set_health(float value);
  
  // optional float healthMax = 31;
  inline bool has_healthmax() const;
  inline void clear_healthmax();
  static const int kHealthMaxFieldNumber = 31;
  inline float healthmax() const;
  inline void set_healthmax(float value);
  
  // optional int32 engineLevel = 32;
  inline bool has_enginelevel() const;
  inline void clear_enginelevel();
  static const int kEngineLevelFieldNumber = 32;
  inline ::google::protobuf::int32 enginelevel() const;
  inline void set_enginelevel(::google::protobuf::int32 value);
  
  // optional int32 regenHealthLevel = 33;
  inline bool has_regenhealthlevel() const;
  inline void clear_regenhealthlevel();
  static const int kRegenHealthLevelFieldNumber = 33;
  inline ::google::protobuf::int32 regenhealthlevel() const;
  inline void set_regenhealthlevel(::google::protobuf::int32 value);
  
  // optional int32 bankLevel = 34;
  inline bool has_banklevel() const;
  inline void clear_banklevel();
  static const int kBankLevelFieldNumber = 34;
  inline ::google::protobuf::int32 banklevel() const;
  inline void set_banklevel(::google::protobuf::int32 value);
  
  // optional float color1 = 35;
  inline bool has_color1() const;
  inline void clear_color1();
  static const int kColor1FieldNumber = 35;
  inline float color1() const;
  inline void set_color1(float value);
  
  // optional float color2 = 36;
  inline bool has_color2() const;
  inline void clear_color2();
  static const int kColor2FieldNumber = 36;
  inline float color2() const;
  inline void set_color2(float value);
  
  // optional .ast.Vector shotDirection = 37;
  inline bool has_shotdirection() const;
  inline void clear_shotdirection();
  static const int kShotDirectionFieldNumber = 37;
  inline const ::ast::Vector& shotdirection() const;
  inline ::ast::Vector* mutable_shotdirection();
  inline ::ast::Vector* release_shotdirection();
  
  // optional bool isFiring = 38;
  inline bool has_isfiring() const;
  inline void clear_isfiring();
  static const int kIsFiringFieldNumber = 38;
  inline bool isfiring() const;
  inline void set_isfiring(bool value);
  
  // optional int32 currentWeapon = 39;
  inline bool has_currentweapon() const;
  inline void clear_currentweapon();
  static const int kCurrentWeaponFieldNumber = 39;
  inline ::google::protobuf::int32 currentweapon() const;
  inline void set_currentweapon(::google::protobuf::int32 value);
  
  // optional float isBarrelRollingLeft = 40;
  inline bool has_isbarrelrollingleft() const;
  inline void clear_isbarrelrollingleft();
  static const int kIsBarrelRollingLeftFieldNumber = 40;
  inline float isbarrelrollingleft() const;
  inline void set_isbarrelrollingleft(float value);
  
  // optional float isBarrelRollingRight = 41;
  inline bool has_isbarrelrollingright() const;
  inline void clear_isbarrelrollingright();
  static const int kIsBarrelRollingRightFieldNumber = 41;
  inline float isbarrelrollingright() const;
  inline void set_isbarrelrollingright(float value);
  
  // optional float curForwardAccel = 42;
  inline bool has_curforwardaccel() const;
  inline void clear_curforwardaccel();
  static const int kCurForwardAccelFieldNumber = 42;
  inline float curforwardaccel() const;
  inline void set_curforwardaccel(float value);
  
  // optional float curRightAccel = 43;
  inline bool has_currightaccel() const;
  inline void clear_currightaccel();
  static const int kCurRightAccelFieldNumber = 43;
  inline float currightaccel() const;
  inline void set_currightaccel(float value);
  
  // optional float curUpAccel = 44;
  inline bool has_curupaccel() const;
  inline void clear_curupaccel();
  static const int kCurUpAccelFieldNumber = 44;
  inline float curupaccel() const;
  inline void set_curupaccel(float value);
  
  // optional bool isBraking = 45;
  inline bool has_isbraking() const;
  inline void clear_isbraking();
  static const int kIsBrakingFieldNumber = 45;
  inline bool isbraking() const;
  inline void set_isbraking(bool value);
  
  // optional float bankPeriod = 46;
  inline bool has_bankperiod() const;
  inline void clear_bankperiod();
  static const int kBankPeriodFieldNumber = 46;
  inline float bankperiod() const;
  inline void set_bankperiod(float value);
  
  // optional bool flyingAIEnabled = 47;
  inline bool has_flyingaienabled() const;
  inline void clear_flyingaienabled();
  static const int kFlyingAIEnabledFieldNumber = 47;
  inline bool flyingaienabled() const;
  inline void set_flyingaienabled(bool value);
  
  // optional bool shootingAIEnabled = 48;
  inline bool has_shootingaienabled() const;
  inline void clear_shootingaienabled();
  static const int kShootingAIEnabledFieldNumber = 48;
  inline bool shootingaienabled() const;
  inline void set_shootingaienabled(bool value);
  
  // optional .ast.Timer bankTimer = 49;
  inline bool has_banktimer() const;
  inline void clear_banktimer();
  static const int kBankTimerFieldNumber = 49;
  inline const ::ast::Timer& banktimer() const;
  inline ::ast::Timer* mutable_banktimer();
  inline ::ast::Timer* release_banktimer();
  
  // optional .ast.Timer aliveTimer = 50;
  inline bool has_alivetimer() const;
  inline void clear_alivetimer();
  static const int kAliveTimerFieldNumber = 50;
  inline const ::ast::Timer& alivetimer() const;
  inline ::ast::Timer* mutable_alivetimer();
  inline ::ast::Timer* release_alivetimer();
  
  // optional .ast.Timer respawnTimer = 51;
  inline bool has_respawntimer() const;
  inline void clear_respawntimer();
  static const int kRespawnTimerFieldNumber = 51;
  inline const ::ast::Timer& respawntimer() const;
  inline ::ast::Timer* mutable_respawntimer();
  inline ::ast::Timer* release_respawntimer();
  
  // optional float timeLeftToRespawn = 52;
  inline bool has_timelefttorespawn() const;
  inline void clear_timelefttorespawn();
  static const int kTimeLeftToRespawnFieldNumber = 52;
  inline float timelefttorespawn() const;
  inline void set_timelefttorespawn(float value);
  
  // optional int32 score = 53;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 53;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // optional int32 kills = 54;
  inline bool has_kills() const;
  inline void clear_kills();
  static const int kKillsFieldNumber = 54;
  inline ::google::protobuf::int32 kills() const;
  inline void set_kills(::google::protobuf::int32 value);
  
  // optional int32 deaths = 55;
  inline bool has_deaths() const;
  inline void clear_deaths();
  static const int kDeathsFieldNumber = 55;
  inline ::google::protobuf::int32 deaths() const;
  inline void set_deaths(::google::protobuf::int32 value);
  
  // optional int32 lives = 56;
  inline bool has_lives() const;
  inline void clear_lives();
  static const int kLivesFieldNumber = 56;
  inline ::google::protobuf::int32 lives() const;
  inline void set_lives(::google::protobuf::int32 value);
  
  // optional int32 bankedShards = 57;
  inline bool has_bankedshards() const;
  inline void clear_bankedshards();
  static const int kBankedShardsFieldNumber = 57;
  inline ::google::protobuf::int32 bankedshards() const;
  inline void set_bankedshards(::google::protobuf::int32 value);
  
  // optional int32 unbankedShards = 58;
  inline bool has_unbankedshards() const;
  inline void clear_unbankedshards();
  static const int kUnbankedShardsFieldNumber = 58;
  inline ::google::protobuf::int32 unbankedshards() const;
  inline void set_unbankedshards(::google::protobuf::int32 value);
  
  // optional int32 totalBankedShards = 59;
  inline bool has_totalbankedshards() const;
  inline void clear_totalbankedshards();
  static const int kTotalBankedShardsFieldNumber = 59;
  inline ::google::protobuf::int32 totalbankedshards() const;
  inline void set_totalbankedshards(::google::protobuf::int32 value);
  
  // optional uint32 ownerid = 60;
  inline bool has_ownerid() const;
  inline void clear_ownerid();
  static const int kOwneridFieldNumber = 60;
  inline ::google::protobuf::uint32 ownerid() const;
  inline void set_ownerid(::google::protobuf::uint32 value);
  
  // optional float lifetime = 61;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 61;
  inline float lifetime() const;
  inline void set_lifetime(float value);
  
  // optional float timeFired = 62;
  inline bool has_timefired() const;
  inline void clear_timefired();
  static const int kTimeFiredFieldNumber = 62;
  inline float timefired() const;
  inline void set_timefired(float value);
  
  // optional int32 weaponIndex = 63;
  inline bool has_weaponindex() const;
  inline void clear_weaponindex();
  static const int kWeaponIndexFieldNumber = 63;
  inline ::google::protobuf::int32 weaponindex() const;
  inline void set_weaponindex(::google::protobuf::int32 value);
  
  // optional float damage = 64;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 64;
  inline float damage() const;
  inline void set_damage(float value);
  
  // optional float chargeTime = 65;
  inline bool has_chargetime() const;
  inline void clear_chargetime();
  static const int kChargeTimeFieldNumber = 65;
  inline float chargetime() const;
  inline void set_chargetime(float value);
  
  // optional float damagePerSecond = 66;
  inline bool has_damagepersecond() const;
  inline void clear_damagepersecond();
  static const int kDamagePerSecondFieldNumber = 66;
  inline float damagepersecond() const;
  inline void set_damagepersecond(float value);
  
  // optional float timeSinceExploded = 67;
  inline bool has_timesinceexploded() const;
  inline void clear_timesinceexploded();
  static const int kTimeSinceExplodedFieldNumber = 67;
  inline float timesinceexploded() const;
  inline void set_timesinceexploded(float value);
  
  // optional bool energyHit = 68;
  inline bool has_energyhit() const;
  inline void clear_energyhit();
  static const int kEnergyHitFieldNumber = 68;
  inline bool energyhit() const;
  inline void set_energyhit(bool value);
  
  // optional float timeLastHitByEnergy = 69;
  inline bool has_timelasthitbyenergy() const;
  inline void clear_timelasthitbyenergy();
  static const int kTimeLastHitByEnergyFieldNumber = 69;
  inline float timelasthitbyenergy() const;
  inline void set_timelasthitbyenergy(float value);
  
  // optional bool shouldRemove = 70;
  inline bool has_shouldremove() const;
  inline void clear_shouldremove();
  static const int kShouldRemoveFieldNumber = 70;
  inline bool shouldremove() const;
  inline void set_shouldremove(bool value);
  
  // optional float length = 71;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 71;
  inline float length() const;
  inline void set_length(float value);
  
  // optional int32 releasedShards = 72;
  inline bool has_releasedshards() const;
  inline void clear_releasedshards();
  static const int kReleasedShardsFieldNumber = 72;
  inline ::google::protobuf::int32 releasedshards() const;
  inline void set_releasedshards(::google::protobuf::int32 value);
  
  // optional uint32 shardType = 73;
  inline bool has_shardtype() const;
  inline void clear_shardtype();
  static const int kShardTypeFieldNumber = 73;
  inline ::google::protobuf::uint32 shardtype() const;
  inline void set_shardtype(::google::protobuf::uint32 value);
  
  // optional uint32 weapNum = 74;
  inline bool has_weapnum() const;
  inline void clear_weapnum();
  static const int kWeapNumFieldNumber = 74;
  inline ::google::protobuf::uint32 weapnum() const;
  inline void set_weapnum(::google::protobuf::uint32 value);
  
  // optional .ast.Vector up = 75;
  inline bool has_up() const;
  inline void clear_up();
  static const int kUpFieldNumber = 75;
  inline const ::ast::Vector& up() const;
  inline ::ast::Vector* mutable_up();
  inline ::ast::Vector* release_up();
  
  // optional .ast.Vector right = 76;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 76;
  inline const ::ast::Vector& right() const;
  inline ::ast::Vector* mutable_right();
  inline ::ast::Vector* release_right();
  
  // optional .ast.Vector forward = 77;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 77;
  inline const ::ast::Vector& forward() const;
  inline ::ast::Vector* mutable_forward();
  inline ::ast::Vector* release_forward();
  
  // @@protoc_insertion_point(class_scope:ast.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_targetup();
  inline void clear_has_targetup();
  inline void set_has_targetright();
  inline void clear_has_targetright();
  inline void set_has_targetforward();
  inline void clear_has_targetforward();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_rotationspeed();
  inline void clear_has_rotationspeed();
  inline void set_has_targetyawspeed();
  inline void clear_has_targetyawspeed();
  inline void set_has_targetpitchspeed();
  inline void clear_has_targetpitchspeed();
  inline void set_has_targetrollspeed();
  inline void clear_has_targetrollspeed();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_healthmax();
  inline void clear_has_healthmax();
  inline void set_has_enginelevel();
  inline void clear_has_enginelevel();
  inline void set_has_regenhealthlevel();
  inline void clear_has_regenhealthlevel();
  inline void set_has_banklevel();
  inline void clear_has_banklevel();
  inline void set_has_color1();
  inline void clear_has_color1();
  inline void set_has_color2();
  inline void clear_has_color2();
  inline void set_has_shotdirection();
  inline void clear_has_shotdirection();
  inline void set_has_isfiring();
  inline void clear_has_isfiring();
  inline void set_has_currentweapon();
  inline void clear_has_currentweapon();
  inline void set_has_isbarrelrollingleft();
  inline void clear_has_isbarrelrollingleft();
  inline void set_has_isbarrelrollingright();
  inline void clear_has_isbarrelrollingright();
  inline void set_has_curforwardaccel();
  inline void clear_has_curforwardaccel();
  inline void set_has_currightaccel();
  inline void clear_has_currightaccel();
  inline void set_has_curupaccel();
  inline void clear_has_curupaccel();
  inline void set_has_isbraking();
  inline void clear_has_isbraking();
  inline void set_has_bankperiod();
  inline void clear_has_bankperiod();
  inline void set_has_flyingaienabled();
  inline void clear_has_flyingaienabled();
  inline void set_has_shootingaienabled();
  inline void clear_has_shootingaienabled();
  inline void set_has_banktimer();
  inline void clear_has_banktimer();
  inline void set_has_alivetimer();
  inline void clear_has_alivetimer();
  inline void set_has_respawntimer();
  inline void clear_has_respawntimer();
  inline void set_has_timelefttorespawn();
  inline void clear_has_timelefttorespawn();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_kills();
  inline void clear_has_kills();
  inline void set_has_deaths();
  inline void clear_has_deaths();
  inline void set_has_lives();
  inline void clear_has_lives();
  inline void set_has_bankedshards();
  inline void clear_has_bankedshards();
  inline void set_has_unbankedshards();
  inline void clear_has_unbankedshards();
  inline void set_has_totalbankedshards();
  inline void clear_has_totalbankedshards();
  inline void set_has_ownerid();
  inline void clear_has_ownerid();
  inline void set_has_lifetime();
  inline void clear_has_lifetime();
  inline void set_has_timefired();
  inline void clear_has_timefired();
  inline void set_has_weaponindex();
  inline void clear_has_weaponindex();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_chargetime();
  inline void clear_has_chargetime();
  inline void set_has_damagepersecond();
  inline void clear_has_damagepersecond();
  inline void set_has_timesinceexploded();
  inline void clear_has_timesinceexploded();
  inline void set_has_energyhit();
  inline void clear_has_energyhit();
  inline void set_has_timelasthitbyenergy();
  inline void clear_has_timelasthitbyenergy();
  inline void set_has_shouldremove();
  inline void clear_has_shouldremove();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_releasedshards();
  inline void clear_has_releasedshards();
  inline void set_has_shardtype();
  inline void clear_has_shardtype();
  inline void set_has_weapnum();
  inline void clear_has_weapnum();
  inline void set_has_up();
  inline void clear_has_up();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_forward();
  inline void clear_has_forward();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::ast::Vector* position_;
  ::ast::Vector* velocity_;
  ::google::protobuf::RepeatedPtrField< ::ast::Weapon > weapon_;
  ::ast::Vector* targetup_;
  ::ast::Vector* targetright_;
  ::ast::Vector* targetforward_;
  ::ast::Vector* axis_;
  float radius_;
  float angle_;
  float rotationspeed_;
  float targetyawspeed_;
  float targetpitchspeed_;
  float targetrollspeed_;
  float health_;
  float healthmax_;
  ::google::protobuf::int32 enginelevel_;
  ::google::protobuf::int32 regenhealthlevel_;
  ::google::protobuf::int32 banklevel_;
  float color1_;
  ::ast::Vector* shotdirection_;
  float color2_;
  ::google::protobuf::int32 currentweapon_;
  float isbarrelrollingleft_;
  float isbarrelrollingright_;
  float curforwardaccel_;
  float currightaccel_;
  float curupaccel_;
  bool isfiring_;
  bool isbraking_;
  bool flyingaienabled_;
  bool shootingaienabled_;
  ::ast::Timer* banktimer_;
  float bankperiod_;
  float timelefttorespawn_;
  ::ast::Timer* alivetimer_;
  ::ast::Timer* respawntimer_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 kills_;
  ::google::protobuf::int32 deaths_;
  ::google::protobuf::int32 lives_;
  ::google::protobuf::int32 bankedshards_;
  ::google::protobuf::int32 unbankedshards_;
  ::google::protobuf::int32 totalbankedshards_;
  ::google::protobuf::uint32 ownerid_;
  float lifetime_;
  float timefired_;
  ::google::protobuf::int32 weaponindex_;
  float damage_;
  float chargetime_;
  float damagepersecond_;
  float timesinceexploded_;
  float timelasthitbyenergy_;
  bool energyhit_;
  bool shouldremove_;
  float length_;
  ::google::protobuf::int32 releasedshards_;
  ::google::protobuf::uint32 shardtype_;
  ::ast::Vector* up_;
  ::ast::Vector* right_;
  ::ast::Vector* forward_;
  ::google::protobuf::uint32 weapnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(63 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class Weapon : public ::google::protobuf::Message {
 public:
  Weapon();
  virtual ~Weapon();
  
  Weapon(const Weapon& from);
  
  inline Weapon& operator=(const Weapon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Weapon& default_instance();
  
  void Swap(Weapon* other);
  
  // implements Message ----------------------------------------------
  
  Weapon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Weapon& from);
  void MergeFrom(const Weapon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // optional .ast.Timer activationTimer = 2;
  inline bool has_activationtimer() const;
  inline void clear_activationtimer();
  static const int kActivationTimerFieldNumber = 2;
  inline const ::ast::Timer& activationtimer() const;
  inline ::ast::Timer* mutable_activationtimer();
  inline ::ast::Timer* release_activationtimer();
  
  // optional float timeLastFired = 3;
  inline bool has_timelastfired() const;
  inline void clear_timelastfired();
  static const int kTimeLastFiredFieldNumber = 3;
  inline float timelastfired() const;
  inline void set_timelastfired(float value);
  
  // optional float coolDown = 4;
  inline bool has_cooldown() const;
  inline void clear_cooldown();
  static const int kCoolDownFieldNumber = 4;
  inline float cooldown() const;
  inline void set_cooldown(float value);
  
  // optional float damage = 5;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 5;
  inline float damage() const;
  inline void set_damage(float value);
  
  // optional float currentHeat = 6;
  inline bool has_currentheat() const;
  inline void clear_currentheat();
  static const int kCurrentHeatFieldNumber = 6;
  inline float currentheat() const;
  inline void set_currentheat(float value);
  
  // optional int32 shotsFired = 7;
  inline bool has_shotsfired() const;
  inline void clear_shotsfired();
  static const int kShotsFiredFieldNumber = 7;
  inline ::google::protobuf::int32 shotsfired() const;
  inline void set_shotsfired(::google::protobuf::int32 value);
  
  // optional float timeStartedFiring = 8;
  inline bool has_timestartedfiring() const;
  inline void clear_timestartedfiring();
  static const int kTimeStartedFiringFieldNumber = 8;
  inline float timestartedfiring() const;
  inline void set_timestartedfiring(float value);
  
  // optional uint32 shotid = 9;
  inline bool has_shotid() const;
  inline void clear_shotid();
  static const int kShotidFieldNumber = 9;
  inline ::google::protobuf::uint32 shotid() const;
  inline void set_shotid(::google::protobuf::uint32 value);
  
  // optional bool purchased = 10;
  inline bool has_purchased() const;
  inline void clear_purchased();
  static const int kPurchasedFieldNumber = 10;
  inline bool purchased() const;
  inline void set_purchased(bool value);
  
  // optional int32 weaponPrice = 11;
  inline bool has_weaponprice() const;
  inline void clear_weaponprice();
  static const int kWeaponPriceFieldNumber = 11;
  inline ::google::protobuf::int32 weaponprice() const;
  inline void set_weaponprice(::google::protobuf::int32 value);
  
  // optional int32 level = 12;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 12;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional float range = 13;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 13;
  inline float range() const;
  inline void set_range(float value);
  
  // optional float overheatLevel = 14;
  inline bool has_overheatlevel() const;
  inline void clear_overheatlevel();
  static const int kOverheatLevelFieldNumber = 14;
  inline float overheatlevel() const;
  inline void set_overheatlevel(float value);
  
  // optional float heatPerShot = 15;
  inline bool has_heatpershot() const;
  inline void clear_heatpershot();
  static const int kHeatPerShotFieldNumber = 15;
  inline float heatpershot() const;
  inline void set_heatpershot(float value);
  
  // optional float chargeStartTime = 16;
  inline bool has_chargestarttime() const;
  inline void clear_chargestarttime();
  static const int kChargeStartTimeFieldNumber = 16;
  inline float chargestarttime() const;
  inline void set_chargestarttime(float value);
  
  // @@protoc_insertion_point(class_scope:ast.Weapon)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_activationtimer();
  inline void clear_has_activationtimer();
  inline void set_has_timelastfired();
  inline void clear_has_timelastfired();
  inline void set_has_cooldown();
  inline void clear_has_cooldown();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_currentheat();
  inline void clear_has_currentheat();
  inline void set_has_shotsfired();
  inline void clear_has_shotsfired();
  inline void set_has_timestartedfiring();
  inline void clear_has_timestartedfiring();
  inline void set_has_shotid();
  inline void clear_has_shotid();
  inline void set_has_purchased();
  inline void clear_has_purchased();
  inline void set_has_weaponprice();
  inline void clear_has_weaponprice();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_overheatlevel();
  inline void clear_has_overheatlevel();
  inline void set_has_heatpershot();
  inline void clear_has_heatpershot();
  inline void set_has_chargestarttime();
  inline void clear_has_chargestarttime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ast::Timer* activationtimer_;
  ::google::protobuf::uint32 index_;
  float timelastfired_;
  float cooldown_;
  float damage_;
  float currentheat_;
  ::google::protobuf::int32 shotsfired_;
  float timestartedfiring_;
  ::google::protobuf::uint32 shotid_;
  bool purchased_;
  ::google::protobuf::int32 weaponprice_;
  ::google::protobuf::int32 level_;
  float range_;
  float overheatlevel_;
  float heatpershot_;
  float chargestarttime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Weapon* default_instance_;
};
// -------------------------------------------------------------------

class ClientCommand : public ::google::protobuf::Message {
 public:
  ClientCommand();
  virtual ~ClientCommand();
  
  ClientCommand(const ClientCommand& from);
  
  inline ClientCommand& operator=(const ClientCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCommand& default_instance();
  
  void Swap(ClientCommand* other);
  
  // implements Message ----------------------------------------------
  
  ClientCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCommand& from);
  void MergeFrom(const ClientCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 shipID = 1;
  inline bool has_shipid() const;
  inline void clear_shipid();
  static const int kShipIDFieldNumber = 1;
  inline ::google::protobuf::uint32 shipid() const;
  inline void set_shipid(::google::protobuf::uint32 value);
  
  // optional sint32 forwardAcceleration = 2;
  inline bool has_forwardacceleration() const;
  inline void clear_forwardacceleration();
  static const int kForwardAccelerationFieldNumber = 2;
  inline ::google::protobuf::int32 forwardacceleration() const;
  inline void set_forwardacceleration(::google::protobuf::int32 value);
  
  // optional sint32 rightAcceleration = 3;
  inline bool has_rightacceleration() const;
  inline void clear_rightacceleration();
  static const int kRightAccelerationFieldNumber = 3;
  inline ::google::protobuf::int32 rightacceleration() const;
  inline void set_rightacceleration(::google::protobuf::int32 value);
  
  // optional sint32 upAcceleration = 4;
  inline bool has_upacceleration() const;
  inline void clear_upacceleration();
  static const int kUpAccelerationFieldNumber = 4;
  inline ::google::protobuf::int32 upacceleration() const;
  inline void set_upacceleration(::google::protobuf::int32 value);
  
  // optional bool brake = 5;
  inline bool has_brake() const;
  inline void clear_brake();
  static const int kBrakeFieldNumber = 5;
  inline bool brake() const;
  inline void set_brake(bool value);
  
  // optional float yawSpeed = 6;
  inline bool has_yawspeed() const;
  inline void clear_yawspeed();
  static const int kYawSpeedFieldNumber = 6;
  inline float yawspeed() const;
  inline void set_yawspeed(float value);
  
  // optional float rollSpeed = 7;
  inline bool has_rollspeed() const;
  inline void clear_rollspeed();
  static const int kRollSpeedFieldNumber = 7;
  inline float rollspeed() const;
  inline void set_rollspeed(float value);
  
  // optional float pitchSpeed = 8;
  inline bool has_pitchspeed() const;
  inline void clear_pitchspeed();
  static const int kPitchSpeedFieldNumber = 8;
  inline float pitchspeed() const;
  inline void set_pitchspeed(float value);
  
  // optional bool fire = 9;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 9;
  inline bool fire() const;
  inline void set_fire(bool value);
  
  // optional uint32 curWeapon = 10;
  inline bool has_curweapon() const;
  inline void clear_curweapon();
  static const int kCurWeaponFieldNumber = 10;
  inline ::google::protobuf::uint32 curweapon() const;
  inline void set_curweapon(::google::protobuf::uint32 value);
  
  // optional float mouseX = 11;
  inline bool has_mousex() const;
  inline void clear_mousex();
  static const int kMouseXFieldNumber = 11;
  inline float mousex() const;
  inline void set_mousex(float value);
  
  // optional float mouseY = 12;
  inline bool has_mousey() const;
  inline void clear_mousey();
  static const int kMouseYFieldNumber = 12;
  inline float mousey() const;
  inline void set_mousey(float value);
  
  // optional uint32 lastReceivedGameStateId = 13;
  inline bool has_lastreceivedgamestateid() const;
  inline void clear_lastreceivedgamestateid();
  static const int kLastReceivedGameStateIdFieldNumber = 13;
  inline ::google::protobuf::uint32 lastreceivedgamestateid() const;
  inline void set_lastreceivedgamestateid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ast.ClientCommand)
 private:
  inline void set_has_shipid();
  inline void clear_has_shipid();
  inline void set_has_forwardacceleration();
  inline void clear_has_forwardacceleration();
  inline void set_has_rightacceleration();
  inline void clear_has_rightacceleration();
  inline void set_has_upacceleration();
  inline void clear_has_upacceleration();
  inline void set_has_brake();
  inline void clear_has_brake();
  inline void set_has_yawspeed();
  inline void clear_has_yawspeed();
  inline void set_has_rollspeed();
  inline void clear_has_rollspeed();
  inline void set_has_pitchspeed();
  inline void clear_has_pitchspeed();
  inline void set_has_fire();
  inline void clear_has_fire();
  inline void set_has_curweapon();
  inline void clear_has_curweapon();
  inline void set_has_mousex();
  inline void clear_has_mousex();
  inline void set_has_mousey();
  inline void clear_has_mousey();
  inline void set_has_lastreceivedgamestateid();
  inline void clear_has_lastreceivedgamestateid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 shipid_;
  ::google::protobuf::int32 forwardacceleration_;
  ::google::protobuf::int32 rightacceleration_;
  ::google::protobuf::int32 upacceleration_;
  float yawspeed_;
  float rollspeed_;
  bool brake_;
  bool fire_;
  float pitchspeed_;
  ::google::protobuf::uint32 curweapon_;
  float mousex_;
  float mousey_;
  ::google::protobuf::uint32 lastreceivedgamestateid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static ClientCommand* default_instance_;
};
// -------------------------------------------------------------------

class Timer : public ::google::protobuf::Message {
 public:
  Timer();
  virtual ~Timer();
  
  Timer(const Timer& from);
  
  inline Timer& operator=(const Timer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timer& default_instance();
  
  void Swap(Timer* other);
  
  // implements Message ----------------------------------------------
  
  Timer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timer& from);
  void MergeFrom(const Timer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float timeStarted = 1;
  inline bool has_timestarted() const;
  inline void clear_timestarted();
  static const int kTimeStartedFieldNumber = 1;
  inline float timestarted() const;
  inline void set_timestarted(float value);
  
  // optional float countDownTime = 2;
  inline bool has_countdowntime() const;
  inline void clear_countdowntime();
  static const int kCountDownTimeFieldNumber = 2;
  inline float countdowntime() const;
  inline void set_countdowntime(float value);
  
  // optional float timePaused = 3;
  inline bool has_timepaused() const;
  inline void clear_timepaused();
  static const int kTimePausedFieldNumber = 3;
  inline float timepaused() const;
  inline void set_timepaused(float value);
  
  // optional bool isPaused = 4;
  inline bool has_ispaused() const;
  inline void clear_ispaused();
  static const int kIsPausedFieldNumber = 4;
  inline bool ispaused() const;
  inline void set_ispaused(bool value);
  
  // optional bool isRunning = 5;
  inline bool has_isrunning() const;
  inline void clear_isrunning();
  static const int kIsRunningFieldNumber = 5;
  inline bool isrunning() const;
  inline void set_isrunning(bool value);
  
  // @@protoc_insertion_point(class_scope:ast.Timer)
 private:
  inline void set_has_timestarted();
  inline void clear_has_timestarted();
  inline void set_has_countdowntime();
  inline void clear_has_countdowntime();
  inline void set_has_timepaused();
  inline void clear_has_timepaused();
  inline void set_has_ispaused();
  inline void clear_has_ispaused();
  inline void set_has_isrunning();
  inline void clear_has_isrunning();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float timestarted_;
  float countdowntime_;
  float timepaused_;
  bool ispaused_;
  bool isrunning_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Timer* default_instance_;
};
// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message {
 public:
  GameState();
  virtual ~GameState();
  
  GameState(const GameState& from);
  
  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();
  
  void Swap(GameState* other);
  
  // implements Message ----------------------------------------------
  
  GameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ast.Entity entity = 1;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::ast::Entity& entity(int index) const;
  inline ::ast::Entity* mutable_entity(int index);
  inline ::ast::Entity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
      mutable_entity();
  
  // required double gameTime = 2;
  inline bool has_gametime() const;
  inline void clear_gametime();
  static const int kGameTimeFieldNumber = 2;
  inline double gametime() const;
  inline void set_gametime(double value);
  
  // optional uint32 playerShip = 3;
  inline bool has_playership() const;
  inline void clear_playership();
  static const int kPlayerShipFieldNumber = 3;
  inline ::google::protobuf::uint32 playership() const;
  inline void set_playership(::google::protobuf::uint32 value);
  
  // optional .ast.Timer levelTimer = 4;
  inline bool has_leveltimer() const;
  inline void clear_leveltimer();
  static const int kLevelTimerFieldNumber = 4;
  inline const ::ast::Timer& leveltimer() const;
  inline ::ast::Timer* mutable_leveltimer();
  inline ::ast::Timer* release_leveltimer();
  
  // optional int32 curLevel = 5;
  inline bool has_curlevel() const;
  inline void clear_curlevel();
  static const int kCurLevelFieldNumber = 5;
  inline ::google::protobuf::int32 curlevel() const;
  inline void set_curlevel(::google::protobuf::int32 value);
  
  // optional uint32 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ast.GameState)
 private:
  inline void set_has_gametime();
  inline void clear_has_gametime();
  inline void set_has_playership();
  inline void clear_has_playership();
  inline void set_has_leveltimer();
  inline void clear_has_leveltimer();
  inline void set_has_curlevel();
  inline void clear_has_curlevel();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ast::Entity > entity_;
  double gametime_;
  ::ast::Timer* leveltimer_;
  ::google::protobuf::uint32 playership_;
  ::google::protobuf::int32 curlevel_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// -------------------------------------------------------------------

class CollisionMessage : public ::google::protobuf::Message {
 public:
  CollisionMessage();
  virtual ~CollisionMessage();
  
  CollisionMessage(const CollisionMessage& from);
  
  inline CollisionMessage& operator=(const CollisionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionMessage& default_instance();
  
  void Swap(CollisionMessage* other);
  
  // implements Message ----------------------------------------------
  
  CollisionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionMessage& from);
  void MergeFrom(const CollisionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 gamestateid = 1;
  inline bool has_gamestateid() const;
  inline void clear_gamestateid();
  static const int kGamestateidFieldNumber = 1;
  inline ::google::protobuf::uint32 gamestateid() const;
  inline void set_gamestateid(::google::protobuf::uint32 value);
  
  // repeated uint32 collider = 2 [packed = true];
  inline int collider_size() const;
  inline void clear_collider();
  static const int kColliderFieldNumber = 2;
  inline ::google::protobuf::uint32 collider(int index) const;
  inline void set_collider(int index, ::google::protobuf::uint32 value);
  inline void add_collider(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      collider() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_collider();
  
  // repeated uint32 wall_top = 3 [packed = true];
  inline int wall_top_size() const;
  inline void clear_wall_top();
  static const int kWallTopFieldNumber = 3;
  inline ::google::protobuf::uint32 wall_top(int index) const;
  inline void set_wall_top(int index, ::google::protobuf::uint32 value);
  inline void add_wall_top(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_top() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_top();
  
  // repeated uint32 wall_bottom = 4 [packed = true];
  inline int wall_bottom_size() const;
  inline void clear_wall_bottom();
  static const int kWallBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 wall_bottom(int index) const;
  inline void set_wall_bottom(int index, ::google::protobuf::uint32 value);
  inline void add_wall_bottom(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_bottom() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_bottom();
  
  // repeated uint32 wall_left = 5 [packed = true];
  inline int wall_left_size() const;
  inline void clear_wall_left();
  static const int kWallLeftFieldNumber = 5;
  inline ::google::protobuf::uint32 wall_left(int index) const;
  inline void set_wall_left(int index, ::google::protobuf::uint32 value);
  inline void add_wall_left(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_left() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_left();
  
  // repeated uint32 wall_right = 6 [packed = true];
  inline int wall_right_size() const;
  inline void clear_wall_right();
  static const int kWallRightFieldNumber = 6;
  inline ::google::protobuf::uint32 wall_right(int index) const;
  inline void set_wall_right(int index, ::google::protobuf::uint32 value);
  inline void add_wall_right(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_right() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_right();
  
  // repeated uint32 wall_front = 7 [packed = true];
  inline int wall_front_size() const;
  inline void clear_wall_front();
  static const int kWallFrontFieldNumber = 7;
  inline ::google::protobuf::uint32 wall_front(int index) const;
  inline void set_wall_front(int index, ::google::protobuf::uint32 value);
  inline void add_wall_front(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_front() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_front();
  
  // repeated uint32 wall_back = 8 [packed = true];
  inline int wall_back_size() const;
  inline void clear_wall_back();
  static const int kWallBackFieldNumber = 8;
  inline ::google::protobuf::uint32 wall_back(int index) const;
  inline void set_wall_back(int index, ::google::protobuf::uint32 value);
  inline void add_wall_back(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wall_back() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wall_back();
  
  // @@protoc_insertion_point(class_scope:ast.CollisionMessage)
 private:
  inline void set_has_gamestateid();
  inline void clear_has_gamestateid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > collider_;
  mutable int _collider_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_top_;
  mutable int _wall_top_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_bottom_;
  mutable int _wall_bottom_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_left_;
  mutable int _wall_left_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_right_;
  mutable int _wall_right_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_front_;
  mutable int _wall_front_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wall_back_;
  mutable int _wall_back_cached_byte_size_;
  ::google::protobuf::uint32 gamestateid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static CollisionMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::Message {
 public:
  ChatMessage();
  virtual ~ChatMessage();
  
  ChatMessage(const ChatMessage& from);
  
  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();
  
  void Swap(ChatMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 sourceid = 1;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  static const int kSourceidFieldNumber = 1;
  inline ::google::protobuf::uint32 sourceid() const;
  inline void set_sourceid(::google::protobuf::uint32 value);
  
  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:ast.ChatMessage)
 private:
  inline void set_has_sourceid();
  inline void clear_has_sourceid();
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  ::google::protobuf::uint32 sourceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class CreateEntityMessage : public ::google::protobuf::Message {
 public:
  CreateEntityMessage();
  virtual ~CreateEntityMessage();
  
  CreateEntityMessage(const CreateEntityMessage& from);
  
  inline CreateEntityMessage& operator=(const CreateEntityMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateEntityMessage& default_instance();
  
  void Swap(CreateEntityMessage* other);
  
  // implements Message ----------------------------------------------
  
  CreateEntityMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateEntityMessage& from);
  void MergeFrom(const CreateEntityMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 createEntityMessageid = 1;
  inline bool has_createentitymessageid() const;
  inline void clear_createentitymessageid();
  static const int kCreateEntityMessageidFieldNumber = 1;
  inline ::google::protobuf::uint32 createentitymessageid() const;
  inline void set_createentitymessageid(::google::protobuf::uint32 value);
  
  // repeated .ast.Entity entity = 2;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::ast::Entity& entity(int index) const;
  inline ::ast::Entity* mutable_entity(int index);
  inline ::ast::Entity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
      mutable_entity();
  
  // @@protoc_insertion_point(class_scope:ast.CreateEntityMessage)
 private:
  inline void set_has_createentitymessageid();
  inline void clear_has_createentitymessageid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ast::Entity > entity_;
  ::google::protobuf::uint32 createentitymessageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static CreateEntityMessage* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();
  
  Frame(const Frame& from);
  
  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();
  
  void Swap(Frame* other);
  
  // implements Message ----------------------------------------------
  
  Frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ast.CollisionMessage collision_message = 1;
  inline int collision_message_size() const;
  inline void clear_collision_message();
  static const int kCollisionMessageFieldNumber = 1;
  inline const ::ast::CollisionMessage& collision_message(int index) const;
  inline ::ast::CollisionMessage* mutable_collision_message(int index);
  inline ::ast::CollisionMessage* add_collision_message();
  inline const ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >&
      collision_message() const;
  inline ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >*
      mutable_collision_message();
  
  // optional .ast.GameState gameState = 9;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 9;
  inline const ::ast::GameState& gamestate() const;
  inline ::ast::GameState* mutable_gamestate();
  inline ::ast::GameState* release_gamestate();
  
  // optional uint32 shipid = 10;
  inline bool has_shipid() const;
  inline void clear_shipid();
  static const int kShipidFieldNumber = 10;
  inline ::google::protobuf::uint32 shipid() const;
  inline void set_shipid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ast.Frame)
 private:
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_shipid();
  inline void clear_has_shipid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage > collision_message_;
  ::ast::GameState* gamestate_;
  ::google::protobuf::uint32 shipid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Network_2fgamestate_2eproto();
  friend void protobuf_AssignDesc_Network_2fgamestate_2eproto();
  friend void protobuf_ShutdownFile_Network_2fgamestate_2eproto();
  
  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector

// optional float x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector::x() const {
  return x_;
}
inline void Vector::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector::y() const {
  return y_;
}
inline void Vector::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector::z() const {
  return z_;
}
inline void Vector::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Entity

// optional uint32 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Entity::id() const {
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 type = 2;
inline bool Entity::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Entity::type() const {
  return type_;
}
inline void Entity::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .ast.Vector position = 3;
inline bool Entity::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_position() {
  if (position_ != NULL) position_->::ast::Vector::Clear();
  clear_has_position();
}
inline const ::ast::Vector& Entity::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::ast::Vector* Entity::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::ast::Vector;
  return position_;
}
inline ::ast::Vector* Entity::release_position() {
  clear_has_position();
  ::ast::Vector* temp = position_;
  position_ = NULL;
  return temp;
}

// optional .ast.Vector velocity = 4;
inline bool Entity::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::ast::Vector::Clear();
  clear_has_velocity();
}
inline const ::ast::Vector& Entity::velocity() const {
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::ast::Vector* Entity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::ast::Vector;
  return velocity_;
}
inline ::ast::Vector* Entity::release_velocity() {
  clear_has_velocity();
  ::ast::Vector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}

// repeated .ast.Weapon weapon = 5;
inline int Entity::weapon_size() const {
  return weapon_.size();
}
inline void Entity::clear_weapon() {
  weapon_.Clear();
}
inline const ::ast::Weapon& Entity::weapon(int index) const {
  return weapon_.Get(index);
}
inline ::ast::Weapon* Entity::mutable_weapon(int index) {
  return weapon_.Mutable(index);
}
inline ::ast::Weapon* Entity::add_weapon() {
  return weapon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::Weapon >&
Entity::weapon() const {
  return weapon_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::Weapon >*
Entity::mutable_weapon() {
  return &weapon_;
}

// optional .ast.Vector targetup = 6;
inline bool Entity::has_targetup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_targetup() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_targetup() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_targetup() {
  if (targetup_ != NULL) targetup_->::ast::Vector::Clear();
  clear_has_targetup();
}
inline const ::ast::Vector& Entity::targetup() const {
  return targetup_ != NULL ? *targetup_ : *default_instance_->targetup_;
}
inline ::ast::Vector* Entity::mutable_targetup() {
  set_has_targetup();
  if (targetup_ == NULL) targetup_ = new ::ast::Vector;
  return targetup_;
}
inline ::ast::Vector* Entity::release_targetup() {
  clear_has_targetup();
  ::ast::Vector* temp = targetup_;
  targetup_ = NULL;
  return temp;
}

// optional .ast.Vector targetright = 7;
inline bool Entity::has_targetright() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_targetright() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_targetright() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_targetright() {
  if (targetright_ != NULL) targetright_->::ast::Vector::Clear();
  clear_has_targetright();
}
inline const ::ast::Vector& Entity::targetright() const {
  return targetright_ != NULL ? *targetright_ : *default_instance_->targetright_;
}
inline ::ast::Vector* Entity::mutable_targetright() {
  set_has_targetright();
  if (targetright_ == NULL) targetright_ = new ::ast::Vector;
  return targetright_;
}
inline ::ast::Vector* Entity::release_targetright() {
  clear_has_targetright();
  ::ast::Vector* temp = targetright_;
  targetright_ = NULL;
  return temp;
}

// optional .ast.Vector targetforward = 8;
inline bool Entity::has_targetforward() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_targetforward() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_targetforward() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_targetforward() {
  if (targetforward_ != NULL) targetforward_->::ast::Vector::Clear();
  clear_has_targetforward();
}
inline const ::ast::Vector& Entity::targetforward() const {
  return targetforward_ != NULL ? *targetforward_ : *default_instance_->targetforward_;
}
inline ::ast::Vector* Entity::mutable_targetforward() {
  set_has_targetforward();
  if (targetforward_ == NULL) targetforward_ = new ::ast::Vector;
  return targetforward_;
}
inline ::ast::Vector* Entity::release_targetforward() {
  clear_has_targetforward();
  ::ast::Vector* temp = targetforward_;
  targetforward_ = NULL;
  return temp;
}

// optional float radius = 19;
inline bool Entity::has_radius() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_radius() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_radius() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float Entity::radius() const {
  return radius_;
}
inline void Entity::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional .ast.Vector axis = 21;
inline bool Entity::has_axis() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_axis() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_axis() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_axis() {
  if (axis_ != NULL) axis_->::ast::Vector::Clear();
  clear_has_axis();
}
inline const ::ast::Vector& Entity::axis() const {
  return axis_ != NULL ? *axis_ : *default_instance_->axis_;
}
inline ::ast::Vector* Entity::mutable_axis() {
  set_has_axis();
  if (axis_ == NULL) axis_ = new ::ast::Vector;
  return axis_;
}
inline ::ast::Vector* Entity::release_axis() {
  clear_has_axis();
  ::ast::Vector* temp = axis_;
  axis_ = NULL;
  return temp;
}

// optional float angle = 25;
inline bool Entity::has_angle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Entity::set_has_angle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Entity::clear_has_angle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Entity::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Entity::angle() const {
  return angle_;
}
inline void Entity::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float rotationSpeed = 26;
inline bool Entity::has_rotationspeed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Entity::set_has_rotationspeed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Entity::clear_has_rotationspeed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Entity::clear_rotationspeed() {
  rotationspeed_ = 0;
  clear_has_rotationspeed();
}
inline float Entity::rotationspeed() const {
  return rotationspeed_;
}
inline void Entity::set_rotationspeed(float value) {
  set_has_rotationspeed();
  rotationspeed_ = value;
}

// optional float targetYawSpeed = 27;
inline bool Entity::has_targetyawspeed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Entity::set_has_targetyawspeed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Entity::clear_has_targetyawspeed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Entity::clear_targetyawspeed() {
  targetyawspeed_ = 0;
  clear_has_targetyawspeed();
}
inline float Entity::targetyawspeed() const {
  return targetyawspeed_;
}
inline void Entity::set_targetyawspeed(float value) {
  set_has_targetyawspeed();
  targetyawspeed_ = value;
}

// optional float targetPitchSpeed = 28;
inline bool Entity::has_targetpitchspeed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Entity::set_has_targetpitchspeed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Entity::clear_has_targetpitchspeed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Entity::clear_targetpitchspeed() {
  targetpitchspeed_ = 0;
  clear_has_targetpitchspeed();
}
inline float Entity::targetpitchspeed() const {
  return targetpitchspeed_;
}
inline void Entity::set_targetpitchspeed(float value) {
  set_has_targetpitchspeed();
  targetpitchspeed_ = value;
}

// optional float targetRollSpeed = 29;
inline bool Entity::has_targetrollspeed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Entity::set_has_targetrollspeed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Entity::clear_has_targetrollspeed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Entity::clear_targetrollspeed() {
  targetrollspeed_ = 0;
  clear_has_targetrollspeed();
}
inline float Entity::targetrollspeed() const {
  return targetrollspeed_;
}
inline void Entity::set_targetrollspeed(float value) {
  set_has_targetrollspeed();
  targetrollspeed_ = value;
}

// optional float health = 30;
inline bool Entity::has_health() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Entity::set_has_health() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Entity::clear_has_health() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Entity::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float Entity::health() const {
  return health_;
}
inline void Entity::set_health(float value) {
  set_has_health();
  health_ = value;
}

// optional float healthMax = 31;
inline bool Entity::has_healthmax() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Entity::set_has_healthmax() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Entity::clear_has_healthmax() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Entity::clear_healthmax() {
  healthmax_ = 0;
  clear_has_healthmax();
}
inline float Entity::healthmax() const {
  return healthmax_;
}
inline void Entity::set_healthmax(float value) {
  set_has_healthmax();
  healthmax_ = value;
}

// optional int32 engineLevel = 32;
inline bool Entity::has_enginelevel() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Entity::set_has_enginelevel() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Entity::clear_has_enginelevel() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Entity::clear_enginelevel() {
  enginelevel_ = 0;
  clear_has_enginelevel();
}
inline ::google::protobuf::int32 Entity::enginelevel() const {
  return enginelevel_;
}
inline void Entity::set_enginelevel(::google::protobuf::int32 value) {
  set_has_enginelevel();
  enginelevel_ = value;
}

// optional int32 regenHealthLevel = 33;
inline bool Entity::has_regenhealthlevel() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Entity::set_has_regenhealthlevel() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Entity::clear_has_regenhealthlevel() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Entity::clear_regenhealthlevel() {
  regenhealthlevel_ = 0;
  clear_has_regenhealthlevel();
}
inline ::google::protobuf::int32 Entity::regenhealthlevel() const {
  return regenhealthlevel_;
}
inline void Entity::set_regenhealthlevel(::google::protobuf::int32 value) {
  set_has_regenhealthlevel();
  regenhealthlevel_ = value;
}

// optional int32 bankLevel = 34;
inline bool Entity::has_banklevel() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Entity::set_has_banklevel() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Entity::clear_has_banklevel() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Entity::clear_banklevel() {
  banklevel_ = 0;
  clear_has_banklevel();
}
inline ::google::protobuf::int32 Entity::banklevel() const {
  return banklevel_;
}
inline void Entity::set_banklevel(::google::protobuf::int32 value) {
  set_has_banklevel();
  banklevel_ = value;
}

// optional float color1 = 35;
inline bool Entity::has_color1() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Entity::set_has_color1() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Entity::clear_has_color1() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Entity::clear_color1() {
  color1_ = 0;
  clear_has_color1();
}
inline float Entity::color1() const {
  return color1_;
}
inline void Entity::set_color1(float value) {
  set_has_color1();
  color1_ = value;
}

// optional float color2 = 36;
inline bool Entity::has_color2() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Entity::set_has_color2() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Entity::clear_has_color2() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Entity::clear_color2() {
  color2_ = 0;
  clear_has_color2();
}
inline float Entity::color2() const {
  return color2_;
}
inline void Entity::set_color2(float value) {
  set_has_color2();
  color2_ = value;
}

// optional .ast.Vector shotDirection = 37;
inline bool Entity::has_shotdirection() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Entity::set_has_shotdirection() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Entity::clear_has_shotdirection() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Entity::clear_shotdirection() {
  if (shotdirection_ != NULL) shotdirection_->::ast::Vector::Clear();
  clear_has_shotdirection();
}
inline const ::ast::Vector& Entity::shotdirection() const {
  return shotdirection_ != NULL ? *shotdirection_ : *default_instance_->shotdirection_;
}
inline ::ast::Vector* Entity::mutable_shotdirection() {
  set_has_shotdirection();
  if (shotdirection_ == NULL) shotdirection_ = new ::ast::Vector;
  return shotdirection_;
}
inline ::ast::Vector* Entity::release_shotdirection() {
  clear_has_shotdirection();
  ::ast::Vector* temp = shotdirection_;
  shotdirection_ = NULL;
  return temp;
}

// optional bool isFiring = 38;
inline bool Entity::has_isfiring() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Entity::set_has_isfiring() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Entity::clear_has_isfiring() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Entity::clear_isfiring() {
  isfiring_ = false;
  clear_has_isfiring();
}
inline bool Entity::isfiring() const {
  return isfiring_;
}
inline void Entity::set_isfiring(bool value) {
  set_has_isfiring();
  isfiring_ = value;
}

// optional int32 currentWeapon = 39;
inline bool Entity::has_currentweapon() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Entity::set_has_currentweapon() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Entity::clear_has_currentweapon() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Entity::clear_currentweapon() {
  currentweapon_ = 0;
  clear_has_currentweapon();
}
inline ::google::protobuf::int32 Entity::currentweapon() const {
  return currentweapon_;
}
inline void Entity::set_currentweapon(::google::protobuf::int32 value) {
  set_has_currentweapon();
  currentweapon_ = value;
}

// optional float isBarrelRollingLeft = 40;
inline bool Entity::has_isbarrelrollingleft() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Entity::set_has_isbarrelrollingleft() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Entity::clear_has_isbarrelrollingleft() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Entity::clear_isbarrelrollingleft() {
  isbarrelrollingleft_ = 0;
  clear_has_isbarrelrollingleft();
}
inline float Entity::isbarrelrollingleft() const {
  return isbarrelrollingleft_;
}
inline void Entity::set_isbarrelrollingleft(float value) {
  set_has_isbarrelrollingleft();
  isbarrelrollingleft_ = value;
}

// optional float isBarrelRollingRight = 41;
inline bool Entity::has_isbarrelrollingright() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Entity::set_has_isbarrelrollingright() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Entity::clear_has_isbarrelrollingright() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Entity::clear_isbarrelrollingright() {
  isbarrelrollingright_ = 0;
  clear_has_isbarrelrollingright();
}
inline float Entity::isbarrelrollingright() const {
  return isbarrelrollingright_;
}
inline void Entity::set_isbarrelrollingright(float value) {
  set_has_isbarrelrollingright();
  isbarrelrollingright_ = value;
}

// optional float curForwardAccel = 42;
inline bool Entity::has_curforwardaccel() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Entity::set_has_curforwardaccel() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Entity::clear_has_curforwardaccel() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Entity::clear_curforwardaccel() {
  curforwardaccel_ = 0;
  clear_has_curforwardaccel();
}
inline float Entity::curforwardaccel() const {
  return curforwardaccel_;
}
inline void Entity::set_curforwardaccel(float value) {
  set_has_curforwardaccel();
  curforwardaccel_ = value;
}

// optional float curRightAccel = 43;
inline bool Entity::has_currightaccel() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Entity::set_has_currightaccel() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Entity::clear_has_currightaccel() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Entity::clear_currightaccel() {
  currightaccel_ = 0;
  clear_has_currightaccel();
}
inline float Entity::currightaccel() const {
  return currightaccel_;
}
inline void Entity::set_currightaccel(float value) {
  set_has_currightaccel();
  currightaccel_ = value;
}

// optional float curUpAccel = 44;
inline bool Entity::has_curupaccel() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Entity::set_has_curupaccel() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Entity::clear_has_curupaccel() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Entity::clear_curupaccel() {
  curupaccel_ = 0;
  clear_has_curupaccel();
}
inline float Entity::curupaccel() const {
  return curupaccel_;
}
inline void Entity::set_curupaccel(float value) {
  set_has_curupaccel();
  curupaccel_ = value;
}

// optional bool isBraking = 45;
inline bool Entity::has_isbraking() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Entity::set_has_isbraking() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Entity::clear_has_isbraking() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Entity::clear_isbraking() {
  isbraking_ = false;
  clear_has_isbraking();
}
inline bool Entity::isbraking() const {
  return isbraking_;
}
inline void Entity::set_isbraking(bool value) {
  set_has_isbraking();
  isbraking_ = value;
}

// optional float bankPeriod = 46;
inline bool Entity::has_bankperiod() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Entity::set_has_bankperiod() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Entity::clear_has_bankperiod() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Entity::clear_bankperiod() {
  bankperiod_ = 0;
  clear_has_bankperiod();
}
inline float Entity::bankperiod() const {
  return bankperiod_;
}
inline void Entity::set_bankperiod(float value) {
  set_has_bankperiod();
  bankperiod_ = value;
}

// optional bool flyingAIEnabled = 47;
inline bool Entity::has_flyingaienabled() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Entity::set_has_flyingaienabled() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Entity::clear_has_flyingaienabled() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Entity::clear_flyingaienabled() {
  flyingaienabled_ = false;
  clear_has_flyingaienabled();
}
inline bool Entity::flyingaienabled() const {
  return flyingaienabled_;
}
inline void Entity::set_flyingaienabled(bool value) {
  set_has_flyingaienabled();
  flyingaienabled_ = value;
}

// optional bool shootingAIEnabled = 48;
inline bool Entity::has_shootingaienabled() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Entity::set_has_shootingaienabled() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Entity::clear_has_shootingaienabled() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Entity::clear_shootingaienabled() {
  shootingaienabled_ = false;
  clear_has_shootingaienabled();
}
inline bool Entity::shootingaienabled() const {
  return shootingaienabled_;
}
inline void Entity::set_shootingaienabled(bool value) {
  set_has_shootingaienabled();
  shootingaienabled_ = value;
}

// optional .ast.Timer bankTimer = 49;
inline bool Entity::has_banktimer() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Entity::set_has_banktimer() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Entity::clear_has_banktimer() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Entity::clear_banktimer() {
  if (banktimer_ != NULL) banktimer_->::ast::Timer::Clear();
  clear_has_banktimer();
}
inline const ::ast::Timer& Entity::banktimer() const {
  return banktimer_ != NULL ? *banktimer_ : *default_instance_->banktimer_;
}
inline ::ast::Timer* Entity::mutable_banktimer() {
  set_has_banktimer();
  if (banktimer_ == NULL) banktimer_ = new ::ast::Timer;
  return banktimer_;
}
inline ::ast::Timer* Entity::release_banktimer() {
  clear_has_banktimer();
  ::ast::Timer* temp = banktimer_;
  banktimer_ = NULL;
  return temp;
}

// optional .ast.Timer aliveTimer = 50;
inline bool Entity::has_alivetimer() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Entity::set_has_alivetimer() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Entity::clear_has_alivetimer() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Entity::clear_alivetimer() {
  if (alivetimer_ != NULL) alivetimer_->::ast::Timer::Clear();
  clear_has_alivetimer();
}
inline const ::ast::Timer& Entity::alivetimer() const {
  return alivetimer_ != NULL ? *alivetimer_ : *default_instance_->alivetimer_;
}
inline ::ast::Timer* Entity::mutable_alivetimer() {
  set_has_alivetimer();
  if (alivetimer_ == NULL) alivetimer_ = new ::ast::Timer;
  return alivetimer_;
}
inline ::ast::Timer* Entity::release_alivetimer() {
  clear_has_alivetimer();
  ::ast::Timer* temp = alivetimer_;
  alivetimer_ = NULL;
  return temp;
}

// optional .ast.Timer respawnTimer = 51;
inline bool Entity::has_respawntimer() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Entity::set_has_respawntimer() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Entity::clear_has_respawntimer() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Entity::clear_respawntimer() {
  if (respawntimer_ != NULL) respawntimer_->::ast::Timer::Clear();
  clear_has_respawntimer();
}
inline const ::ast::Timer& Entity::respawntimer() const {
  return respawntimer_ != NULL ? *respawntimer_ : *default_instance_->respawntimer_;
}
inline ::ast::Timer* Entity::mutable_respawntimer() {
  set_has_respawntimer();
  if (respawntimer_ == NULL) respawntimer_ = new ::ast::Timer;
  return respawntimer_;
}
inline ::ast::Timer* Entity::release_respawntimer() {
  clear_has_respawntimer();
  ::ast::Timer* temp = respawntimer_;
  respawntimer_ = NULL;
  return temp;
}

// optional float timeLeftToRespawn = 52;
inline bool Entity::has_timelefttorespawn() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Entity::set_has_timelefttorespawn() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Entity::clear_has_timelefttorespawn() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Entity::clear_timelefttorespawn() {
  timelefttorespawn_ = 0;
  clear_has_timelefttorespawn();
}
inline float Entity::timelefttorespawn() const {
  return timelefttorespawn_;
}
inline void Entity::set_timelefttorespawn(float value) {
  set_has_timelefttorespawn();
  timelefttorespawn_ = value;
}

// optional int32 score = 53;
inline bool Entity::has_score() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Entity::set_has_score() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Entity::clear_has_score() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Entity::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 Entity::score() const {
  return score_;
}
inline void Entity::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 kills = 54;
inline bool Entity::has_kills() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Entity::set_has_kills() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Entity::clear_has_kills() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Entity::clear_kills() {
  kills_ = 0;
  clear_has_kills();
}
inline ::google::protobuf::int32 Entity::kills() const {
  return kills_;
}
inline void Entity::set_kills(::google::protobuf::int32 value) {
  set_has_kills();
  kills_ = value;
}

// optional int32 deaths = 55;
inline bool Entity::has_deaths() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Entity::set_has_deaths() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Entity::clear_has_deaths() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Entity::clear_deaths() {
  deaths_ = 0;
  clear_has_deaths();
}
inline ::google::protobuf::int32 Entity::deaths() const {
  return deaths_;
}
inline void Entity::set_deaths(::google::protobuf::int32 value) {
  set_has_deaths();
  deaths_ = value;
}

// optional int32 lives = 56;
inline bool Entity::has_lives() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Entity::set_has_lives() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Entity::clear_has_lives() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Entity::clear_lives() {
  lives_ = 0;
  clear_has_lives();
}
inline ::google::protobuf::int32 Entity::lives() const {
  return lives_;
}
inline void Entity::set_lives(::google::protobuf::int32 value) {
  set_has_lives();
  lives_ = value;
}

// optional int32 bankedShards = 57;
inline bool Entity::has_bankedshards() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Entity::set_has_bankedshards() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Entity::clear_has_bankedshards() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Entity::clear_bankedshards() {
  bankedshards_ = 0;
  clear_has_bankedshards();
}
inline ::google::protobuf::int32 Entity::bankedshards() const {
  return bankedshards_;
}
inline void Entity::set_bankedshards(::google::protobuf::int32 value) {
  set_has_bankedshards();
  bankedshards_ = value;
}

// optional int32 unbankedShards = 58;
inline bool Entity::has_unbankedshards() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Entity::set_has_unbankedshards() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Entity::clear_has_unbankedshards() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Entity::clear_unbankedshards() {
  unbankedshards_ = 0;
  clear_has_unbankedshards();
}
inline ::google::protobuf::int32 Entity::unbankedshards() const {
  return unbankedshards_;
}
inline void Entity::set_unbankedshards(::google::protobuf::int32 value) {
  set_has_unbankedshards();
  unbankedshards_ = value;
}

// optional int32 totalBankedShards = 59;
inline bool Entity::has_totalbankedshards() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Entity::set_has_totalbankedshards() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Entity::clear_has_totalbankedshards() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Entity::clear_totalbankedshards() {
  totalbankedshards_ = 0;
  clear_has_totalbankedshards();
}
inline ::google::protobuf::int32 Entity::totalbankedshards() const {
  return totalbankedshards_;
}
inline void Entity::set_totalbankedshards(::google::protobuf::int32 value) {
  set_has_totalbankedshards();
  totalbankedshards_ = value;
}

// optional uint32 ownerid = 60;
inline bool Entity::has_ownerid() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Entity::set_has_ownerid() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Entity::clear_has_ownerid() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Entity::clear_ownerid() {
  ownerid_ = 0u;
  clear_has_ownerid();
}
inline ::google::protobuf::uint32 Entity::ownerid() const {
  return ownerid_;
}
inline void Entity::set_ownerid(::google::protobuf::uint32 value) {
  set_has_ownerid();
  ownerid_ = value;
}

// optional float lifetime = 61;
inline bool Entity::has_lifetime() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Entity::set_has_lifetime() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Entity::clear_has_lifetime() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Entity::clear_lifetime() {
  lifetime_ = 0;
  clear_has_lifetime();
}
inline float Entity::lifetime() const {
  return lifetime_;
}
inline void Entity::set_lifetime(float value) {
  set_has_lifetime();
  lifetime_ = value;
}

// optional float timeFired = 62;
inline bool Entity::has_timefired() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Entity::set_has_timefired() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Entity::clear_has_timefired() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Entity::clear_timefired() {
  timefired_ = 0;
  clear_has_timefired();
}
inline float Entity::timefired() const {
  return timefired_;
}
inline void Entity::set_timefired(float value) {
  set_has_timefired();
  timefired_ = value;
}

// optional int32 weaponIndex = 63;
inline bool Entity::has_weaponindex() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Entity::set_has_weaponindex() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Entity::clear_has_weaponindex() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Entity::clear_weaponindex() {
  weaponindex_ = 0;
  clear_has_weaponindex();
}
inline ::google::protobuf::int32 Entity::weaponindex() const {
  return weaponindex_;
}
inline void Entity::set_weaponindex(::google::protobuf::int32 value) {
  set_has_weaponindex();
  weaponindex_ = value;
}

// optional float damage = 64;
inline bool Entity::has_damage() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Entity::set_has_damage() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Entity::clear_has_damage() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void Entity::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline float Entity::damage() const {
  return damage_;
}
inline void Entity::set_damage(float value) {
  set_has_damage();
  damage_ = value;
}

// optional float chargeTime = 65;
inline bool Entity::has_chargetime() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Entity::set_has_chargetime() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Entity::clear_has_chargetime() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Entity::clear_chargetime() {
  chargetime_ = 0;
  clear_has_chargetime();
}
inline float Entity::chargetime() const {
  return chargetime_;
}
inline void Entity::set_chargetime(float value) {
  set_has_chargetime();
  chargetime_ = value;
}

// optional float damagePerSecond = 66;
inline bool Entity::has_damagepersecond() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Entity::set_has_damagepersecond() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Entity::clear_has_damagepersecond() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Entity::clear_damagepersecond() {
  damagepersecond_ = 0;
  clear_has_damagepersecond();
}
inline float Entity::damagepersecond() const {
  return damagepersecond_;
}
inline void Entity::set_damagepersecond(float value) {
  set_has_damagepersecond();
  damagepersecond_ = value;
}

// optional float timeSinceExploded = 67;
inline bool Entity::has_timesinceexploded() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Entity::set_has_timesinceexploded() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Entity::clear_has_timesinceexploded() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Entity::clear_timesinceexploded() {
  timesinceexploded_ = 0;
  clear_has_timesinceexploded();
}
inline float Entity::timesinceexploded() const {
  return timesinceexploded_;
}
inline void Entity::set_timesinceexploded(float value) {
  set_has_timesinceexploded();
  timesinceexploded_ = value;
}

// optional bool energyHit = 68;
inline bool Entity::has_energyhit() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Entity::set_has_energyhit() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Entity::clear_has_energyhit() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Entity::clear_energyhit() {
  energyhit_ = false;
  clear_has_energyhit();
}
inline bool Entity::energyhit() const {
  return energyhit_;
}
inline void Entity::set_energyhit(bool value) {
  set_has_energyhit();
  energyhit_ = value;
}

// optional float timeLastHitByEnergy = 69;
inline bool Entity::has_timelasthitbyenergy() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Entity::set_has_timelasthitbyenergy() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Entity::clear_has_timelasthitbyenergy() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Entity::clear_timelasthitbyenergy() {
  timelasthitbyenergy_ = 0;
  clear_has_timelasthitbyenergy();
}
inline float Entity::timelasthitbyenergy() const {
  return timelasthitbyenergy_;
}
inline void Entity::set_timelasthitbyenergy(float value) {
  set_has_timelasthitbyenergy();
  timelasthitbyenergy_ = value;
}

// optional bool shouldRemove = 70;
inline bool Entity::has_shouldremove() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Entity::set_has_shouldremove() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Entity::clear_has_shouldremove() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Entity::clear_shouldremove() {
  shouldremove_ = false;
  clear_has_shouldremove();
}
inline bool Entity::shouldremove() const {
  return shouldremove_;
}
inline void Entity::set_shouldremove(bool value) {
  set_has_shouldremove();
  shouldremove_ = value;
}

// optional float length = 71;
inline bool Entity::has_length() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Entity::set_has_length() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Entity::clear_has_length() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Entity::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float Entity::length() const {
  return length_;
}
inline void Entity::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional int32 releasedShards = 72;
inline bool Entity::has_releasedshards() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Entity::set_has_releasedshards() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Entity::clear_has_releasedshards() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Entity::clear_releasedshards() {
  releasedshards_ = 0;
  clear_has_releasedshards();
}
inline ::google::protobuf::int32 Entity::releasedshards() const {
  return releasedshards_;
}
inline void Entity::set_releasedshards(::google::protobuf::int32 value) {
  set_has_releasedshards();
  releasedshards_ = value;
}

// optional uint32 shardType = 73;
inline bool Entity::has_shardtype() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Entity::set_has_shardtype() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Entity::clear_has_shardtype() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Entity::clear_shardtype() {
  shardtype_ = 0u;
  clear_has_shardtype();
}
inline ::google::protobuf::uint32 Entity::shardtype() const {
  return shardtype_;
}
inline void Entity::set_shardtype(::google::protobuf::uint32 value) {
  set_has_shardtype();
  shardtype_ = value;
}

// optional uint32 weapNum = 74;
inline bool Entity::has_weapnum() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Entity::set_has_weapnum() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Entity::clear_has_weapnum() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Entity::clear_weapnum() {
  weapnum_ = 0u;
  clear_has_weapnum();
}
inline ::google::protobuf::uint32 Entity::weapnum() const {
  return weapnum_;
}
inline void Entity::set_weapnum(::google::protobuf::uint32 value) {
  set_has_weapnum();
  weapnum_ = value;
}

// optional .ast.Vector up = 75;
inline bool Entity::has_up() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Entity::set_has_up() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Entity::clear_has_up() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Entity::clear_up() {
  if (up_ != NULL) up_->::ast::Vector::Clear();
  clear_has_up();
}
inline const ::ast::Vector& Entity::up() const {
  return up_ != NULL ? *up_ : *default_instance_->up_;
}
inline ::ast::Vector* Entity::mutable_up() {
  set_has_up();
  if (up_ == NULL) up_ = new ::ast::Vector;
  return up_;
}
inline ::ast::Vector* Entity::release_up() {
  clear_has_up();
  ::ast::Vector* temp = up_;
  up_ = NULL;
  return temp;
}

// optional .ast.Vector right = 76;
inline bool Entity::has_right() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Entity::set_has_right() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Entity::clear_has_right() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Entity::clear_right() {
  if (right_ != NULL) right_->::ast::Vector::Clear();
  clear_has_right();
}
inline const ::ast::Vector& Entity::right() const {
  return right_ != NULL ? *right_ : *default_instance_->right_;
}
inline ::ast::Vector* Entity::mutable_right() {
  set_has_right();
  if (right_ == NULL) right_ = new ::ast::Vector;
  return right_;
}
inline ::ast::Vector* Entity::release_right() {
  clear_has_right();
  ::ast::Vector* temp = right_;
  right_ = NULL;
  return temp;
}

// optional .ast.Vector forward = 77;
inline bool Entity::has_forward() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Entity::set_has_forward() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Entity::clear_has_forward() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Entity::clear_forward() {
  if (forward_ != NULL) forward_->::ast::Vector::Clear();
  clear_has_forward();
}
inline const ::ast::Vector& Entity::forward() const {
  return forward_ != NULL ? *forward_ : *default_instance_->forward_;
}
inline ::ast::Vector* Entity::mutable_forward() {
  set_has_forward();
  if (forward_ == NULL) forward_ = new ::ast::Vector;
  return forward_;
}
inline ::ast::Vector* Entity::release_forward() {
  clear_has_forward();
  ::ast::Vector* temp = forward_;
  forward_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Weapon

// required uint32 index = 1;
inline bool Weapon::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Weapon::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Weapon::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Weapon::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Weapon::index() const {
  return index_;
}
inline void Weapon::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .ast.Timer activationTimer = 2;
inline bool Weapon::has_activationtimer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Weapon::set_has_activationtimer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Weapon::clear_has_activationtimer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Weapon::clear_activationtimer() {
  if (activationtimer_ != NULL) activationtimer_->::ast::Timer::Clear();
  clear_has_activationtimer();
}
inline const ::ast::Timer& Weapon::activationtimer() const {
  return activationtimer_ != NULL ? *activationtimer_ : *default_instance_->activationtimer_;
}
inline ::ast::Timer* Weapon::mutable_activationtimer() {
  set_has_activationtimer();
  if (activationtimer_ == NULL) activationtimer_ = new ::ast::Timer;
  return activationtimer_;
}
inline ::ast::Timer* Weapon::release_activationtimer() {
  clear_has_activationtimer();
  ::ast::Timer* temp = activationtimer_;
  activationtimer_ = NULL;
  return temp;
}

// optional float timeLastFired = 3;
inline bool Weapon::has_timelastfired() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Weapon::set_has_timelastfired() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Weapon::clear_has_timelastfired() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Weapon::clear_timelastfired() {
  timelastfired_ = 0;
  clear_has_timelastfired();
}
inline float Weapon::timelastfired() const {
  return timelastfired_;
}
inline void Weapon::set_timelastfired(float value) {
  set_has_timelastfired();
  timelastfired_ = value;
}

// optional float coolDown = 4;
inline bool Weapon::has_cooldown() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Weapon::set_has_cooldown() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Weapon::clear_has_cooldown() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Weapon::clear_cooldown() {
  cooldown_ = 0;
  clear_has_cooldown();
}
inline float Weapon::cooldown() const {
  return cooldown_;
}
inline void Weapon::set_cooldown(float value) {
  set_has_cooldown();
  cooldown_ = value;
}

// optional float damage = 5;
inline bool Weapon::has_damage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Weapon::set_has_damage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Weapon::clear_has_damage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Weapon::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline float Weapon::damage() const {
  return damage_;
}
inline void Weapon::set_damage(float value) {
  set_has_damage();
  damage_ = value;
}

// optional float currentHeat = 6;
inline bool Weapon::has_currentheat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Weapon::set_has_currentheat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Weapon::clear_has_currentheat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Weapon::clear_currentheat() {
  currentheat_ = 0;
  clear_has_currentheat();
}
inline float Weapon::currentheat() const {
  return currentheat_;
}
inline void Weapon::set_currentheat(float value) {
  set_has_currentheat();
  currentheat_ = value;
}

// optional int32 shotsFired = 7;
inline bool Weapon::has_shotsfired() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Weapon::set_has_shotsfired() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Weapon::clear_has_shotsfired() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Weapon::clear_shotsfired() {
  shotsfired_ = 0;
  clear_has_shotsfired();
}
inline ::google::protobuf::int32 Weapon::shotsfired() const {
  return shotsfired_;
}
inline void Weapon::set_shotsfired(::google::protobuf::int32 value) {
  set_has_shotsfired();
  shotsfired_ = value;
}

// optional float timeStartedFiring = 8;
inline bool Weapon::has_timestartedfiring() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Weapon::set_has_timestartedfiring() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Weapon::clear_has_timestartedfiring() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Weapon::clear_timestartedfiring() {
  timestartedfiring_ = 0;
  clear_has_timestartedfiring();
}
inline float Weapon::timestartedfiring() const {
  return timestartedfiring_;
}
inline void Weapon::set_timestartedfiring(float value) {
  set_has_timestartedfiring();
  timestartedfiring_ = value;
}

// optional uint32 shotid = 9;
inline bool Weapon::has_shotid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Weapon::set_has_shotid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Weapon::clear_has_shotid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Weapon::clear_shotid() {
  shotid_ = 0u;
  clear_has_shotid();
}
inline ::google::protobuf::uint32 Weapon::shotid() const {
  return shotid_;
}
inline void Weapon::set_shotid(::google::protobuf::uint32 value) {
  set_has_shotid();
  shotid_ = value;
}

// optional bool purchased = 10;
inline bool Weapon::has_purchased() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Weapon::set_has_purchased() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Weapon::clear_has_purchased() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Weapon::clear_purchased() {
  purchased_ = false;
  clear_has_purchased();
}
inline bool Weapon::purchased() const {
  return purchased_;
}
inline void Weapon::set_purchased(bool value) {
  set_has_purchased();
  purchased_ = value;
}

// optional int32 weaponPrice = 11;
inline bool Weapon::has_weaponprice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Weapon::set_has_weaponprice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Weapon::clear_has_weaponprice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Weapon::clear_weaponprice() {
  weaponprice_ = 0;
  clear_has_weaponprice();
}
inline ::google::protobuf::int32 Weapon::weaponprice() const {
  return weaponprice_;
}
inline void Weapon::set_weaponprice(::google::protobuf::int32 value) {
  set_has_weaponprice();
  weaponprice_ = value;
}

// optional int32 level = 12;
inline bool Weapon::has_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Weapon::set_has_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Weapon::clear_has_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Weapon::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Weapon::level() const {
  return level_;
}
inline void Weapon::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional float range = 13;
inline bool Weapon::has_range() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Weapon::set_has_range() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Weapon::clear_has_range() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Weapon::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float Weapon::range() const {
  return range_;
}
inline void Weapon::set_range(float value) {
  set_has_range();
  range_ = value;
}

// optional float overheatLevel = 14;
inline bool Weapon::has_overheatlevel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Weapon::set_has_overheatlevel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Weapon::clear_has_overheatlevel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Weapon::clear_overheatlevel() {
  overheatlevel_ = 0;
  clear_has_overheatlevel();
}
inline float Weapon::overheatlevel() const {
  return overheatlevel_;
}
inline void Weapon::set_overheatlevel(float value) {
  set_has_overheatlevel();
  overheatlevel_ = value;
}

// optional float heatPerShot = 15;
inline bool Weapon::has_heatpershot() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Weapon::set_has_heatpershot() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Weapon::clear_has_heatpershot() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Weapon::clear_heatpershot() {
  heatpershot_ = 0;
  clear_has_heatpershot();
}
inline float Weapon::heatpershot() const {
  return heatpershot_;
}
inline void Weapon::set_heatpershot(float value) {
  set_has_heatpershot();
  heatpershot_ = value;
}

// optional float chargeStartTime = 16;
inline bool Weapon::has_chargestarttime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Weapon::set_has_chargestarttime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Weapon::clear_has_chargestarttime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Weapon::clear_chargestarttime() {
  chargestarttime_ = 0;
  clear_has_chargestarttime();
}
inline float Weapon::chargestarttime() const {
  return chargestarttime_;
}
inline void Weapon::set_chargestarttime(float value) {
  set_has_chargestarttime();
  chargestarttime_ = value;
}

// -------------------------------------------------------------------

// ClientCommand

// required uint32 shipID = 1;
inline bool ClientCommand::has_shipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCommand::set_has_shipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCommand::clear_has_shipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCommand::clear_shipid() {
  shipid_ = 0u;
  clear_has_shipid();
}
inline ::google::protobuf::uint32 ClientCommand::shipid() const {
  return shipid_;
}
inline void ClientCommand::set_shipid(::google::protobuf::uint32 value) {
  set_has_shipid();
  shipid_ = value;
}

// optional sint32 forwardAcceleration = 2;
inline bool ClientCommand::has_forwardacceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCommand::set_has_forwardacceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCommand::clear_has_forwardacceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCommand::clear_forwardacceleration() {
  forwardacceleration_ = 0;
  clear_has_forwardacceleration();
}
inline ::google::protobuf::int32 ClientCommand::forwardacceleration() const {
  return forwardacceleration_;
}
inline void ClientCommand::set_forwardacceleration(::google::protobuf::int32 value) {
  set_has_forwardacceleration();
  forwardacceleration_ = value;
}

// optional sint32 rightAcceleration = 3;
inline bool ClientCommand::has_rightacceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientCommand::set_has_rightacceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientCommand::clear_has_rightacceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientCommand::clear_rightacceleration() {
  rightacceleration_ = 0;
  clear_has_rightacceleration();
}
inline ::google::protobuf::int32 ClientCommand::rightacceleration() const {
  return rightacceleration_;
}
inline void ClientCommand::set_rightacceleration(::google::protobuf::int32 value) {
  set_has_rightacceleration();
  rightacceleration_ = value;
}

// optional sint32 upAcceleration = 4;
inline bool ClientCommand::has_upacceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientCommand::set_has_upacceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientCommand::clear_has_upacceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientCommand::clear_upacceleration() {
  upacceleration_ = 0;
  clear_has_upacceleration();
}
inline ::google::protobuf::int32 ClientCommand::upacceleration() const {
  return upacceleration_;
}
inline void ClientCommand::set_upacceleration(::google::protobuf::int32 value) {
  set_has_upacceleration();
  upacceleration_ = value;
}

// optional bool brake = 5;
inline bool ClientCommand::has_brake() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientCommand::set_has_brake() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientCommand::clear_has_brake() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientCommand::clear_brake() {
  brake_ = false;
  clear_has_brake();
}
inline bool ClientCommand::brake() const {
  return brake_;
}
inline void ClientCommand::set_brake(bool value) {
  set_has_brake();
  brake_ = value;
}

// optional float yawSpeed = 6;
inline bool ClientCommand::has_yawspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientCommand::set_has_yawspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientCommand::clear_has_yawspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientCommand::clear_yawspeed() {
  yawspeed_ = 0;
  clear_has_yawspeed();
}
inline float ClientCommand::yawspeed() const {
  return yawspeed_;
}
inline void ClientCommand::set_yawspeed(float value) {
  set_has_yawspeed();
  yawspeed_ = value;
}

// optional float rollSpeed = 7;
inline bool ClientCommand::has_rollspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientCommand::set_has_rollspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientCommand::clear_has_rollspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientCommand::clear_rollspeed() {
  rollspeed_ = 0;
  clear_has_rollspeed();
}
inline float ClientCommand::rollspeed() const {
  return rollspeed_;
}
inline void ClientCommand::set_rollspeed(float value) {
  set_has_rollspeed();
  rollspeed_ = value;
}

// optional float pitchSpeed = 8;
inline bool ClientCommand::has_pitchspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientCommand::set_has_pitchspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientCommand::clear_has_pitchspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientCommand::clear_pitchspeed() {
  pitchspeed_ = 0;
  clear_has_pitchspeed();
}
inline float ClientCommand::pitchspeed() const {
  return pitchspeed_;
}
inline void ClientCommand::set_pitchspeed(float value) {
  set_has_pitchspeed();
  pitchspeed_ = value;
}

// optional bool fire = 9;
inline bool ClientCommand::has_fire() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientCommand::set_has_fire() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientCommand::clear_has_fire() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientCommand::clear_fire() {
  fire_ = false;
  clear_has_fire();
}
inline bool ClientCommand::fire() const {
  return fire_;
}
inline void ClientCommand::set_fire(bool value) {
  set_has_fire();
  fire_ = value;
}

// optional uint32 curWeapon = 10;
inline bool ClientCommand::has_curweapon() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientCommand::set_has_curweapon() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientCommand::clear_has_curweapon() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientCommand::clear_curweapon() {
  curweapon_ = 0u;
  clear_has_curweapon();
}
inline ::google::protobuf::uint32 ClientCommand::curweapon() const {
  return curweapon_;
}
inline void ClientCommand::set_curweapon(::google::protobuf::uint32 value) {
  set_has_curweapon();
  curweapon_ = value;
}

// optional float mouseX = 11;
inline bool ClientCommand::has_mousex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientCommand::set_has_mousex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientCommand::clear_has_mousex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientCommand::clear_mousex() {
  mousex_ = 0;
  clear_has_mousex();
}
inline float ClientCommand::mousex() const {
  return mousex_;
}
inline void ClientCommand::set_mousex(float value) {
  set_has_mousex();
  mousex_ = value;
}

// optional float mouseY = 12;
inline bool ClientCommand::has_mousey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientCommand::set_has_mousey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientCommand::clear_has_mousey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientCommand::clear_mousey() {
  mousey_ = 0;
  clear_has_mousey();
}
inline float ClientCommand::mousey() const {
  return mousey_;
}
inline void ClientCommand::set_mousey(float value) {
  set_has_mousey();
  mousey_ = value;
}

// optional uint32 lastReceivedGameStateId = 13;
inline bool ClientCommand::has_lastreceivedgamestateid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientCommand::set_has_lastreceivedgamestateid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientCommand::clear_has_lastreceivedgamestateid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientCommand::clear_lastreceivedgamestateid() {
  lastreceivedgamestateid_ = 0u;
  clear_has_lastreceivedgamestateid();
}
inline ::google::protobuf::uint32 ClientCommand::lastreceivedgamestateid() const {
  return lastreceivedgamestateid_;
}
inline void ClientCommand::set_lastreceivedgamestateid(::google::protobuf::uint32 value) {
  set_has_lastreceivedgamestateid();
  lastreceivedgamestateid_ = value;
}

// -------------------------------------------------------------------

// Timer

// optional float timeStarted = 1;
inline bool Timer::has_timestarted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timer::set_has_timestarted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timer::clear_has_timestarted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timer::clear_timestarted() {
  timestarted_ = 0;
  clear_has_timestarted();
}
inline float Timer::timestarted() const {
  return timestarted_;
}
inline void Timer::set_timestarted(float value) {
  set_has_timestarted();
  timestarted_ = value;
}

// optional float countDownTime = 2;
inline bool Timer::has_countdowntime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timer::set_has_countdowntime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timer::clear_has_countdowntime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timer::clear_countdowntime() {
  countdowntime_ = 0;
  clear_has_countdowntime();
}
inline float Timer::countdowntime() const {
  return countdowntime_;
}
inline void Timer::set_countdowntime(float value) {
  set_has_countdowntime();
  countdowntime_ = value;
}

// optional float timePaused = 3;
inline bool Timer::has_timepaused() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timer::set_has_timepaused() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timer::clear_has_timepaused() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timer::clear_timepaused() {
  timepaused_ = 0;
  clear_has_timepaused();
}
inline float Timer::timepaused() const {
  return timepaused_;
}
inline void Timer::set_timepaused(float value) {
  set_has_timepaused();
  timepaused_ = value;
}

// optional bool isPaused = 4;
inline bool Timer::has_ispaused() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Timer::set_has_ispaused() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Timer::clear_has_ispaused() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Timer::clear_ispaused() {
  ispaused_ = false;
  clear_has_ispaused();
}
inline bool Timer::ispaused() const {
  return ispaused_;
}
inline void Timer::set_ispaused(bool value) {
  set_has_ispaused();
  ispaused_ = value;
}

// optional bool isRunning = 5;
inline bool Timer::has_isrunning() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Timer::set_has_isrunning() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Timer::clear_has_isrunning() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Timer::clear_isrunning() {
  isrunning_ = false;
  clear_has_isrunning();
}
inline bool Timer::isrunning() const {
  return isrunning_;
}
inline void Timer::set_isrunning(bool value) {
  set_has_isrunning();
  isrunning_ = value;
}

// -------------------------------------------------------------------

// GameState

// repeated .ast.Entity entity = 1;
inline int GameState::entity_size() const {
  return entity_.size();
}
inline void GameState::clear_entity() {
  entity_.Clear();
}
inline const ::ast::Entity& GameState::entity(int index) const {
  return entity_.Get(index);
}
inline ::ast::Entity* GameState::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::ast::Entity* GameState::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
GameState::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
GameState::mutable_entity() {
  return &entity_;
}

// required double gameTime = 2;
inline bool GameState::has_gametime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameState::set_has_gametime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameState::clear_has_gametime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameState::clear_gametime() {
  gametime_ = 0;
  clear_has_gametime();
}
inline double GameState::gametime() const {
  return gametime_;
}
inline void GameState::set_gametime(double value) {
  set_has_gametime();
  gametime_ = value;
}

// optional uint32 playerShip = 3;
inline bool GameState::has_playership() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameState::set_has_playership() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameState::clear_has_playership() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameState::clear_playership() {
  playership_ = 0u;
  clear_has_playership();
}
inline ::google::protobuf::uint32 GameState::playership() const {
  return playership_;
}
inline void GameState::set_playership(::google::protobuf::uint32 value) {
  set_has_playership();
  playership_ = value;
}

// optional .ast.Timer levelTimer = 4;
inline bool GameState::has_leveltimer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameState::set_has_leveltimer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameState::clear_has_leveltimer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameState::clear_leveltimer() {
  if (leveltimer_ != NULL) leveltimer_->::ast::Timer::Clear();
  clear_has_leveltimer();
}
inline const ::ast::Timer& GameState::leveltimer() const {
  return leveltimer_ != NULL ? *leveltimer_ : *default_instance_->leveltimer_;
}
inline ::ast::Timer* GameState::mutable_leveltimer() {
  set_has_leveltimer();
  if (leveltimer_ == NULL) leveltimer_ = new ::ast::Timer;
  return leveltimer_;
}
inline ::ast::Timer* GameState::release_leveltimer() {
  clear_has_leveltimer();
  ::ast::Timer* temp = leveltimer_;
  leveltimer_ = NULL;
  return temp;
}

// optional int32 curLevel = 5;
inline bool GameState::has_curlevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameState::set_has_curlevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameState::clear_has_curlevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameState::clear_curlevel() {
  curlevel_ = 0;
  clear_has_curlevel();
}
inline ::google::protobuf::int32 GameState::curlevel() const {
  return curlevel_;
}
inline void GameState::set_curlevel(::google::protobuf::int32 value) {
  set_has_curlevel();
  curlevel_ = value;
}

// optional uint32 id = 6;
inline bool GameState::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameState::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameState::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameState::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 GameState::id() const {
  return id_;
}
inline void GameState::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// CollisionMessage

// optional uint32 gamestateid = 1;
inline bool CollisionMessage::has_gamestateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionMessage::set_has_gamestateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionMessage::clear_has_gamestateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionMessage::clear_gamestateid() {
  gamestateid_ = 0u;
  clear_has_gamestateid();
}
inline ::google::protobuf::uint32 CollisionMessage::gamestateid() const {
  return gamestateid_;
}
inline void CollisionMessage::set_gamestateid(::google::protobuf::uint32 value) {
  set_has_gamestateid();
  gamestateid_ = value;
}

// repeated uint32 collider = 2 [packed = true];
inline int CollisionMessage::collider_size() const {
  return collider_.size();
}
inline void CollisionMessage::clear_collider() {
  collider_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::collider(int index) const {
  return collider_.Get(index);
}
inline void CollisionMessage::set_collider(int index, ::google::protobuf::uint32 value) {
  collider_.Set(index, value);
}
inline void CollisionMessage::add_collider(::google::protobuf::uint32 value) {
  collider_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::collider() const {
  return collider_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_collider() {
  return &collider_;
}

// repeated uint32 wall_top = 3 [packed = true];
inline int CollisionMessage::wall_top_size() const {
  return wall_top_.size();
}
inline void CollisionMessage::clear_wall_top() {
  wall_top_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_top(int index) const {
  return wall_top_.Get(index);
}
inline void CollisionMessage::set_wall_top(int index, ::google::protobuf::uint32 value) {
  wall_top_.Set(index, value);
}
inline void CollisionMessage::add_wall_top(::google::protobuf::uint32 value) {
  wall_top_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_top() const {
  return wall_top_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_top() {
  return &wall_top_;
}

// repeated uint32 wall_bottom = 4 [packed = true];
inline int CollisionMessage::wall_bottom_size() const {
  return wall_bottom_.size();
}
inline void CollisionMessage::clear_wall_bottom() {
  wall_bottom_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_bottom(int index) const {
  return wall_bottom_.Get(index);
}
inline void CollisionMessage::set_wall_bottom(int index, ::google::protobuf::uint32 value) {
  wall_bottom_.Set(index, value);
}
inline void CollisionMessage::add_wall_bottom(::google::protobuf::uint32 value) {
  wall_bottom_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_bottom() const {
  return wall_bottom_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_bottom() {
  return &wall_bottom_;
}

// repeated uint32 wall_left = 5 [packed = true];
inline int CollisionMessage::wall_left_size() const {
  return wall_left_.size();
}
inline void CollisionMessage::clear_wall_left() {
  wall_left_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_left(int index) const {
  return wall_left_.Get(index);
}
inline void CollisionMessage::set_wall_left(int index, ::google::protobuf::uint32 value) {
  wall_left_.Set(index, value);
}
inline void CollisionMessage::add_wall_left(::google::protobuf::uint32 value) {
  wall_left_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_left() const {
  return wall_left_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_left() {
  return &wall_left_;
}

// repeated uint32 wall_right = 6 [packed = true];
inline int CollisionMessage::wall_right_size() const {
  return wall_right_.size();
}
inline void CollisionMessage::clear_wall_right() {
  wall_right_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_right(int index) const {
  return wall_right_.Get(index);
}
inline void CollisionMessage::set_wall_right(int index, ::google::protobuf::uint32 value) {
  wall_right_.Set(index, value);
}
inline void CollisionMessage::add_wall_right(::google::protobuf::uint32 value) {
  wall_right_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_right() const {
  return wall_right_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_right() {
  return &wall_right_;
}

// repeated uint32 wall_front = 7 [packed = true];
inline int CollisionMessage::wall_front_size() const {
  return wall_front_.size();
}
inline void CollisionMessage::clear_wall_front() {
  wall_front_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_front(int index) const {
  return wall_front_.Get(index);
}
inline void CollisionMessage::set_wall_front(int index, ::google::protobuf::uint32 value) {
  wall_front_.Set(index, value);
}
inline void CollisionMessage::add_wall_front(::google::protobuf::uint32 value) {
  wall_front_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_front() const {
  return wall_front_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_front() {
  return &wall_front_;
}

// repeated uint32 wall_back = 8 [packed = true];
inline int CollisionMessage::wall_back_size() const {
  return wall_back_.size();
}
inline void CollisionMessage::clear_wall_back() {
  wall_back_.Clear();
}
inline ::google::protobuf::uint32 CollisionMessage::wall_back(int index) const {
  return wall_back_.Get(index);
}
inline void CollisionMessage::set_wall_back(int index, ::google::protobuf::uint32 value) {
  wall_back_.Set(index, value);
}
inline void CollisionMessage::add_wall_back(::google::protobuf::uint32 value) {
  wall_back_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CollisionMessage::wall_back() const {
  return wall_back_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CollisionMessage::mutable_wall_back() {
  return &wall_back_;
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 sourceid = 1;
inline bool ChatMessage::has_sourceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_sourceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_sourceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_sourceid() {
  sourceid_ = 0u;
  clear_has_sourceid();
}
inline ::google::protobuf::uint32 ChatMessage::sourceid() const {
  return sourceid_;
}
inline void ChatMessage::set_sourceid(::google::protobuf::uint32 value) {
  set_has_sourceid();
  sourceid_ = value;
}

// optional string text = 2;
inline bool ChatMessage::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ChatMessage::text() const {
  return *text_;
}
inline void ChatMessage::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChatMessage::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChatMessage::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ChatMessage::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreateEntityMessage

// optional uint32 createEntityMessageid = 1;
inline bool CreateEntityMessage::has_createentitymessageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateEntityMessage::set_has_createentitymessageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateEntityMessage::clear_has_createentitymessageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateEntityMessage::clear_createentitymessageid() {
  createentitymessageid_ = 0u;
  clear_has_createentitymessageid();
}
inline ::google::protobuf::uint32 CreateEntityMessage::createentitymessageid() const {
  return createentitymessageid_;
}
inline void CreateEntityMessage::set_createentitymessageid(::google::protobuf::uint32 value) {
  set_has_createentitymessageid();
  createentitymessageid_ = value;
}

// repeated .ast.Entity entity = 2;
inline int CreateEntityMessage::entity_size() const {
  return entity_.size();
}
inline void CreateEntityMessage::clear_entity() {
  entity_.Clear();
}
inline const ::ast::Entity& CreateEntityMessage::entity(int index) const {
  return entity_.Get(index);
}
inline ::ast::Entity* CreateEntityMessage::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::ast::Entity* CreateEntityMessage::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::Entity >&
CreateEntityMessage::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::Entity >*
CreateEntityMessage::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// Frame

// repeated .ast.CollisionMessage collision_message = 1;
inline int Frame::collision_message_size() const {
  return collision_message_.size();
}
inline void Frame::clear_collision_message() {
  collision_message_.Clear();
}
inline const ::ast::CollisionMessage& Frame::collision_message(int index) const {
  return collision_message_.Get(index);
}
inline ::ast::CollisionMessage* Frame::mutable_collision_message(int index) {
  return collision_message_.Mutable(index);
}
inline ::ast::CollisionMessage* Frame::add_collision_message() {
  return collision_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >&
Frame::collision_message() const {
  return collision_message_;
}
inline ::google::protobuf::RepeatedPtrField< ::ast::CollisionMessage >*
Frame::mutable_collision_message() {
  return &collision_message_;
}

// optional .ast.GameState gameState = 9;
inline bool Frame::has_gamestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_gamestate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_gamestate() {
  if (gamestate_ != NULL) gamestate_->::ast::GameState::Clear();
  clear_has_gamestate();
}
inline const ::ast::GameState& Frame::gamestate() const {
  return gamestate_ != NULL ? *gamestate_ : *default_instance_->gamestate_;
}
inline ::ast::GameState* Frame::mutable_gamestate() {
  set_has_gamestate();
  if (gamestate_ == NULL) gamestate_ = new ::ast::GameState;
  return gamestate_;
}
inline ::ast::GameState* Frame::release_gamestate() {
  clear_has_gamestate();
  ::ast::GameState* temp = gamestate_;
  gamestate_ = NULL;
  return temp;
}

// optional uint32 shipid = 10;
inline bool Frame::has_shipid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_shipid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_shipid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_shipid() {
  shipid_ = 0u;
  clear_has_shipid();
}
inline ::google::protobuf::uint32 Frame::shipid() const {
  return shipid_;
}
inline void Frame::set_shipid(::google::protobuf::uint32 value) {
  set_has_shipid();
  shipid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ast

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Network_2fgamestate_2eproto__INCLUDED
